# 설계와 연구 (Design and Research)

2003년 1월 [^1]

이 나라를 방문한 사람들은 미국인들이 대화를 시작할 때 "무슨 일을 하세요?"라고 묻는 것을 좋아한다는 사실에 종종 놀랍니다. 저는 이 질문을 좋아한 적이 없습니다. 이 질문에 명쾌한 대답을 한 적도 거의 없습니다. 하지만 마침내 이 문제를 해결했다고 생각합니다. 이제 누군가 제게 무엇을 하냐고 물으면, 저는 그들의 눈을 똑바로 바라보며 "저는 Lisp의 새로운 방언(dialect)을 설계하고 있습니다."라고 말합니다. 무엇을 하냐는 질문을 받는 것을 좋아하지 않는 분들께 이 답변을 추천합니다. 그러면 대화는 즉시 다른 주제로 흘러갈 것입니다.

저는 스스로 프로그래밍 언어에 대한 연구(research)를 하고 있다고 생각하지 않습니다. 저는 건물이나 의자, 혹은 새로운 글꼴(typeface)을 설계하는 것처럼, 단지 언어를 설계하고 있을 뿐입니다. 저는 새로운 것을 발견하려고 노력하는 것이 아닙니다. 단지 프로그래밍하기 좋은 언어를 만들고 싶을 뿐입니다. 어떤 면에서는 이 가정 덕분에 일이 훨씬 쉬워집니다.

설계(design)와 연구(research)의 차이는 새로움(new)이냐 좋음(good)이냐의 문제인 것 같습니다. 설계는 새로울 필요는 없지만, 좋아야 합니다. 연구는 좋을 필요는 없지만, 새로워야 합니다. 저는 이 두 경로가 정점에서 수렴한다고 생각합니다. 최고의 설계는 새로운 아이디어를 사용함으로써 이전의 것들을 능가하며, 최고의 연구는 새로울 뿐만 아니라 실제로 해결할 가치가 있는 문제들을 해결합니다. 따라서 궁극적으로 우리는 같은 목적지를 향해 나아가고 있으며, 단지 다른 방향에서 접근하고 있을 뿐입니다.

오늘 제가 말씀드릴 내용은, 여러분의 목표물을 '뒷모습'에서 바라보는 것입니다. 프로그래밍 언어를 연구 주제가 아닌 설계 문제로 다룰 때 무엇이 달라지는가? 가장 큰 차이점은 사용자에 더 집중한다는 것입니다. 설계는 '이것이 누구를 위한 것이며, 그들은 무엇을 필요로 하는가?'를 질문하며 시작됩니다. 예를 들어, 훌륭한 건축가는 자신이 만든 설계를 사용자에게 강요하는 것으로 시작하는 것이 아니라, 대상 사용자를 연구하고 그들이 무엇을 필요로 하는지 파악하는 것에서 시작합니다.

제가 "그들이 원하는 것(what they want)"이 아니라 "그들이 필요로 하는 것(what they need)"이라고 말한 것에 주목해 주십시오. 제가 설계자로서 일하는 것이 마치 고객이 시키는 대로만 하는 사람처럼 일하는 것이라는 인상을 주려는 것은 아닙니다. 예술 분야에서는 분야마다 다르겠지만, 고객이 말하는 것을 그대로 만드는 사람들이 최고의 작업을 한다고는 생각하지 않습니다.

"고객은 언제나 옳다"는 말은 좋은 설계의 기준이 사용자에게 얼마나 잘 작동하는지로 판단된다는 점에서 의미가 있습니다. 모든 사람을 지루하게 만드는 소설을 쓰거나, 앉기 끔찍하게 불편한 의자를 만든다면, 그것은 명백히 잘못된 일입니다. 그 소설이나 의자가 가장 진보된 이론적 원칙에 따라 설계되었다고 말하는 것은 변명이 되지 못합니다.

하지만 사용자에게 잘 작동하는 것을 만드는 것이 반드시 사용자가 말하는 것을 그대로 만드는 것을 의미하지는 않습니다. 사용자는 가능한 모든 선택지를 알지 못하며, 종종 자신이 진정으로 원하는 것에 대해 착각하기도 합니다. 이 역설에 대한 답은, 사용자를 위해 설계해야 하지만, 단순히 사용자가 원한다고 말하는 것을 만드는 것이 아니라 사용자가 필요로 하는 것을 설계해야 한다는 것이라고 생각합니다.

이는 마치 의사가 되는 것과 같습니다. 의사는 환자의 증상만 치료할 수는 없습니다. 환자가 증상을 말할 때, 의사는 실제로 무엇이 문제인지 파악하고 그것을 치료해야 합니다.

이러한 사용자 중심 사고는 훌륭한 설계 관행 대부분을 도출할 수 있는 공리(axiom)와 같으며, 대부분의 설계 문제가 중심을 잡는 기준이 됩니다. 훌륭한 설계가 사용자의 필요를 충족해야 한다면, 사용자는 누구인가? 설계는 사용자를 위한 것이어야 한다고 말할 때, 훌륭한 설계가 어떤 최저 수준(lowest common denominator)을 목표로 한다는 의미는 아닙니다. 원하는 사용자 그룹을 선택할 수 있습니다. 예를 들어 도구를 설계한다면, 초심자부터 전문가까지 누구를 대상으로 할지 선택할 수 있으며, 한 그룹에게 좋은 설계가 다른 그룹에게는 나쁜 설계일 수도 있습니다. 중요한 것은 사용자 그룹을 반드시 선택해야 한다는 것입니다. 의도된 사용자를 참조하지 않고는 좋거나 나쁜 설계에 대해 이야기조차 할 수 없다고 생각합니다.

의도된 사용자에 설계자 자신이 포함될 때 가장 좋은 설계를 얻을 가능성이 높습니다. 자신이 포함되지 않은 그룹을 위해 무언가를 설계할 때는, 자신보다 덜 세련된(sophisticated) 사람들을 대상으로 하는 경향이 있습니다. 더 세련된 사람들을 대상으로 하는 것이 아니라요. 이는 문제가 됩니다. 왜냐하면 사용자를 깔보는 것은, 아무리 좋은 의도라 할지라도, 필연적으로 설계자를 타락시키는 것처럼 보이기 때문입니다. 미국의 주택 프로젝트 중 극소수만이 건축가 자신이 거주할 것을 예상하고 설계되었다고 의심합니다. 프로그래밍 언어에서도 같은 점을 볼 수 있습니다. C, Lisp, Smalltalk는 설계자 자신이 사용하기 위해 만들어졌습니다. Cobol, Ada, Java는 다른 사람들이 사용하기 위해 만들어졌습니다.

만약 당신이 바보들을 위한 것을 설계하고 있다고 생각한다면, 설령 바보들을 위한 것이라 해도 좋은 것을 설계하고 있을 확률은 낮습니다. 가장 수준 높은(sophisticated) 사용자들을 위해 설계한다 하더라도, 결국 인간을 위해 설계하는 것입니다. 연구의 경우는 다릅니다. 수학에서는 증명을 더 짧게 만드는 추상화(abstraction)를 선택하지, 인간이 이해하기 쉬운 추상화를 선택하지는 않습니다. 이는 일반적으로 과학 전반에 걸쳐 사실이라고 생각합니다. 과학적 아이디어는 인체공학적(ergonomic)일 필요는 없습니다.

예술 분야에서는 상황이 매우 다릅니다. 설계는 전적으로 사람에 관한 것입니다. 인간의 몸은 이상한 것이지만, 의자를 설계할 때 그것이 바로 당신이 설계하는 대상이며, 이를 피할 방법은 없습니다. 모든 예술은 인간의 흥미와 한계에 맞춰야 합니다. 예를 들어 회화에서, 다른 모든 조건이 같다면 사람이 등장하는 그림이 그렇지 않은 그림보다 더 흥미로울 것입니다. 르네상스 시대의 위대한 회화들이 모두 사람들로 가득 차 있다는 것이 단순히 역사의 우연은 아닙니다. 만약 그렇지 않았다면, 회화라는 매체는 지금과 같은 명성을 얻지 못했을 것입니다.

좋든 싫든, 프로그래밍 언어도 사람들을 위한 것이며, 인간의 뇌 또한 인간의 몸만큼이나 울퉁불퉁하고 독특한(idiosyncratic) 특징을 가지고 있다고 생각합니다. 어떤 아이디어는 사람들이 쉽게 이해하지만, 어떤 아이디어는 그렇지 않습니다. 예를 들어, 우리는 세부 사항을 다루는 데 있어 매우 제한된 능력을 가지고 있는 것 같습니다. 프로그래밍 언어가 애초에 좋은 아이디어인 이유가 바로 이 사실 때문입니다. 만약 우리가 세부 사항을 처리할 수 있다면, 기계어(machine language)로 프로그래밍할 수 있었을 것입니다.

또한, 언어는 주로 완성된 프로그램의 형식이 아니라, 프로그램이 개발되어야 하는 대상이라는 점을 기억하십시오. 예술 분야의 사람이라면 누구나 두 가지 상황에 대해 다른 매체(medium)를 원할 수 있다는 것을 말해줄 것입니다. 예를 들어 대리석은 완성된 아이디어를 위한 멋지고 내구성 있는 매체이지만, 새로운 아이디어를 개발하는 데에는 끔찍하게 유연하지 못한(inflexible) 매체입니다.

프로그램은 증명과 마찬가지로, 과거에 수많은 실패한 시도(false starts)들이 갈라져 나왔던 트리(tree) 구조에서 가지를 쳐낸(pruned) 결과물입니다. 따라서 언어의 시험대는 단순히 완성된 프로그램이 그 안에서 얼마나 깔끔하게 보이는지가 아니라, 완성된 프로그램에 이르기까지의 경로가 얼마나 깔끔했는가입니다. 우아한(elegant) 완성 프로그램을 제공하는 설계 선택이 반드시 우아한 설계 과정을 제공하지는 않을 수 있습니다. 예를 들어, 저는 중첩된 백틱(backquotes)으로 가득 찬 매크로 정의 매크로 몇 개를 작성했는데, 지금은 보석처럼 보이지만, 그것을 작성하는 데에는 몇 시간의 가장 추악한 시행착오(trial and error)가 필요했고, 솔직히 말해 아직도 그것들이 정확한지 완전히 확신하지 못합니다.

우리는 종종 언어의 시험대가 완성된 프로그램이 그 안에서 얼마나 보기 좋게 보이는지에 있는 것처럼 행동합니다. 같은 프로그램을 두 언어로 작성한 것을 보고 한 버전이 훨씬 짧을 때, 그것은 매우 설득력 있게 보입니다. 예술의 관점에서 이 문제를 접근하면, 이러한 종류의 시험에 덜 의존하게 됩니다. 대리석과 같은 프로그래밍 언어로 끝나고 싶지는 않을 것입니다.

예를 들어, 소프트웨어 개발에서 대화형 탑 레벨(interactive toplevel), Lisp에서는 읽기-평가-출력 루프(read-eval-print loop)라고 불리는 것을 갖는 것은 엄청난 이점입니다. 그리고 이를 갖는 것은 언어 설계에 실질적인 영향을 미칩니다. 예를 들어, 변수를 사용하기 전에 미리 선언해야 하는 언어에서는 잘 작동하지 않을 것입니다. 탑 레벨에 단순히 표현식(expression)을 입력할 때, 변수 x에 어떤 값을 할당하고 나서 x를 이용해 작업을 시작하고 싶을 것입니다. 먼저 x의 타입을 선언해야 하는 것을 원하지는 않을 것입니다. 이 전제들 중 어느 하나에 대해 이의를 제기할 수도 있겠지만, 편리함을 위해 언어에 탑 레벨이 있어야 하고, 필수 타입 선언(mandatory type declarations)이 탑 레벨과 양립할 수 없다면, 타입 선언을 의무화하는 언어는 프로그래밍하기 편리할 수 없습니다.

실제로는 좋은 설계를 얻으려면 사용자에게 가까이 다가가고, 가까이 머물러야 합니다. 실제 사용자들을 대상으로 꾸준히, 특히 초기 단계에서 아이디어를 조정(calibrate)해야 합니다. 제인 오스틴의 소설이 그렇게 훌륭한 이유 중 하나는 그녀가 가족에게 소설을 소리 내어 읽어주었기 때문입니다. 그렇기 때문에 그녀는 자기 탐닉적인(self-indulgently) 예술적인 풍경 묘사나 허세 부리는(pretentious) 철학적 논의에 빠지지 않았습니다. (철학은 존재하지만, 레이블처럼 덧붙여진 것이 아니라 이야기에 짜여 들어가 있습니다.) 평범한 '문학적인' 소설을 열고, 마치 자신이 쓴 것처럼 친구들에게 소리 내어 읽는다고 상상해 보십시오. 그러면 그런 종류의 글이 독자에게 얼마나 부담스러운지 매우 생생하게 느낄 것입니다.

소프트웨어 세계에서는 이 아이디어가 "Worse is Better"로 알려져 있습니다. 사실, "Worse is Better"라는 개념에는 여러 아이디어가 혼합되어 있으며, 이것이 사람들이 그것이 실제로 더 나쁜 것이 더 나은 것인지 아닌지를 여전히 논쟁하는 이유입니다. 하지만 그 혼합물 속 주요 아이디어 중 하나는, 새로운 것을 구축할 때는 가능한 한 빨리 사용자 앞에 프로토타입(prototype)을 내놓아야 한다는 것입니다.

대안적인 접근법은 "Hail Mary" 전략이라고 불릴 수 있습니다. 프로토타입을 빨리 내놓고 점진적으로 개선하는 대신, 한 번의 긴 터치다운 패스(touchdown pass)로 완전하고 최종적인 제품을 만들려고 시도하는 것입니다. 제가 알기로는 이것은 재앙을 부르는 처방입니다. 인터넷 거품(Internet bubble) 시기 동안 수많은 스타트업이 이런 방식으로 스스로 파멸했습니다. 작동했던 사례는 들어본 적이 없습니다.

소프트웨어 세계 밖에 있는 사람들이 깨닫지 못할 수도 있는 것은, "Worse is Better"가 예술 전반에 걸쳐 발견된다는 사실입니다. 예를 들어 소묘(drawing)에서는 이 아이디어가 르네상스 시대에 발견되었습니다. 이제 거의 모든 소묘 교사는 정확한 그림을 얻는 올바른 방법은 대상의 윤곽선을 따라 천천히 작업하는 것이 아니라고 말할 것입니다. 왜냐하면 오류가 누적되어 결국 선들이 만나지 않는다는 것을 발견하게 될 것이기 때문입니다. 대신, 대략적으로 올바른 위치에 몇 개의 빠른 선을 그리고, 점차 이 초기 스케치를 다듬어야 합니다.

대부분의 분야에서는 프로토타입이 전통적으로 다른 재료로 만들어졌습니다. 금속으로 새길 서체(typeface)는 처음에 종이에 붓으로 디자인되었습니다. 청동으로 주조될 조각상은 밀랍으로 모델링되었습니다. 태피스트리(tapestry)에 수놓을 패턴은 먹물로 종이에 그려졌습니다. 돌로 지을 건물은 목재로 축소하여 테스트되었습니다. 15세기에 유화(oil paint)가 처음 인기를 얻었을 때 그것을 그렇게 흥미롭게 만든 것은, 프로토타입으로 실제 완성 작업을 할 수 있었다는 점입니다. 원한다면 예비 스케치를 할 수도 있었지만, 그것에 구속되지 않았습니다. 세부 사항을 모두 다듬고, 그림을 완성해 나가면서 주요 변경까지도 할 수 있었습니다.

소프트웨어에서도 이렇게 할 수 있습니다. 프로토타입은 단순한 모델일 필요는 없습니다. 완성된 제품으로 개선해 나갈 수 있습니다. 가능하다면 항상 이렇게 해야 한다고 생각합니다. 이를 통해 과정 중에 얻는 새로운 통찰력(insight)을 활용할 수 있습니다. 하지만 아마도 더 중요한 것은, 이것이 사기(morale)에 좋다는 것입니다. 사기는 설계의 핵심입니다. 사람들이 이것에 대해 더 많이 이야기하지 않는다는 것이 놀랍습니다. 제 첫 미술 선생님 중 한 분이 제게 말했습니다. 무언가를 그릴 때 지루하다면, 그 그림은 지루하게 보일 것이라고요.

예를 들어 건물을 그려야 하는데, 벽돌 하나하나를 개별적으로 그리기로 결정했다고 가정해 봅시다. 원한다면 그렇게 할 수 있지만, 중간에 지루해져서 각 벽돌을 관찰하는 대신 기계적으로 벽돌을 그리기 시작하면, 단순히 벽돌을 암시(suggested)하기만 했을 때보다 그림이 더 나쁘게 보일 것입니다.

프로토타입을 점진적으로 개선하여 무언가를 구축하는 것은 당신을 몰입(engaged) 상태로 유지시켜 주기 때문에 사기에 좋습니다. 소프트웨어에서는 제 규칙은 이것입니다. 항상 작동하는 코드를 가지십시오. 한 시간 안에 테스트할 수 있는 것을 쓰고 있다면, 당신에게 동기를 부여할 즉각적인 보상의 전망이 있는 것입니다. 예술, 특히 유화에서도 마찬가지입니다. 대부분의 화가는 흐릿한 스케치로 시작하여 점차 그것을 다듬습니다. 이런 방식으로 작업한다면, 원칙적으로 완성되지 않은 것처럼 보이는 것으로 하루를 마감할 필요가 결코 없습니다. 실제로 화가들 사이에는 이런 속담도 있습니다: "그림은 결코 완성되지 않는다, 단지 작업을 멈출 뿐이다." 이 아이디어는 소프트웨어 작업을 해본 사람이라면 누구나 익숙할 것입니다.

사기는 수준이 낮은(unsophisticated) 사용자를 위해 무언가를 설계하기 어려운 또 다른 이유입니다. 자신이 좋아하지 않는 것에 계속 흥미를 느끼는 것은 어렵습니다. 좋은 것을 만들기 위해서는, "와, 이거 정말 대단해"라고 생각해야지, "이 똥 같은 것, 저 바보들이 좋아하겠지"라고 생각해서는 안 됩니다.

설계는 인간을 위한 것을 만드는 것을 의미합니다. 하지만 인간인 것은 사용자가 전부는 아닙니다. 설계자 또한 인간입니다.

지금까지 제가 "설계자"에 대해 이야기하고 있다는 점에 주목하십시오. 설계는 일반적으로 제대로 되려면 한 사람의 통제하에 있어야 합니다. 하지만 여러 사람이 연구 프로젝트에 협력하는 것은 가능한 것 같습니다. 이것은 연구와 설계 사이의 가장 흥미로운 차이점 중 하나로 보입니다. 예술 분야에는 유명한 협업 사례가 있었지만, 대부분은 핵융합(nuclear fusion)보다는 분자 결합(molecular bonding)의 경우처럼 보입니다. 오페라에서는 한 사람이 대본(libretto)을 쓰고 다른 사람이 음악을 쓰는 것이 일반적입니다. 그리고 르네상스 시대에는 북유럽 출신의 숙련공(journeymen)들이 이탈리아 회화의 배경 풍경을 그리는 데 자주 고용되었습니다. 하지만 이것들은 진정한 협업이 아닙니다. 그것들은 로버트 프로스트의 "좋은 울타리가 좋은 이웃을 만든다(good fences make good neighbors)"는 말의 예시와 더 비슷합니다. 좋은 설계를 서로 붙일 수는 있지만, 개별 프로젝트 내에서는 한 사람이 통제해야 합니다.

훌륭한 설계가 한 사람이 모든 것을 생각해야 한다고 말하는 것은 아닙니다. 당신이 신뢰하는 사람의 조언보다 더 가치 있는 것은 없습니다. 하지만 대화가 끝나면, 무엇을 할지에 대한 결정은 한 사람에게 달려 있어야 합니다. 왜 연구는 협력자들에 의해 수행될 수 있지만 설계는 그렇지 못한 걸까요? 이것은 흥미로운 질문입니다. 저는 답을 모릅니다. 아마도 설계와 연구가 수렴한다면, 최고의 연구 또한 훌륭한 설계이며, 실제로 협력자들에 의해 수행될 수 없을 것입니다. 가장 유명한 과학자들 중 다수는 혼자 작업한 것으로 보입니다. 하지만 이곳에 패턴이 있는지 말할 만큼 충분히 알지는 못합니다. 단지 많은 유명 과학자들이 협업이 덜 일반적이던 시기에 작업했기 때문일 수도 있습니다.

과학 분야의 이야기가 어떻든, 예술 분야에서는 진정한 협업이 극히 드물어 보입니다. 위원회에 의한 설계(Design by committee)는 나쁜 설계의 동의어입니다. 왜 그럴까요? 이 한계를 극복할 방법이 있을까요? 저는 그렇지 않다고 생각하는 경향이 있습니다. 즉, 훌륭한 설계는 독재자(dictator)를 필요로 한다는 것입니다. 한 가지 이유는 훌륭한 설계는 전체적으로 일관성이 있어야 하기 때문입니다. 설계는 단순히 인간을 위한 것이 아니라, 개별 인간을 위한 것입니다. 만약 어떤 설계가 한 사람의 머리에 맞는 아이디어를 나타낸다면, 그 아이디어는 사용자(user)의 머리에도 맞을 것입니다.

[^1]: 이 글은 NEPLS 2002년 가을 회의에서의 기조 연설을 바탕으로 작성되었습니다.