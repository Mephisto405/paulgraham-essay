# 인기 있는 것들 (Being Popular)

2001년 5월
이 글은 새로운 언어에 대한 일종의 사업 계획으로 작성되었습니다. 따라서 좋은 프로그래밍 언어의 가장 중요한 특징인 매우 강력한 추상화가 (당연하다고 생각하기 때문에) 빠져 있습니다.

제 친구 중 한 명이 저명한 운영체제 전문가에게 아주 좋은 프로그래밍 언어를 설계하고 싶다고 말했습니다. 그 전문가는 그것이 시간 낭비가 될 것이라고 말했습니다. 프로그래밍 언어는 그 가치에 따라 인기 있거나 인기 없게 되는 것이 아니며, 따라서 아무리 좋은 언어라도 아무도 사용하지 않을 것이라고 말했습니다. 적어도 그가 설계한 언어에는 그렇게 되었기 때문입니다.
무엇이 언어를 인기 있게 만드는가? 인기 있는 언어가 그 인기를 누릴 자격이 있는가? 좋은 프로그래밍 언어를 정의하려고 노력할 가치가 있는가? 어떻게 하면 그렇게 할 수 있을까?
이 질문들에 대한 답은 해커들을 살펴보고 그들이 무엇을 원하는지 배움으로써 찾을 수 있다고 생각합니다. 프로그래밍 언어는 해커를 위한 것이며, 프로그래밍 언어는 (예를 들어, 의미론이나 컴파일러 설계의 연습이 아니라) 해커가 좋아한다면 프로그래밍 언어로서 좋습니다.

## 1. 인기의 역학

대부분의 사람들이 프로그래밍 언어를 단순히 그 가치에 따라 선택하는 것은 확실히 사실입니다. 대부분의 프로그래머는 다른 사람으로부터 어떤 언어를 사용해야 하는지 지시받습니다. 그러나 저는 그러한 외부 요인이 프로그래밍 언어의 인기에 미치는 영향이 때때로 생각하는 것만큼 크지는 않다고 생각합니다. 저는 해커의 좋은 프로그래밍 언어에 대한 생각이 대부분의 언어 설계자의 생각과 같지 않다는 것이 더 큰 문제라고 생각합니다.
이 둘 사이에서 해커의 의견이 중요합니다. 프로그래밍 언어는 정리가 아닙니다. 그것들은 사람들을 위해 설계된 도구이며, 신발이 사람의 발에 맞게 설계되어야 하는 것처럼 인간의 강점과 약점에 맞게 설계되어야 합니다. 신발을 신었을 때 불편하면, 그것이 조각 작품으로서 얼마나 우아하든 나쁜 신발입니다.
대부분의 프로그래머가 좋은 언어와 나쁜 언어를 구별하지 못할 수도 있습니다. 하지만 이는 다른 어떤 도구와도 다르지 않습니다. 좋은 언어를 설계하려고 노력하는 것이 시간 낭비라는 의미는 아닙니다.
숙련된 해커는 좋은 언어를 보면 알 수 있고, 그것을 사용할 것입니다. 숙련된 해커는 분명히 아주 적은 소수이지만, 그 아주 적은 소수가 모든 좋은 소프트웨어를 작성하며, 그들의 영향력은 나머지 프로그래머들이 그들이 사용하는 언어를 사용하게 만드는 정도입니다. 종종 이것은 단순히 영향력이라기보다는 명령입니다. 숙련된 해커는 종종 다른 프로그래머들에게 어떤 언어를 사용해야 하는지 지시하는 상사나 지도 교수인 사람들입니다.
숙련된 해커의 의견이 프로그래밍 언어의 상대적 인기를 결정하는 유일한 힘은 아닙니다. — 기존 소프트웨어(Cobol)와 과대 광고(Ada, Java)도 역할을 합니다. — 하지만 저는 장기적으로 가장 강력한 힘이라고 생각합니다. 초기 임계 질량과 충분한 시간이 주어지면, 프로그래밍 언어는 아마도 그것이 받을 만한 만큼 인기가 있을 것입니다. 그리고 인기는 좋은 언어와 나쁜 언어를 더욱 구분하게 합니다. 왜냐하면 실제 사용자의 피드백은 항상 개선으로 이어지기 때문입니다. 인기 있는 언어가 그 수명 동안 얼마나 많이 변경되었는지 살펴보십시오. Perl과 Fortran은 극단적인 경우이지만, Lisp조차도 많이 변경되었습니다. 예를 들어 Lisp 1.5에는 매크로가 없었지만, MIT의 해커들이 Lisp를 사용하여 실제 프로그램을 작성하는 데 몇 년을 보낸 후에 나중에 개발되었습니다.[^1]
따라서 언어가 인기를 얻으려면 좋아야 하는지와 상관없이, 언어가 좋으려면 인기가 있어야 한다고 생각합니다. 그리고 계속 좋으려면 인기를 유지해야 합니다. 프로그래밍 언어의 최신 기술은 멈추지 않습니다. 그럼에도 불구하고 오늘날의 Lisp는 1980년대 중반 MIT에서 그랬던 것과 거의 동일합니다. 왜냐하면 Lisp가 충분히 크고 요구 사항이 많은 사용자 기반을 가졌던 마지막 시기가 그때였기 때문입니다.
물론 해커는 언어를 사용하기 전에 그것에 대해 알아야 합니다. 어떻게 소식을 들을 수 있을까요? 다른 해커들로부터요. 하지만 다른 사람들이 그것에 대해 듣기 위해서는 언어를 사용하는 초기 해커 그룹이 있어야 합니다. 이 그룹이 얼마나 커야 하는지 궁금합니다. 얼마나 많은 사용자가 임계 질량을 구성하는가? 즉석에서 말하자면, 스무 명이라고 말할 수 있습니다. 언어에 이십 명의 별도 사용자가 있다면, 즉 스스로 사용하기로 결정한 이십 명의 사용자가 있다면, 저는 그것을 실체라고 간주할 것입니다.
거기에 도달하는 것은 쉽지 않을 것입니다. 제로에서 스무 명으로 가는 것이 스무 명에서 천 명으로 가는 것보다 어렵다는 것에 놀라지 않을 것입니다. 그 초기 이십 명의 사용자를 확보하는 가장 좋은 방법은 아마도 트로이 목마를 사용하는 것일 겁니다. 사람들이 원하는 애플리케이션을 제공하되, 우연히 새로운 언어로 작성되도록 하는 것입니다.

## 2. 외부 요인

프로그래밍 언어의 인기에 영향을 미치는 외부 요인 하나를 인정하는 것으로 시작해 봅시다. 프로그래밍 언어가 인기를 얻으려면 인기 있는 시스템의 스크립팅 언어가 되어야 합니다. Fortran과 Cobol은 초기 IBM 메인프레임의 스크립팅 언어였습니다. C는 Unix의 스크립팅 언어였으며, 나중에는 Perl도 그랬습니다. Tcl은 Tk의 스크립팅 언어입니다. Java와 Javascript는 웹 브라우저의 스크립팅 언어가 될 것으로 의도됩니다.
Lisp는 인기 있는 시스템의 스크립팅 언어가 아니기 때문에 엄청나게 인기 있는 언어가 아닙니다. Lisp가 유지하는 인기는 1960년대와 1970년대 MIT의 스크립팅 언어였던 시대로 거슬러 올라갑니다. 당시 훌륭한 프로그래머 중 많은 수가 어느 시점에 MIT와 관련이 있었습니다. 그리고 1970년대 초, C 이전에 MIT의 Lisp 방언인 MacLisp는 진지한 해커가 사용하고 싶어 하는 유일한 프로그래밍 언어 중 하나였습니다.
오늘날 Lisp는 두 개의 중간 정도 인기 있는 시스템인 Emacs와 Autocad의 스크립팅 언어이며, 그 이유로 저는 오늘날 이루어지는 Lisp 프로그래밍의 대부분이 Emacs Lisp 또는 AutoLisp로 이루어진다고 생각합니다.
프로그래밍 언어는 고립되어 존재하지 않습니다. 해킹(hack)은 타동사입니다. — 해커는 보통 무언가를 해킹합니다. — 그리고 실제로 언어는 그것이 해킹하는 것과 비교하여 평가됩니다. 따라서 인기 있는 언어를 설계하고 싶다면, 언어 이상을 제공하거나 기존 시스템의 스크립팅 언어를 대체하도록 언어를 설계해야 합니다.
Common Lisp가 인기가 없는 이유 중 하나는 그것이 고아이기 때문입니다. 그것은 원래 해킹할 시스템, 즉 Lisp Machine을 가지고 있었습니다. 하지만 Lisp Machine(병렬 컴퓨터와 함께)은 1980년대 범용 프로세서의 증가하는 성능에 의해 짓밟혔습니다. Common Lisp가 Unix의 좋은 스크립팅 언어였다면 인기를 유지했을 수도 있습니다. 유감스럽게도, 그것은 끔찍하게 나쁜 언어입니다.
이 상황을 설명하는 한 가지 방법은 언어가 자체적인 가치로 판단되지 않는다고 말하는 것입니다. 또 다른 관점은 프로그래밍 언어가 실제로 무언가의 스크립팅 언어이지 않은 한 프로그래밍 언어가 아니라는 것입니다. 이것은 놀랍게도 오는 것이 아니라면 불공평하게 보입니다. 프로그래밍 언어가 예를 들어 구현을 갖도록 기대하는 것보다 더 불공평하지 않다고 생각합니다. 그것은 단지 프로그래밍 언어가 무엇인지에 대한 일부일 뿐입니다.
프로그래밍 언어는 물론 좋은 구현을 필요로 하며, 이것은 무료여야 합니다. 기업은 소프트웨어에 돈을 지불하겠지만, 개별 해커는 그렇지 않을 것이고, 당신이 유치해야 하는 것은 해커입니다.
언어에는 또한 그것에 관한 책이 필요합니다. 그 책은 얇고 잘 쓰여야 하며 좋은 예제로 가득해야 합니다. K&R이 여기서 이상적입니다. 현재 저는 언어가 O'Reilly에 의해 출판된 책을 가지고 있어야 한다고 거의 말할 것입니다. 그것이 해커에게 중요한지 여부를 판단하는 기준이 되고 있습니다.
온라인 문서도 있어야 합니다. 사실, 책은 온라인 문서로 시작할 수 있습니다. 하지만 저는 아직 종이 책이 시대에 뒤떨어졌다고 생각하지 않습니다. 그것들의 형식은 편리하며, 출판사에 의해 부과되는 사실상의 검열은 불완전하지만 유용한 필터입니다. 서점은 새로운 언어에 대해 배우는 가장 중요한 장소 중 하나입니다.

## 3. 간결함

어떤 언어든 필요한 세 가지 것—무료 구현, 책, 그리고 해킹할 무언가—를 제공할 수 있다면, 어떻게 하면 해커가 좋아할 만한 언어를 만들 수 있을까요?
해커가 좋아하는 것 중 하나는 간결함입니다. 해커는 수학자나 모더니스트 건축가처럼 게으릅니다. 그들은 모든 불필요한 것을 싫어합니다. 프로그램에 글을 쓰려는 해커가 사용할 언어를, 적어도 잠재의식적으로, 자신이 입력해야 할 총 문자 수에 따라 결정한다고 말하는 것이 진실에서 크게 벗어나지 않을 것입니다. 이것이 해커가 정확히 생각하는 방식이 아니라면, 언어 설계자는 마치 그렇다고 가정하고 작업하는 것이 좋을 것입니다.
사용자에게 영어와 유사하도록 의도된 장황한 표현으로 사용자를 귀엽게 만들려고 하는 것은 실수입니다. Cobol은 이 결함으로 악명 높습니다. 해커는
z = x+y
대신
add x to y giving z
라고 쓰도록 요청받는 것을 자신의 지능에 대한 모욕과 신에 대한 죄의 중간 정도로 간주할 것입니다.
Lisp가 car와 cdr 대신 first와 rest를 사용해야 한다고 말해지기도 했습니다. 왜냐하면 그것이 프로그램을 더 쉽게 읽을 수 있게 할 것이기 때문입니다. 아마도 처음 몇 시간 동안은요. 하지만 해커는 car가 리스트의 첫 번째 요소를 의미하고 cdr이 나머지를 의미한다는 것을 충분히 빨리 배울 수 있습니다. first와 rest를 사용하는 것은 타이핑이 50% 더 많다는 것을 의미합니다. 그리고 그들은 길이도 다르기 때문에, car와 cdr처럼 종종 연속적인 줄에 있는 인자가 정렬되지 않을 것입니다. 저는 코드가 페이지에 어떻게 정렬되는지가 매우 중요하다고 생각합니다. 가변 폭 글꼴로 설정된 Lisp 코드는 거의 읽을 수 없으며, 친구들은 이것이 다른 언어에도 그렇다고 말합니다.
간결함은 강력하게 타입화된 언어가 지는 한 가지 영역입니다. 다른 모든 것이 동등하다면, 아무도 선언의 긴 문구로 프로그램을 시작하고 싶어 하지 않습니다. 암시될 수 있는 것은 무엇이든 암시되어야 합니다.
개별 토큰도 짧아야 합니다. Perl과 Common Lisp는 이 질문에서 반대 극점에 있습니다. Perl 프로그램은 거의 암호화될 정도로 밀집될 수 있는 반면, 내장된 Common Lisp 연산자의 이름은 우스꽝스럽게 깁니다. Common Lisp 설계자들은 사용자들이 이러한 긴 이름을 대신 입력해 주는 텍스트 편집기를 가지고 있을 것으로 예상했을 것입니다. 하지만 긴 이름의 비용은 그것을 입력하는 비용만이 아닙니다. 그것을 읽는 비용과 화면에서 차지하는 공간의 비용도 있습니다.

## 4. 해킹 가능성

해커에게 간결함보다 더 중요한 한 가지가 있습니다: 자신이 원하는 것을 할 수 있는 능력입니다. 프로그래밍 언어의 역사에서 부적절하다고 간주되는 일을 프로그래머가 하지 못하게 하는 데 놀라울 정도로 많은 노력이 투입되었습니다. 이것은 위험하게 거만한 계획입니다. 언어 설계자가 프로그래머가 무엇을 해야 할 필요가 있을지 어떻게 알 수 있을까요? 저는 언어 설계자가 자신의 목표 사용자를 자신으로부터 보호해야 하는 서투른 사람이라기보다는, 자신이 예상하지 못한 일을 필요로 할 천재로 간주하는 것이 더 낫다고 생각합니다. 서투른 사람은 어쨌든 스스로에게 총을 쏘게 될 것입니다. 다른 패키지의 변수를 참조하는 것을 막을 수는 있지만, 잘못된 문제를 해결하기 위해 서투르게 설계된 프로그램을 작성하고 거기에 영원히 시간을 쏟는 것을 막을 수는 없습니다.
훌륭한 프로그래머는 종종 위험하고 좋지 않은 일을 하고 싶어 합니다. 좋지 않다는 것은 언어가 제시하려는 의미론적 외관을 벗어나는 일을 하는 것을 의미합니다. 예를 들어, 추상화의 내부 표현을 얻는 것입니다. 해커는 해킹하는 것을 좋아하며, 해킹은 사물 속으로 들어가 원래 설계자를 두 번 생각하는 것을 의미합니다.
자신이 두 번 생각되도록 하십시오.
어떤 도구를 만들든 사람들은 당신이 의도하지 않은 방식으로 그것을 사용하며, 이는 특히 프로그래밍 언어와 같이 매우 정교한 도구에서 더욱 그렇습니다. 많은 해커는 당신이 상상하지도 못했던 방식으로 당신의 의미론적 모델을 미세 조정하고 싶어 할 것입니다. 허용하라고 말합니다. 런타임 시스템(예: 가비지 컬렉터)을 위험에 빠뜨리지 않는 한 프로그래머에게 가능한 한 많은 내부 사항에 접근할 수 있도록 하십시오.
Common Lisp에서 저는 종종 구조체(struct)의 필드를 반복하고 싶었습니다. — 예를 들어 삭제된 객체에 대한 참조를 모두 제거하거나 초기화되지 않은 필드를 찾기 위해. 저는 구조체가 기본적으로 벡터일 뿐이라는 것을 알고 있습니다. 그렇지만 저는 어떤 구조체에든 호출할 수 있는 일반적인 함수를 작성할 수 없습니다. 구조체가 의미하는 바가 그것이기 때문에 이름으로만 필드에 접근할 수 있습니다.
해커는 큰 프로그램에서 의도된 모델을 한두 번만 전복시키기를 원할 수 있습니다. 하지만 그렇게 할 수 있다는 것은 큰 차이를 만듭니다. 그리고 이것은 단지 문제를 해결하는 것 이상의 문제입니다. 여기에 즐거움의 종류도 있습니다. 해커들은 외과 의사가 거친 내장을 탐색하는 비밀스러운 즐거움, 십대 소년이 여드름을 짜는 비밀스러운 즐거움을 공유합니다.[^2] 적어도 소년들에게는 어떤 종류의 끔찍함은 매혹적입니다. Maxim 잡지는 핀업 사진과 끔찍한 사고 사진을 혼합한 연간 사진집을 발행합니다. 그들은 자신의 독자를 알고 있습니다.
역사적으로 Lisp는 해커들이 원하는 대로 하도록 하는 데 좋았습니다. Common Lisp의 정치적 올바름은 일탈입니다. 초기 Lisp는 모든 것에 접근할 수 있게 해주었습니다. 다행히 그 정신의 상당 부분은 매크로에 보존되어 있습니다. 소스 코드를 임의로 변환할 수 있다는 것은 정말 놀라운 일입니다.
클래식 매크로는 실제 해커의 도구입니다. — 간단하고 강력하며 위험합니다. 그것들이 무엇을 하는지는 이해하기 매우 쉽습니다. 매크로 인자에 함수를 호출하고, 그 반환값이 매크로 호출 대신 삽입됩니다. 위생적 매크로(Hygienic macros)는 반대 원칙을 구현합니다. 그것들은 당신이 그것들이 하는 일을 이해하지 못하도록 보호하려고 합니다. 저는 위생적 매크로가 한 문장으로 설명되는 것을 들어본 적이 없습니다. 그리고 그것들은 프로그래머가 원하는 것을 결정하는 것의 위험성에 대한 고전적인 예입니다. 위생적 매크로는 다른 것들 중에서도 변수 캡처로부터 저를 보호하기 위한 것이지만, 저는 일부 매크로에서 변수 캡처를 원합니다.
정말로 좋은 언어는 깨끗하고 더러워야 합니다. — 깨끗하게 설계되어 잘 이해되고 매우 직교적인 연산자의 작은 코어를 가지되, 해커가 원하는 대로 할 수 있도록 하는 의미에서 더러워야 합니다. C가 이렇습니다. 초기 Lisp도 그랬습니다. 진정한 해커의 언어는 항상 약간 멋없는 특징을 가질 것입니다.
좋은 프로그래밍 언어는 "소프트웨어 엔지니어링"이라는 문구를 사용하는 사람들을 불쾌하게 만드는 특징을 가져야 합니다. 연속체의 다른 쪽 끝에는 Ada와 Pascal과 같은 언어들이 있으며, 이들은 교육에는 좋지만 그 외에는 별로 좋지 않은 규범의 모델입니다.

## 5. 일회용 프로그램

해커에게 매력적이려면, 언어는 그들이 쓰고 싶어하는 종류의 프로그램을 작성하는 데 좋아야 합니다. 그리고 그것은 놀랍게도 일회용 프로그램을 작성하는 데 좋아야 함을 의미합니다.
일회용 프로그램은 제한된 작업을 위해 빠르게 작성하는 프로그램입니다. — 시스템 관리 작업을 자동화하거나 시뮬레이션을 위한 테스트 데이터를 생성하거나 데이터를 한 형식에서 다른 형식으로 변환하는 프로그램입니다. 일회용 프로그램에 대한 놀라운 점은, 제2차 세계 대전 중 많은 미국 대학에 지어진 "임시" 건물처럼, 종종 폐기되지 않는다는 것입니다. 많은 프로그램이 실제 기능과 실제 사용자를 가진 실제 프로그램으로 진화합니다.
최고의 대규모 프로그램은 처음부터 크게 설계된 것, 즉 후버 댐과 같은 것보다 이렇게 시작된다는 속설이 있습니다. 처음부터 큰 것을 구축하는 것은 무섭습니다. 사람들이 너무 큰 프로젝트를 맡으면 압도당합니다. 프로젝트가 좌초되거나 결과물이 메마르고 뻣뻣해집니다. — 실제 도심이 아닌 쇼핑몰, 로마가 아닌 브라질리아, C가 아닌 Ada.
또 다른 큰 프로그램을 얻는 방법은 일회용 프로그램으로 시작하여 계속 개선하는 것입니다. 이 접근 방식은 덜 위협적이며, 프로그램 설계는 진화로부터 이익을 얻습니다. 하나하나 살펴보면 대부분의 큰 프로그램이 이렇게 개발되었다는 것을 알게 될 것이라고 생각합니다. 그리고 이렇게 진화한 프로그램들은 아마도 여전히 처음 작성된 언어로 작성될 것입니다. 왜냐하면 정치적인 이유를 제외하고는 프로그램을 이식하는 경우는 드물기 때문입니다. 따라서 역설적으로, 큰 시스템에 사용되는 언어를 만들고 싶다면, 일회용 프로그램을 작성하는 데 좋게 만들어야 합니다. 왜냐하면 큰 시스템은 거기서 나오기 때문입니다.
Perl은 이 아이디어의 인상적인 예입니다. 그것은 일회용 프로그램을 작성하기 위해 설계되었을 뿐만 아니라 그 자체로 거의 일회용 프로그램이었습니다. Perl은 보고서 생성을 위한 유틸리티 모음으로 시작했으며, 사람들이 그 안에서 작성한 일회용 프로그램이 커짐에 따라 프로그래밍 언어로 진화했습니다. Perl 5(만약 그렇다면)가 되어서야 언어가 "진지한" 프로그램을 작성하는 데 적합해졌지만, 이미 엄청나게 인기가 있었습니다.
무엇이 언어를 일회용 프로그램에 좋게 만드는가? 시작하기 위해, 그것은 쉽게 사용할 수 있어야 합니다. 일회용 프로그램은 한 시간 안에 작성할 것으로 예상하는 것입니다. 따라서 언어는 사용자가 이미 사용 중인 컴퓨터에 설치되어 있어야 할 것입니다. 사용하기 전에 설치해야 하는 것이어서는 안 됩니다. 거기에 있어야 합니다. C는 운영 체제와 함께 제공되었기 때문에 거기에 있었습니다. Perl은 원래 시스템 관리자를 위한 도구였고, 당신의 시스템 관리자가 이미 설치했기 때문에 거기에 있었습니다.
하지만 사용 가능성은 설치된 것 이상을 의미합니다. 명령줄 인터페이스를 가진 대화식 언어는 컴파일하고 별도로 실행해야 하는 언어보다 더 사용할 수 있습니다. 인기 있는 프로그래밍 언어는 대화식이어야 하며 빨리 시작해야 합니다.
일회용 프로그램에서 원하는 또 다른 것은 간결함입니다. 간결함은 항상 해커에게 매력적이며, 한 시간 안에 끝낼 것으로 예상하는 프로그램에서는 더욱 그렇습니다.

## 6. 라이브러리

물론 간결함의 궁극은 프로그램이 이미 작성되어 있고 그것을 호출하기만 하는 것입니다. 그리고 이것은 프로그래밍 언어에서 점점 더 중요해질 기능이라고 생각하는 라이브러리 함수에 우리를 이끕니다. Perl은 문자열 조작을 위한 대규모 라이브러리를 가지고 있기 때문에 승리합니다. 이 종류의 라이브러리 함수는 종종 데이터 변환이나 추출을 위해 원래 작성된 일회용 프로그램에 특히 중요합니다. 많은 Perl 프로그램은 아마도 몇 가지 라이브러리 호출을 함께 연결하는 것에서 시작될 것입니다.
저는 앞으로 50년 동안 프로그래밍 언어에서 일어날 많은 발전이 라이브러리 함수와 관련될 것이라고 생각합니다. 저는 미래의 프로그래밍 언어가 핵심 언어만큼 신중하게 설계된 라이브러리를 가질 것이라고 생각합니다. 프로그래밍 언어 설계는 언어를 강력하게 또는 약하게 타입화할지, 객체 지향적으로 할지, 함수형으로 할지 등에 대한 것이 아니라 훌륭한 라이브러리를 설계하는 방법에 관한 것이 될 것입니다. 타입 시스템 설계 방법에 대해 생각하는 것을 좋아하는 언어 설계자들은 이것에 몸서리칠 수 있습니다.
이것은 거의 애플리케이션을 작성하는 것과 같습니다! 안타깝게도. 언어는 프로그래머를 위한 것이고, 라이브러리는 프로그래머에게 필요한 것입니다.
좋은 라이브러리를 설계하는 것은 어렵습니다. 단순히 많은 코드를 작성하는 문제가 아닙니다. 라이브러리가 너무 커지면 때로는 필요한 함수를 찾는 데 자체 코드를 작성하는 것보다 더 오래 걸릴 수 있습니다. 라이브러리는 핵심 언어와 마찬가지로 작고 직교적인 연산자 세트를 사용하여 설계되어야 합니다. 프로그래머가 자신이 필요로 하는 라이브러리 호출이 무엇인지 추측할 수 있어야 합니다.
라이브러리는 Common Lisp가 부족한 한 가지입니다. 문자열 조작을 위한 기본적인 라이브러리만 있고, 운영 체제와 통신하기 위한 라이브러리는 거의 없습니다. 역사적인 이유로 Common Lisp는 OS가 존재하지 않는 것처럼 가장하려고 합니다. 그리고 OS와 통신할 수 없기 때문에 Common Lisp의 내장 연산자만으로는 진지한 프로그램을 작성하기 어렵습니다. 일부 구현별 해킹도 사용해야 하며, 실제로 이러한 해킹은 원하는 모든 것을 제공하지 않는 경향이 있습니다. Common Lisp가 강력한 문자열 라이브러리와 좋은 OS 지원을 가졌다면 해커들은 Lisp를 훨씬 더 높이 평가할 것입니다.

## 7. 문법

Lisp의 문법, 또는 더 정확하게는 문법의 부재가 언젠가 인기를 얻을 수 있을까요? 저는 이 질문에 대한 답을 모릅니다. Lisp가 현재 인기 없는 주된 이유가 문법은 아니라고 생각합니다. Common Lisp는 익숙하지 않은 문법보다 더 나쁜 문제를 가지고 있습니다. 저는 접두사 문법에 익숙하지만 여전히 기본적으로 Perl을 사용하는 몇몇 프로그래머를 알고 있습니다. 왜냐하면 Perl은 강력한 문자열 라이브러리를 가지고 있고 OS와 통신할 수 있기 때문입니다.
접두사 표기법에는 두 가지 가능한 문제가 있습니다. — 그것이 프로그래머에게 익숙하지 않다는 것과, 충분히 밀집되어 있지 않다는 것입니다. Lisp 세계의 일반적인 통념은 첫 번째 문제가 실제 문제라는 것입니다. 저는 확신하지 않습니다. 네, 접두사 표기법은 일반 프로그래머를 당황하게 합니다. 하지만 일반 프로그래머의 의견은 중요하지 않다고 생각합니다. 언어는 숙련된 해커가 그것들에 대해 어떻게 생각하는지에 따라 인기를 얻거나 잃게 되며, 저는 숙련된 해커들이 접두사 표기법을 다룰 수 있을 것이라고 생각합니다. Perl 문법은 상당히 이해하기 어려울 수 있지만, 그것이 Perl의 인기에 방해가 되지 않았습니다. 오히려 Perl 컬트를 키우는 데 도움이 되었을지도 모릅니다.
더 심각한 문제는 접두사 표기법의 산만함입니다. 숙련된 해커에게는 그것이 정말 문제입니다. 아무도 `a[x,y]`라고 쓸 수 있을 때 `(aref a x y)`라고 쓰고 싶어 하지 않습니다.
이 특정 경우, 문제를 요리조리 피할 수 있는 방법이 있습니다. 데이터 구조를 인덱스에 대한 함수처럼 취급하면 `(a x y)`라고 쓸 수 있으며, 이는 Perl 형식보다 훨씬 짧습니다. 유사한 트릭으로 다른 유형의 표현식을 단축할 수 있습니다.
들여쓰기를 의미있게 만듦으로써 많은 괄호를 제거하거나(선택적으로 만들 수 있습니다) 제거할 수 있습니다. 프로그래머는 어차피 코드를 그렇게 읽습니다. — 들여쓰기가 한 가지를 말하고 구분 기호가 다른 것을 말할 때, 우리는 들여쓰기를 따릅니다. 들여쓰기를 의미있게 취급하는 것은 이러한 일반적인 버그의 원인을 제거할 뿐만 아니라 프로그램을 더 짧게 만들 것입니다.
때때로 중첩 표기법이 읽기 쉽습니다. 특히 수학 표현식의 경우 더욱 그렇습니다. 저는 제 프로그래밍 생활 내내 Lisp를 사용했지만, 여전히 접두사 수학 표현식을 자연스럽다고 생각하지 않습니다. 그럼에도 불구하고, 특히 코드를 생성할 때, 어떤 수의 인자도 받는 연산자를 갖는 것이 편리합니다. 따라서 중첩 표기법이 있다면, 그것은 아마도 일종의 읽기 매크로로 구현되어야 할 것입니다.
우리가 근본적인 s-표현식으로 잘 이해되는 방식으로 번역된다면, Lisp에 문법을 도입하는 것을 종교적으로 반대해서는 안 된다고 생각합니다. Lisp에는 이미 상당한 양의 문법이 있습니다. 아무도 그것을 사용하도록 강요하지 않는 한, 더 많은 것을 도입하는 것이 반드시 나쁜 것은 아닙니다. Common Lisp에서는 일부 구분 기호가 언어를 위해 예약되어 있어, 적어도 일부 설계자는 미래에 더 많은 문법을 도입할 의도가 있었음을 시사합니다.
Common Lisp에서 가장 터무니없이 비-Lisp적인 문법 중 하나는 형식 문자열에서 발생합니다. format은 그 자체로 언어이며, 그 언어는 Lisp가 아닙니다. Lisp에 더 많은 문법을 도입할 계획이 있다면, 형식 지정자는 그것에 포함될 수 있습니다. 매크로가 다른 종류의 코드를 생성하는 방식과 마찬가지로 형식 지정자를 생성할 수 있다면 좋을 것입니다.
저명한 Lisp 해커 중 한 명은 CLTL 사본이 format 섹션에서 열린다고 말했습니다. 제 것도 그렇습니다. 이것은 아마도 개선의 여지를 나타냅니다. 또한 프로그램이 많은 I/O를 한다는 것을 의미할 수도 있습니다.

## 8. 효율성

모든 사람이 알듯이 좋은 언어는 빠른 코드를 생성해야 합니다. 하지만 실제로는 언어 설계에서 하는 일에서 주로 빠른 코드가 나오지 않는다고 생각합니다. Knuth가 오래전에 지적했듯이, 속도는 특정 병목 현상에서만 중요합니다. 그리고 많은 프로그래머가 이미 관찰했듯이, 이러한 병목 현상이 어디인지 매우 자주 잘못 판단합니다.
따라서 실제로 빠른 코드를 얻는 방법은, 예를 들어 언어를 강력하게 타입화하는 것이 아니라, 매우 좋은 프로파일러를 갖는 것입니다. 프로그램의 모든 호출에서 모든 인자의 타입을 알 필요는 없습니다. 병목 현상에서 인자의 타입을 선언할 수 있어야 합니다. 그리고 더 중요한 것은, 병목 현상이 어디인지 알아낼 수 있어야 합니다.
Lisp에 대한 한 가지 불만은 무엇이 비싼지 말하기 어렵다는 것입니다. 이것은 사실일 수 있습니다. 매우 추상적인 언어를 원한다면 피할 수 없을 수도 있습니다. 그리고 어쨌든 좋은 프로파일링이 문제를 해결하는 데 크게 도움이 될 것이라고 생각합니다. — 곧 무엇이 비싼지 알게 될 것입니다.
여기서 문제의 일부는 사회적입니다. 언어 설계자들은 빠른 컴파일러를 작성하는 것을 좋아합니다. 그들은 자신의 기술을 그렇게 측정합니다. 그들은 프로파일러를 최소한 부가 기능으로 생각합니다. 하지만 실제로는 좋은 프로파일러가 빠른 코드를 생성하는 컴파일러보다 언어로 작성된 실제 프로그램의 속도를 향상시키는 데 더 많은 것을 할 수 있습니다. 여기서도 언어 설계자들은 사용자들과 다소 동떨어져 있습니다. 그들은 잘못된 문제를 약간 해결하는 데 정말 좋은 일을 합니다.
활성 프로파일러를 갖는 것이 좋을 것입니다. — 프로그래머가 요청할 때까지 기다리는 대신 성능 데이터를 프로그래머에게 푸시하는 것입니다. 예를 들어, 편집기는 프로그래머가 소스 코드를 편집할 때 빨간색으로 병목 현상을 표시할 수 있습니다. 또 다른 접근 방식은 실행 중인 프로그램에서 무슨 일이 일어나고 있는지 어떤 식으로든 나타내는 것입니다. 이것은 수많은 실행 중인 프로그램을 볼 수 있는 서버 기반 애플리케이션에서 특히 큰 이점이 될 것입니다. 활성 프로파일러는 프로그램이 실행될 때 메모리에서 무슨 일이 일어나고 있는지 그래픽으로 보여주거나, 무슨 일이 일어나고 있는지 알려주는 소리를 낼 수도 있습니다.
소리는 문제에 대한 좋은 신호입니다. 제가 일했던 한 곳에서는 웹 서버에 무슨 일이 일어나고 있는지 보여주는 커다란 다이얼 보드가 있었습니다. 바늘은 움직일 때 약간의 소리를 내는 작은 서보 모터에 의해 움직였습니다. 제 책상에서는 보드를 볼 수 없었지만, 서버에 문제가 있을 때 소리를 통해 즉시 알 수 있다는 것을 발견했습니다.
효율이 떨어지는 알고리즘을 자동으로 감지하는 프로파일러를 작성하는 것도 가능할 것입니다. 특정 메모리 액세스 패턴이 나쁜 알고리즘의 확실한 징후로 판명될 것이라고 놀라지 않을 것입니다. 컴퓨터 안에서 돌아다니는 작은 사람이 우리 프로그램을 실행하고 있다면, 그는 연방 정부 직원의 이야기만큼 길고 애처로운 이야기를 가지고 있을 것입니다. 저는 종종 프로세서에게 여러 번의 헛수고를 보내는 느낌을 받지만, 그것이 무엇을 하고 있는지 볼 좋은 방법을 가진 적이 없습니다.
많은 Lisp가 이제 바이트 코드로 컴파일되어 인터프리터에 의해 실행됩니다. 이것은 일반적으로 구현을 더 쉽게 이식하기 위해 수행되지만, 유용한 언어 기능이 될 수 있습니다. 바이트 코드를 언어의 공식적인 부분으로 만들고, 프로그래머가 병목 현상에서 인라인 바이트 코드를 사용할 수 있도록 하는 것이 좋을 것입니다. 그러면 그러한 최적화도 이식 가능할 것입니다.
최종 사용자에게 인식되는 속도의 특성이 변하고 있을 수 있습니다. 서버 기반 애플리케이션의 부상으로, 점점 더 많은 프로그램이 I/O 바운드가 될 것입니다. I/O를 빠르게 만드는 것이 가치가 있을 것입니다. 언어는 간단하고 빠르며 형식화된 출력 함수와 같은 직접적인 측정뿐만 아니라 캐싱 및 영구 객체와 같은 깊은 구조적 변경에도 도움이 될 수 있습니다.
사용자는 응답 시간에 관심이 있습니다. 하지만 또 다른 종류의 효율성이 점점 더 중요해질 것입니다. — 프로세서당 지원할 수 있는 동시 사용자 수입니다. 향후 몇 년 안에 작성될 많은 흥미로운 애플리케이션은 서버 기반이 될 것이며, 서버당 사용자 수는 그러한 애플리케이션을 호스팅하는 모든 사람에게 중요한 질문입니다. 서버 기반 애플리케이션을 제공하는 비즈니스의 자본 비용에서 이것은 나누는 값입니다.
수년 동안 대부분의 최종 사용자 애플리케이션에서 효율성은 그다지 중요하지 않았습니다. 개발자는 각 사용자가 점점 더 강력한 프로세서를 책상에 가지고 있다고 가정할 수 있었습니다. 그리고 파킨슨 법칙에 따라 소프트웨어는 사용 가능한 리소스를 사용하도록 확장되었습니다. 서버 기반 애플리케이션에서는 이것이 바뀔 것입니다.
그 세계에서는 하드웨어와 소프트웨어가 함께 제공될 것입니다. 서버 기반 애플리케이션을 제공하는 기업에게는 서버당 지원할 수 있는 사용자 수가 손익 계산서에 큰 영향을 미칠 것입니다.
어떤 애플리케이션에서는 프로세서가 제한 요인이 될 것이며, 실행 속도가 최적화하는 데 가장 중요한 것이 될 것입니다. 하지만 종종 메모리가 한계가 될 것입니다. — 동시 사용자 수는 각 사용자의 데이터에 필요한 메모리 양에 의해 결정될 것입니다. 언어도 여기서 도움이 될 수 있습니다. 스레드에 대한 좋은 지원은 모든 사용자가 단일 힙을 공유할 수 있도록 합니다. 영구 객체 및/또는 지연 로딩에 대한 언어 수준 지원도 도움이 될 수 있습니다.

## 9. 시간

인기 있는 언어가 필요로 하는 마지막 요소는 시간입니다. 아무도 사라질지도 모르는 언어로 프로그램을 작성하고 싶어 하지 않습니다. 많은 프로그래밍 언어가 그렇게 됩니다. 따라서 대부분의 해커는 언어를 사용하기 전에 몇 년 동안 존재할 때까지 기다리는 경향이 있습니다.
훌륭한 새로운 것들의 발명가들은 종종 이것을 발견하고 놀라지만, 사람들에게 메시지를 전달하는 데는 시간이 필요합니다. 제 친구는 누군가 그에게 무언가를 요청할 때 처음에는 거의 아무것도 하지 않습니다. 그는 사람들이 때때로 원하지 않는 것을 요청한다는 것을 알고 있습니다. 자신의 시간을 낭비하지 않기 위해, 그는 세 번째 또는 네 번째로 요청받을 때까지 기다립니다. — 그 시점에서 요청하는 사람은 상당히 짜증이 날 수 있지만, 적어도 그들은 아마도 그들이 요청하는 것을 정말로 원할 것입니다.
대부분의 사람들은 새로운 것에 대해 비슷한 필터링을 하도록 배웠습니다. 그들은 그것에 대해 열 번 듣기 전까지는 주의를 기울이지 않습니다. 그들은 완벽하게 정당화됩니다. — 신기술의 대다수는 시간 낭비로 판명되어 결국 사라집니다. VRML 학습을 연기함으로써, 저는 그것을 전혀 배울 필요가 없었습니다.
따라서 새로운 것을 발명한 사람은 사람들이 그것을 이해하기 시작하기 전에 몇 년 동안 메시지를 반복해야 할 것으로 예상해야 합니다. 우리가 제가 아는 한 최초의 웹 서버 기반 애플리케이션을 작성했다고 생각하지만, 사람들이 그것이 다운로드될 필요가 없다는 것을 이해하는 데 몇 년이 걸렸습니다. 그들이 어리석은 것이 아니었습니다. 그들은 단지 우리를 무시했을 뿐입니다.
좋은 소식은 단순한 반복이 문제를 해결한다는 것입니다. 여러분이 할 일은 여러분의 이야기를 계속 말하는 것이고, 결국 사람들은 듣기 시작할 것입니다. 사람들이 당신이 거기에 있다는 것을 알아차릴 때가 아니라, 당신이 여전히 거기에 있다는 것을 알아차릴 때 그들은 주의를 기울입니다.
모멘텀을 얻는 데 보통 시간이 걸리는 것은 좋습니다. 대부분의 기술은 출시된 후에도 상당히 발전합니다. — 특히 프로그래밍 언어는 더욱 그렇습니다. 새로운 기술에게 몇 년 동안 소수의 얼리 어답터에게만 사용되는 것보다 더 나은 것은 없습니다. 얼리 어답터는 정교하고 요구 사항이 많으며, 기술에 남아 있는 결함을 빠르게 제거합니다. 사용자가 적을 때 모든 사용자와 긴밀하게 접촉할 수 있습니다. 그리고 얼리 어답터는 시스템을 개선하더라도 약간의 고장이 발생하더라도 용서합니다.
신기술이 도입되는 두 가지 방법이 있습니다. — 유기적 성장 방식과 빅뱅 방식입니다. 유기적 성장 방식은 고전적인 경험에 의존하는 자금 부족한 차고 스타트업의 예시입니다. 몇 명의 사람들이 어둠 속에서 작업하며 새로운 기술을 개발합니다. 그들은 마케팅 없이 출시하고 처음에는 소수의 (열성적인) 사용자만 갖습니다. 그들은 기술을 계속 개선하고, 그동안 사용자 기반은 구전으로 성장합니다. 그들은 알기도 전에 커집니다.
다른 접근 방식인 빅뱅 방식은 VC 투자, 대대적인 마케팅을 받은 스타트업의 예시입니다. 그들은 제품 개발을 서두르고, 엄청난 홍보와 함께 출시하며, 즉시 (그들이 바라는 대로) 대규모 사용자 기반을 갖습니다.
일반적으로 차고의 사람들은 빅뱅 사람들을 부러워합니다. 빅뱅 사람들은 세련되고 자신감 있으며 VC로부터 존경받습니다. 그들은 모든 것의 최고를 감당할 수 있으며, 출시를 둘러싼 PR 캠페인은 유명인이 되는 부작용을 갖습니다. 유기적 성장 사람들은 차고에 앉아 가난하고 사랑받지 못한다고 느낍니다. 그럼에도 불구하고 저는 그들이 자신을 불쌍하게 여긴다고 생각하는 경우가 많다고 생각합니다.
유기적 성장은 빅뱅 방식보다 더 나은 기술과 더 부유한 창업자를 산출하는 것으로 보입니다. 오늘날의 지배적인 기술을 보면, 대부분이 유기적으로 성장했다는 것을 알게 될 것입니다.
이 패턴은 회사에만 적용되는 것이 아닙니다. 후원 연구에서도 볼 수 있습니다. Multics와 Common Lisp는 빅뱅 프로젝트였고, Unix와 MacLisp는 유기적 성장 프로젝트였습니다.

## 10. 재설계

"최고의 글은 고쳐 쓰는 것이다." E. B. White가 썼습니다. 모든 훌륭한 작가는 이를 알고 있으며, 소프트웨어에도 마찬가지입니다. 디자인의 가장 중요한 부분은 재설계입니다. 특히 프로그래밍 언어는 충분히 재설계되지 않습니다.
훌륭한 소프트웨어를 작성하려면 두 가지 반대되는 아이디어를 동시에 머릿속에 두어야 합니다. 젊은 해커의 순진한 능력에 대한 믿음과 동시에 베테랑의 회의감이 필요합니다. 당신은 당신의 뇌의 절반으로
이것이 얼마나 어렵겠어?
라고 생각하면서, 다른 절반으로는
절대 작동하지 않을 거야
라고 생각해야 합니다.
요점은 이것에 실제 모순이 없다는 것을 깨닫는 것입니다. 해결할 가능성에 대해서는 낙관적이어야 하지만, 지금까지 얻은 어떤 해결책의 가치에 대해서는 회의적이어야 합니다.
훌륭한 일을 하는 사람들은 종종 자신이 작업하는 모든 것이 좋지 않다고 생각합니다. 다른 사람들은 그들이 한 것을 보고 경탄하지만, 창작자는 걱정으로 가득합니다. 이 패턴은 우연이 아닙니다. — 그것은 작품을 좋게 만든 걱정입니다.
희망과 걱정을 균형 있게 유지하면, 두 다리가 자전거를 앞으로 움직이는 것처럼 프로젝트를 추진할 것입니다. 혁신 엔진의 두 주기 첫 번째 단계에서는 해결할 수 있다는 자신감에 영감을 받아 문제에 대해 열정적으로 작업합니다. 두 번째 단계에서는 아침의 냉철한 빛 속에서 자신이 한 일을 살펴보고 모든 결점을 매우 명확하게 봅니다. 하지만 당신의 비판적인 정신이 희망을 능가하지 않는 한, 당신은 인정할 수 없이 불완전한 시스템을 보고, 나머지 길을 가는 것이 얼마나 어렵겠어? 라고 생각하며, 사이클을 계속할 수 있을 것입니다.
두 가지 힘의 균형을 유지하는 것은 어렵습니다. 젊은 해커에게는 낙관주의가 지배적입니다. 그들은 무언가를 생산하고, 그것이 훌륭하다고 확신하며, 절대 개선하지 않습니다. 늙은 해커에게는 회의주의가 지배적이며, 야심찬 프로젝트에 감히 착수조차 하지 않을 것입니다.
재설계 사이클을 계속 유지하는 데 도움이 되는 것은 무엇이든 좋습니다. 산문은 만족할 때까지 반복해서 다시 쓸 수 있습니다. 하지만 소프트웨어는 일반적으로 충분히 재설계되지 않습니다. 산문에는 독자가 있지만, 소프트웨어에는 사용자가 있습니다.
작가가 에세이를 다시 쓴다면, 오래된 버전을 읽은 사람들이 새롭게 도입된 비호환성으로 인해 자신의 생각이 깨졌다고 불평할 가능성은 낮습니다. 사용자는 양날의 검입니다. 그들은 언어를 개선하는 데 도움을 줄 수 있지만, 개선을 방해할 수도 있습니다. 따라서 사용자를 신중하게 선택하고, 그 수를 천천히 늘리십시오. 사용자를 갖는 것은 최적화와 같습니다. 현명한 경로는 그것을 지연시키는 것입니다. 또한 일반적인 규칙으로, 우리는 지금 생각하는 것보다 더 많이 변경할 수 있습니다. 변화를 도입하는 것은 반창고를 떼어내는 것과 같습니다. — 고통은 느끼는 즉시 거의 기억이 됩니다.
친숙하지 않은 시스템으로 인해 사용자가 변경에 대한 불만을 제기하는 상황이 발생할 수 있습니다.
위원회가 디자인한 언어를 갖는 것이 좋지 않다는 것은 모두가 알고 있습니다. 위원회는 나쁜 디자인을 산출합니다. 하지만 위원회의 가장 큰 위험은 재설계를 방해한다고 생각합니다. 변경 사항을 도입하는 데 너무 많은 노력이 들기 때문에 아무도 신경 쓰고 싶어 하지 않습니다. 위원회가 결정한 것은 대부분의 구성원이 좋아하지 않더라도 그대로 유지되는 경향이 있습니다.
심지어 두 명으로 구성된 위원회조차도 재설계를 방해합니다. 이것은 특히 두 사람이 작성한 소프트웨어 조각 간의 인터페이스에서 발생합니다. 인터페이스를 변경하려면 둘 다 동시에 변경하는 데 동의해야 합니다. 따라서 인터페이스는 전혀 변경되지 않는 경향이 있으며, 이는 시스템의 가장 임시적인 부분 중 하나인 경향이 있기 때문에 문제가 됩니다.
여기서 한 가지 해결책은 인터페이스가 수직이 아니라 수평이 되도록 시스템을 설계하는 것일 수 있습니다. — 모듈이 항상 추상화의 수직으로 쌓인 층이 되도록 하는 것입니다. 그러면 인터페이스는 결국 그 중 하나에 의해 소유될 것입니다. 두 레벨 중 낮은 레벨은 위 레벨이 작성된 언어이거나, 그 경우 낮은 레벨이 인터페이스를 소유하거나, 노예인 경우이며, 그 경우 인터페이스는 위 레벨에 의해 결정될 수 있습니다.

## 11. Lisp

이 모든 것이 새로운 Lisp에 희망이 있다는 것을 의미합니다. Lisp를 포함하여 해커가 원하는 것을 제공하는 모든 언어에 희망이 있습니다. 해커들이 Lisp의 이상함에 꺼려한다고 생각하는 것이 실수였다고 생각합니다. 이 위안이 되는 환상은 Lisp, 적어도 Common Lisp의 실제 문제를 보지 못하게 했을 수도 있습니다. 즉, 해커가 하고 싶어 하는 일을 하는 데 형편없다는 것입니다. 해커의 언어는 강력한 라이브러리와 해킹할 무언가가 필요합니다. Common Lisp는 둘 다 없습니다. 해커의 언어는 간결하고 해킹 가능합니다. Common Lisp는 그렇지 않습니다.
좋은 소식은 Lisp 자체가 아니라 Common Lisp가 형편없다는 것입니다. 우리가 진정한 해커의 언어인 새로운 Lisp를 개발할 수 있다면, 해커들이 그것을 사용할 것이라고 생각합니다. 그들은 작업을 수행하는 언어를 사용할 것입니다. 우리는 이 새로운 Lisp가 다른 언어보다 중요한 작업을 더 잘 수행하도록 해야 합니다.
역사가 약간의 격려를 제공합니다. 시간이 지남에 따라 연속적인 새로운 프로그래밍 언어는 Lisp에서 점점 더 많은 기능을 가져왔습니다. 만든 언어가 Lisp가 되기 전에 복사할 것이 거의 남아 있지 않습니다. 최신 인기 언어인 Python은 접두사 문법과 매크로가 없는 희석된 Lisp입니다. 새로운 Lisp는 이 진행에서 자연스러운 단계가 될 것입니다.
때때로 그것을 Python의 개선된 버전이라고 부르는 것이 좋은 마케팅 트릭이 될 것이라고 생각합니다. Lisp보다 더 힙해 보입니다. 많은 사람들에게 Lisp는 괄호가 많은 느린 AI 언어입니다. Fritz Kunze의 공식 전기에는 L-단어가 언급되지 않습니다. 하지만 저는 우리가 새로운 Lisp를 Lisp라고 부르는 것을 두려워해서는 안 된다고 추측합니다. Lisp는 최고의 해커들 사이에서 여전히 많은 잠재적인 존경을 가지고 있습니다. — 예를 들어 6.001을 이해한 사람들입니다. 그리고 당신이 이겨야 하는 사용자들입니다.
"해커가 되는 법"에서 Eric Raymond는 Lisp를 라틴어나 그리스어와 비슷하게 설명합니다. — 지적인 연습을 위해 배워야 하는 언어입니다. 실제로 사용하지는 않더라도 말입니다.
Lisp는 마침내 이해할 때 경험하는 심오한 깨달음의 경험을 위해 배울 가치가 있습니다. — 그 경험은 실제 Lisp를 많이 사용하지 않더라도 평생 동안 당신을 더 나은 프로그래머로 만들 것입니다.
제가 Lisp를 몰랐다면, 이것을 읽는 것은 저에게 질문을 하게 만들었을 것입니다. 의미가 있다면, 제가 더 나은 프로그래머가 되도록 할 언어는 프로그래밍에 더 나을 것입니다. 그리고 그것은 사실 Eric이 말하는 것의 의미입니다.
그 아이디어가 여전히 떠도는 한, 저는 해커들이 새로운 Lisp에 대해, 심지어 Lisp라고 불리더라도 충분히 수용적일 것이라고 생각합니다. 하지만 이 Lisp는 1970년대의 클래식 Lisp와 같은 해커의 언어여야 합니다. 간결하고, 단순하며, 해킹 가능해야 합니다. 그리고 오늘날 해커들이 원하는 것을 하기 위한 강력한 라이브러리가 있어야 합니다.
라이브러리 문제에 있어서는 Perl과 Python과 같은 언어를 그들의 게임에서 이길 수 있는 여지가 있다고 생각합니다. 향후 몇 년 동안 작성해야 할 많은 새로운 애플리케이션은 서버 기반 애플리케이션이 될 것입니다. 새로운 Lisp가 Perl만큼 좋은 문자열 라이브러리를 갖지 못할 이유가 없으며, 이 새로운 Lisp가 서버 기반 애플리케이션을 위한 강력한 라이브러리를 갖춘다면 매우 인기가 있을 수 있습니다.
진정한 해커는 몇 가지 라이브러리 호출로 어려운 문제를 해결할 수 있는 새로운 도구를 코웃음치지 않을 것입니다. 기억하세요, 해커는 게으릅니다.
서버 기반 애플리케이션을 위한 핵심 언어 지원을 갖는 것은 더 큰 이점이 될 수 있습니다. 예를 들어, 다중 사용자 프로그램에 대한 명시적 지원 또는 타입 태그 수준의 데이터 소유권입니다.
서버 기반 애플리케이션은 또한 이 새로운 Lisp가 무엇을 해킹하는 데 사용될지에 대한 질문에 대한 답을 제공합니다. Lisp를 Unix의 스크립팅 언어로 더 좋게 만드는 것은 해가 되지 않을 것입니다. (더 나쁘게 만드는 것은 어려울 것입니다.) 하지만 기존 언어를 이기기가 더 쉬운 영역이 있다고 생각합니다. Tcl의 모델을 따르고 Lisp를 완전한 서버 기반 애플리케이션 지원 시스템과 함께 제공하는 것이 더 좋을 것이라고 생각합니다. Lisp는 서버 기반 애플리케이션에 자연스럽게 적합합니다. 어휘적 클로저(Lexical closures)는 UI가 일련의 웹 페이지에 불과할 때 서브루틴의 효과를 얻는 방법을 제공합니다. S-표현식은 HTML에 잘 매핑되며, 매크로는 이를 생성하는 데 좋습니다. 서버 기반 애플리케이션을 작성하기 위한 더 나은 도구가 필요하며, 새로운 Lisp가 필요하며, 둘은 매우 잘 작동할 것입니다.

## 12. 꿈의 언어

요약하자면, 해커의 꿈의 언어를 설명해 보겠습니다.
꿈의 언어는 아름답고, 깨끗하며, 간결합니다. 그것은 빠르게 시작하는 대화식 최상위 레벨을 가지고 있습니다. 매우 적은 코드로 일반적인 문제를 해결하는 프로그램을 작성할 수 있습니다. 당신이 작성하는 모든 프로그램의 거의 모든 코드는 당신의 애플리케이션에 특정한 코드입니다. 나머지 모든 것은 당신을 위해 완료되었습니다.
언어의 문법은 지나치게 간결합니다. 불필요한 문자는 전혀 입력할 필요가 없으며, Shift 키를 많이 사용할 필요도 없습니다.
거대한 추상화를 사용하여 프로그램의 첫 버전을 매우 빠르게 작성할 수 있습니다. 나중에 최적화하고 싶을 때, 어디에 집중해야 할지 알려주는 정말 좋은 프로파일러가 있습니다. 필요하다면 인라인 바이트 코드까지 사용하여 내부 루프를 눈부시게 빠르게 만들 수 있습니다.
배울 수 있는 좋은 예제가 많이 있으며, 언어는 직관적이어서 몇 분 안에 예제에서 사용법을 배울 수 있습니다. 설명서를 많이 찾아볼 필요가 없습니다. 설명서는 얇고 경고와 자격 요건이 거의 없습니다.
언어는 작은 코어와, 핵심 언어만큼 신중하게 설계된 강력하고 매우 직교적인 라이브러리를 가지고 있습니다. 라이브러리는 모두 잘 작동하며, 언어의 모든 것이 멋진 카메라 부품처럼 잘 들어맞습니다. 아무것도 폐기되거나 호환성을 위해 유지되지 않습니다. 모든 라이브러리의 소스 코드는 쉽게 사용할 수 있습니다. 운영 체제 및 다른 언어로 작성된 애플리케이션과 쉽게 통신할 수 있습니다.
언어는 계층으로 구축됩니다. 상위 레벨 추상화는 하위 레벨 추상화에서 매우 투명한 방식으로 구축되며, 원한다면 접근할 수 있습니다.
절대적으로 필요하지 않은 이상은 아무것도 숨겨져 있지 않습니다. 언어는 작업을 절약하는 방법으로만 추상화를 제공하며, 무엇을 해야 할지 지시하는 방법으로는 그렇지 않습니다. 사실, 언어는 설계에 동등한 참여자가 되도록 권장합니다. 구문 자체를 포함하여 모든 것을 변경할 수 있으며, 당신이 작성하는 모든 것은 가능한 한 미리 정의된 것과 동일한 지위를 갖습니다.

---

[^1]: 현대적인 아이디어에 매우 가까운 매크로가 1964년, Lisp 1.5 출시 2년 후에 Timothy Hart에 의해 제안되었습니다. 초기에는 변수 캡처와 다중 평가를 피하는 방법이 누락되었습니다. Hart의 예는 둘 다 대상입니다.
[^2]: Frank Vertosick의 "When the Air Hits Your Brain"에서 신경외과 의사 Frank Vertosick은 자신의 수석 레지던트 Gary가 외과 의사와 내과 의사("벼룩")의 차이에 대해 이야기하는 대화를 회상합니다.
Gary와 나는 피자를 많이 주문하고 빈 부스를 찾았다. 수석은 담배를 피웠다. "평생 한 번 볼까 말까 한 질병에 대해 지껄이는 저 빌어먹을 벼룩들을 봐. 벼룩의 문제는 끔찍한 것만 좋아한다는 거야. 그들은 빵과 버터 사례를 싫어해. 그게 우리와 빌어먹을 벼룩의 차이야. 알겠어, 우리는 크고 즙이 많은 요추 디스크 탈출증을 좋아하지만, 그들은 고혈압을 싫어해...."
요추 디스크 탈출증을 즙이 많다고 생각하기는 어렵습니다(문자 그대로 제외하고). 그럼에도 불구하고 나는 그들이 무슨 뜻인지 안다고 생각합니다. 나는 추적할 즙이 많은 버그를 여러 번 가지고 있었습니다. 프로그래머가 아닌 사람은 버그에서 즐거움을 찾을 수 있다는 것을 상상하기 어려울 것입니다. 물론 모든 것이 제대로 작동하는 것이 더 좋습니다. 한 가지 방법으로는 그렇습니다. 그럼에도 불구하고 특정 종류의 버그를 추적하는 데는 부인할 수 없는 냉혹한 만족감이 있습니다.