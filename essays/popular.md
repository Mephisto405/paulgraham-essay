# 인기 얻기 (Being Popular)

2001년 5월

(이 글은 새로운 프로그래밍 언어를 위한 비즈니스 플랜의 일종으로 작성되었습니다. 따라서 좋은 프로그래밍 언어의 가장 중요한 특징인 '매우 강력한 추상화'에 대한 언급은 빠져있습니다. (이러한 특징은 당연한 것으로 간주되었습니다.))

한 친구가 저명한 운영체제 전문가에게 정말 좋은 프로그래밍 언어를 설계하고 싶다고 말했습니다. 그 전문가는 시간 낭비일 뿐이라고 말했습니다. 프로그래밍 언어는 장점에 따라 인기를 얻거나 잃는 것이 아니기 때문에, 아무리 좋은 언어를 만들어도 아무도 사용하지 않을 것이라고 했습니다. 적어도 자신이 설계했던 언어가 그랬다고 말이죠.

그렇다면 무엇이 언어를 인기 있게 만들까요? 인기 있는 언어는 인기를 얻을 만한 자격이 있을까요? 좋은 프로그래밍 언어를 정의하려는 노력은 가치가 있을까요? 어떻게 정의할 수 있을까요?

이 질문들에 대한 답은 해커(hacker)들을 관찰하고 그들이 무엇을 원하는지 파악함으로써 찾을 수 있다고 생각합니다. 프로그래밍 언어는 해커들을 위한 것이며, 해커들이 좋아할 때 비로소 좋은 프로그래밍 언어가 됩니다. (예를 들어, 표의적 의미론(denotational semantics)이나 컴파일러 설계 연습이 아니라 말이죠.)

## 1. 인기 메커니즘 (The Mechanics of Popularity)

대부분의 사람이 단순히 장점만 보고 프로그래밍 언어를 선택하지 않는다는 것은 분명 사실입니다. 대부분의 프로그래머는 다른 사람에게서 사용할 언어를 지시받습니다. 그러나 프로그래밍 언어의 인기에 미치는 이러한 외부 요인의 영향은 생각만큼 크지 않다고 생각합니다. 오히려 더 큰 문제는 해커가 생각하는 좋은 프로그래밍 언어와 대부분의 언어 설계자가 생각하는 것이 다르다는 점입니다.

둘 중에서는 해커의 의견이 중요합니다. 프로그래밍 언어는 정리가 아닙니다. 그것은 사람들을 위해 설계된 도구이며, 신발이 사람 발에 맞게 설계되어야 하듯이 인간의 강점과 약점에 맞게 설계되어야 합니다. 신발을 신었을 때 발이 아프다면, 조각품으로서 아무리 우아하더라도 나쁜 신발입니다.

대부분의 프로그래머가 좋은 언어와 나쁜 언어를 구별하지 못할 수도 있습니다. 하지만 다른 도구들도 마찬가지입니다. 그렇다고 해서 좋은 언어를 설계하려는 노력이 시간 낭비라는 의미는 아닙니다.

전문 해커(expert hacker)들은 좋은 언어를 보면 알아보고 그것을 사용합니다. 전문 해커는 극히 소수에 불과하지만, 이 소수의 집단이 모든 좋은 소프트웨어를 만들고, 그들의 영향력은 나머지 프로그래머들이 그들이 사용하는 언어를 따르도록 만듭니다. 실제로 전문 해커들은 종종 상사나 교수 자문으로서 다른 프로그래머들에게 사용할 언어를 지시하는 사람들인 경우도 많습니다.

전문 해커의 의견이 프로그래밍 언어의 상대적 인기를 결정하는 유일한 요인은 아닙니다. 레거시(legacy) 소프트웨어(코볼, Cobol)와 과장된 홍보(에이다, Ada; 자바, Java)도 역할을 하지만, 장기적으로는 가장 강력한 힘이라고 생각합니다. 초기 임계 질량(critical mass)과 충분한 시간이 주어지면, 프로그래밍 언어는 아마도 그 인기를 얻을 만한 가치만큼 인기를 얻게 될 것입니다. 그리고 인기는 좋은 언어와 나쁜 언어를 더욱 분리시키는데, 이는 실제 사용자들로부터의 피드백이 항상 개선으로 이어지기 때문입니다. 인기 있는 언어가 생애 동안 얼마나 많이 변했는지 보십시오. 펄(Perl)과 포트란(Fortran)은 극단적인 경우이지만, 리스프(Lisp)조차도 많이 변했습니다. 예를 들어 리스프 1.5에는 매크로(macro)가 없었습니다. 이는 MIT의 해커들이 리스프를 사용하여 실제 프로그램을 작성하는 데 몇 년을 보낸 후에 진화한 것입니다. [1]

따라서 언어가 인기 있기 위해 좋아야 하는지 여부와 관계없이, 저는 언어가 좋아지려면 인기가 있어야 한다고 생각합니다. 그리고 좋아진 상태를 유지하려면 계속 인기가 있어야 합니다. 프로그래밍 언어의 기술 발전은 멈추지 않습니다. 그러나 오늘날의 리스프는 여전히 1980년대 중반 MIT에서 사용되던 것과 거의 같습니다. 왜냐하면 그 때가 리스프가 충분히 크고 까다로운 사용자 기반을 가졌던 마지막 시기였기 때문입니다.

물론 해커들은 언어를 사용하기 전에 그 언어에 대해 알아야 합니다. 어떻게 듣게 될까요? 다른 해커들로부터입니다. 하지만 다른 사람들이 그 언어에 대해 듣기 위해서는 언어를 사용하는 초기 해커 그룹이 있어야 합니다. 이 그룹이 얼마나 커야 할까요? 몇 명의 사용자가 임계 질량을 이룰까요? 제 생각으로는 스무 명입니다. 만약 언어가 스무 명의 개별 사용자를 가진다면, 즉 스스로 사용하기로 결정한 스무 명의 사용자를 가진다면, 저는 그것을 실제라고 생각할 것입니다.

거기까지 가는 것은 쉽지 않을 것입니다. 0명에서 20명으로 가는 것이 20명에서 1000명으로 가는 것보다 더 어려울 것이라고 해도 놀랍지 않을 것입니다. 이 초기 20명의 사용자를 얻는 가장 좋은 방법은 아마도 트로이 목마(trojan horse)를 사용하는 것일 겁니다. 사람들이 원하는 애플리케이션을 제공하되, 그 애플리케이션이 새로운 언어로 작성되도록 하는 것입니다.

## 2. 외부 요인 (External Factors)

프로그래밍 언어의 인기에 영향을 미치는 한 가지 외부 요인을 먼저 인정하고 시작합시다. 인기 있는 프로그래밍 언어가 되려면 인기 있는 시스템의 스크립팅 언어여야 합니다. 포트란과 코볼은 초창기 IBM 메인프레임의 스크립팅 언어였습니다. C는 유닉스(Unix)의 스크립팅 언어였고, 이후 펄도 마찬가지였습니다. Tcl은 Tk의 스크립팅 언어입니다. 자바와 자바스크립트(Javascript)는 웹 브라우저의 스크립팅 언어를 목표로 합니다.

리스프는 대중적인 시스템의 스크립팅 언어가 아니기 때문에 대중적으로 인기가 많은 언어는 아닙니다. 남아있는 인기는 1960년대와 1970년대, 즉 리스프가 MIT의 스크립팅 언어였던 시절에 거슬러 올라갑니다. 당시의 훌륭한 프로그래머들 중 상당수가 한때 MIT와 관련이 있었습니다. 그리고 1970년대 초, C가 등장하기 전에는 MIT의 리스프 방언인 매클리스프(MacLisp)가 진지한 해커라면 사용하고 싶어 할 만한 유일한 프로그래밍 언어 중 하나였습니다.

오늘날 리스프는 이맥스(Emacs)와 오토캐드(Autocad)라는 두 개의 중간 정도 인기 있는 시스템의 스크립팅 언어이며, 이 때문에 오늘날 이루어지는 대부분의 리스프 프로그래밍은 이맥스 리스프나 오토리습(AutoLisp)으로 이루어진다고 생각합니다.

프로그래밍 언어는 고립되어 존재하지 않습니다. 해킹(hack)은 타동사입니다. 해커는 보통 무언가를 해킹하고 있으며, 실제로는 언어가 해킹하는 데 사용되는 대상에 따라 평가됩니다. 따라서 인기 있는 언어를 설계하고 싶다면 언어 이상의 것을 제공하거나, 기존 시스템의 스크립팅 언어를 대체하도록 언어를 설계해야 합니다.

커먼 리스프(Common Lisp)가 인기가 없는 이유 중 하나는 고아이기 때문입니다. 원래는 해킹할 시스템, 즉 리스프 머신(Lisp Machine)과 함께 출시되었습니다. 하지만 리스프 머신은 (병렬 컴퓨터와 함께) 1980년대 범용 프로세서의 성능 향상에 의해 압도당했습니다. 커먼 리스프는 유닉스에 좋은 스크립팅 언어였다면 인기를 유지했을 수도 있습니다. 안타깝게도 유닉스에는 형편없이 나쁜 언어였습니다.

이러한 상황을 설명하는 한 가지 방법은 언어가 자체의 장점만으로 평가되지 않는다고 말하는 것입니다. 또 다른 관점은 프로그래밍 언어는 무언가의 스크립팅 언어가 아니라면 진정한 프로그래밍 언어가 아니라는 것입니다. 이는 예상치 못한 경우에만 불공평하게 들릴 뿐입니다. 저는 프로그래밍 언어가 구현을 가져야 한다고 기대하는 것보다 더 불공평하지 않다고 생각합니다. 단지 프로그래밍 언어가 무엇인지에 대한 한 부분일 뿐입니다.

물론 프로그래밍 언어는 좋은 구현이 필요하며, 이는 무료여야 합니다. 회사는 소프트웨어에 돈을 지불하겠지만, 개별 해커는 그렇지 않을 것이며, 해커들을 유치해야 합니다.

언어에는 또한 관련 서적이 필요합니다. 그 책은 얇고 잘 쓰여졌으며 좋은 예제로 가득 차 있어야 합니다. K&R[역주: 브라이언 커니핸과 데니스 리치가 쓴 C 프로그래밍 언어 책]이 여기에서 이상적입니다. 현재로서는 거의 언어가 오라일리(O'Reilly)에서 출판한 책을 가져야 한다고 말할 수 있습니다. 그것이 해커들에게 중요한지 여부를 판단하는 기준이 되고 있습니다.

온라인 문서도 있어야 합니다. 사실 책은 온라인 문서로 시작될 수도 있습니다. 하지만 저는 아직 물리적인 책이 시대에 뒤떨어졌다고 생각하지 않습니다. 그 형식은 편리하며, 출판사들이 부과하는 사실상의 검열(de facto censorship)은 불완전하지만 유용한 필터 역할을 합니다. 서점은 새로운 언어에 대해 배우는 가장 중요한 장소 중 하나입니다.

## 3. 간결함 (Brevity)

모든 언어에 필요한 세 가지, 즉 무료 구현, 책, 그리고 해킹할 대상이 주어진다면, 어떻게 해커들이 좋아할 만한 언어를 만들 수 있을까요?

해커들이 좋아하는 것 중 하나는 간결함입니다. 해커들은 수학자나 모더니즘 건축가처럼 게으릅니다. 그들은 불필요한 것을 싫어합니다. 해커가 프로그램을 작성하기 직전에, 적어도 무의식적으로는, 자신이 입력해야 할 총 문자 수에 따라 사용할 언어를 결정한다고 말해도 과언이 아닐 것입니다. 해커가 정확히 이런 식으로 생각하지 않더라도, 언어 설계자는 마치 그렇다고 여기고 행동하는 것이 좋을 것입니다.

영어를 닮도록 의도된 장황한 표현으로 사용자를 유치하게 대하려는 시도는 실수입니다. 코볼은 이러한 결함으로 악명이 높습니다. 해커는 `z = x + y` 대신 `add x to y giving z`를 작성하라는 요청을 받는 것을 자신의 지능에 대한 모욕이자 신에 대한 죄악으로 여길 것입니다.

리스프가 `car`와 `cdr` 대신 `first`와 `rest`를 사용해야 한다는 말이 있었습니다. 프로그램이 더 읽기 쉬워질 것이라는 이유에서였죠. 아마 처음 몇 시간 동안은 그럴 겁니다. 하지만 해커는 `car`가 리스트의 첫 번째 요소를 의미하고 `cdr`가 나머지를 의미한다는 것을 충분히 빨리 배울 수 있습니다. `first`와 `rest`를 사용하면 타이핑이 50% 더 많아집니다. 그리고 길이도 달라서 `car`와 `cdr`처럼 연속적인 줄에서 호출될 때 인수가 정렬되지 않습니다. 저는 코드가 페이지에서 어떻게 정렬되는지가 매우 중요하다는 것을 발견했습니다. 저는 가변폭 글꼴로 설정된 리스프 코드를 거의 읽을 수 없으며, 친구들은 다른 언어도 마찬가지라고 말합니다.

간결함은 강타입(strongly typed) 언어가 불리한 부분입니다. 다른 모든 조건이 동일하다면, 누구도 프로그램 시작을 온갖 선언으로 시작하고 싶어 하지 않습니다. 암묵적으로 처리될 수 있는 것은 무엇이든 암묵적으로 처리되어야 합니다.

개별 토큰(token)도 짧아야 합니다. 펄과 커먼 리스프는 이 문제에서 정반대의 극점에 서 있습니다. 펄 프로그램은 거의 암호처럼 복잡할 수 있는 반면, 커먼 리스프 내장 연산자들의 이름은 우스꽝스러울 정도로 깁니다. 커먼 리스프 설계자들은 사용자들이 긴 이름을 대신 입력해 줄 텍스트 편집기를 가지고 있을 것이라고 예상했을 것입니다. 그러나 긴 이름의 비용은 단순히 입력 비용뿐만이 아닙니다. 읽는 비용과 화면에서 차지하는 공간 비용도 있습니다.

## 4. 해킹 가능성 (Hackability)

해커에게 간결함보다 더 중요한 것이 한 가지 있습니다. 원하는 것을 할 수 있는 능력입니다. 프로그래밍 언어의 역사에서 프로그래머가 부적절하다고 간주되는 일을 하지 못하게 막는 데 놀라울 정도로 많은 노력이 들어갔습니다. 이것은 위험할 정도로 주제넘은 계획입니다. 언어 설계자가 프로그래머가 무엇을 해야 할지 어떻게 알 수 있겠습니까? 저는 언어 설계자들이 목표 사용자를 스스로를 보호해야 할 엉성한 사람이 아니라, 그들이 예상하지 못했던 일들을 해야 할 천재라고 생각하는 것이 더 나을 것이라고 생각합니다. 엉성한 사람은 어차피 제 발을 찧을 것입니다. 다른 패키지의 변수를 참조하는 것을 막을 수는 있지만, 잘못된 문제를 해결하기 위해 잘못 설계된 프로그램을 작성하고 영원히 시간을 보내는 것을 막을 수는 없습니다.

훌륭한 프로그래머들은 종종 위험하고 불쾌한 일을 하고 싶어 합니다. '불쾌하다'는 것은 언어가 제시하려는 의미적 외관(semantic facade) 뒤로 들어가는 것을 의미합니다. 예를 들어, 어떤 고수준 추상화의 내부 표현을 손에 넣는 것 말입니다. 해커들은 해킹하는 것을 좋아하고, 해킹은 내부로 들어가서 원래 설계자의 의도를 재해석하는 것을 의미합니다.

자신이 재해석될 수 있도록 내버려 두십시오. 어떤 도구를 만들든지 사람들은 당신이 의도하지 않은 방식으로 그것을 사용하며, 이는 프로그래밍 언어와 같은 고도로 체계화된 도구에서는 특히 그렇습니다. 많은 해커가 당신이 상상조차 하지 못한 방식으로 당신의 의미론적 모델(semantic model)을 수정하고 싶어 할 것입니다. 저는 그들이 그렇게 하도록 내버려 두라고 말합니다. 가비지 컬렉터(garbage collector)와 같은 런타임 시스템을 위험에 빠뜨리지 않는 한, 프로그래머에게 가능한 한 많은 내부 기능에 접근할 수 있도록 하십시오.

커먼 리스프에서 저는 종종 구조체(struct)의 필드들을 반복해서 처리하고 싶었습니다. 예를 들어, 삭제된 객체에 대한 참조를 제거하거나 초기화되지 않은 필드를 찾기 위해서 말이죠. 저는 구조체가 내부적으로는 벡터(vector)라는 것을 알고 있습니다. 하지만 어떤 구조체에든 호출할 수 있는 범용 함수를 작성할 수는 없습니다. 필드 이름으로만 접근할 수 있는데, 이는 구조체가 원래 그렇게 의미하기 때문입니다.

해커는 큰 프로그램에서 의도된 모델을 한두 번만 전복시키고 싶을 수도 있습니다. 하지만 그렇게 할 수 있다는 것이 얼마나 큰 차이를 만드는지 모릅니다. 그리고 이는 단순히 문제를 해결하는 것 이상의 문제일 수도 있습니다. 여기에는 일종의 즐거움도 있습니다. 해커들은 끔찍한 내장을 파헤치는 외과의사의 비밀스러운 즐거움, 여드름을 짜는 십대들의 비밀스러운 즐거움을 공유합니다. [2] 적어도 남자들에게는 특정 종류의 공포가 매력적입니다. 막심(Maxim) 잡지는 매년 화보집을 발행하는데, 핀업 사진과 끔찍한 사고 사진이 섞여 있습니다. 그들은 자신들의 독자를 압니다.

역사적으로 리스프는 해커들이 원하는 대로 할 수 있도록 하는 데 능숙했습니다. 커먼 리스프의 정치적 올바름(political correctness)은 예외적인 현상입니다. 초기 리스프는 모든 것을 직접 다룰 수 있도록 허용했습니다. 다행히도 이러한 정신의 상당 부분이 매크로에 보존되어 있습니다. 소스 코드를 임의로 변환할 수 있다는 것이 얼마나 멋진 일입니까.

클래식 매크로는 진정한 해커의 도구입니다. 간단하고 강력하며 위험하죠. 그들이 무엇을 하는지 이해하기가 매우 쉽습니다. 매크로의 인수에 함수를 호출하면, 그 함수가 반환하는 것이 매크로 호출 자리에 삽입됩니다. 위생 매크로(hygienic macro)는 그 반대 원리를 구현합니다. 그들은 당신이 그들이 무엇을 하는지 이해하지 못하도록 보호하려 합니다. 저는 위생 매크로가 한 문장으로 설명되는 것을 들어본 적이 없습니다. 그리고 그들은 프로그래머가 무엇을 원해도 되는지 결정하는 것의 위험성을 보여주는 전형적인 예시입니다. 위생 매크로는 다른 것들 중에서도 변수 포획(variable capture)으로부터 저를 보호하기 위한 것이지만, 변수 포획은 어떤 매크로에서는 제가 정확히 원하는 것입니다.

정말 좋은 언어는 깨끗하면서도 더러워야 합니다. 즉, 잘 이해되고 고도로 직교적인(orthogonal) 소수의 연산자로 깔끔하게 설계되어야 하지만, 해커가 마음껏 다룰 수 있도록 허용한다는 의미에서 더러워야 합니다. C가 그렇습니다. 초기 리스프도 마찬가지였습니다. 진정한 해커의 언어는 항상 약간 건달 같은 특성을 가질 것입니다.

좋은 프로그래밍 언어는 "소프트웨어 공학"이라는 문구를 사용하는 사람들이 못마땅하게 고개를 저을 만한 기능들을 가지고 있어야 합니다. 스펙트럼의 다른 끝에는 에이다와 파스칼(Pascal)과 같은 언어가 있습니다. 이들은 적절함의 모범이며 교육용으로는 좋지만 그 외에는 별다른 것이 없습니다.

## 5. 일회용 프로그램 (Throwaway Programs)

해커들에게 매력적이려면 언어는 그들이 작성하고 싶어 하는 종류의 프로그램을 작성하는 데 적합해야 합니다. 그리고 이는 아마도 놀랍게도, 일회용 프로그램(throwaway program)을 작성하는 데 적합해야 한다는 것을 의미합니다.

일회용 프로그램은 어떤 제한된 작업을 위해 빠르게 작성하는 프로그램입니다. 시스템 관리 작업을 자동화하거나, 시뮬레이션을 위한 테스트 데이터를 생성하거나, 데이터를 한 형식에서 다른 형식으로 변환하는 프로그램 같은 것입니다. 일회용 프로그램의 놀라운 점은 제2차 세계대전 동안 많은 미국 대학에 지어진 "임시" 건물처럼, 종종 버려지지 않는다는 것입니다. 많은 프로그램이 실제 기능과 실제 사용자를 가진 실제 프로그램으로 진화합니다.

저는 최고의 대규모 프로그램들이 후버 댐(Hoover Dam)처럼 처음부터 크게 설계되기보다는 이런 식으로 생겨난다고 생각합니다. 맨 처음부터 큰 것을 짓는 것은 두려운 일입니다. 사람들이 너무 큰 프로젝트를 맡으면 압도당합니다. 프로젝트는 늪에 빠지거나, 결과물이 무미건조하고 뻣뻣해집니다. 실제 도심 대신 쇼핑몰, 로마 대신 브라질리아(Brasília), C 대신 에이다가 되는 것처럼 말입니다.

큰 프로그램을 얻는 또 다른 방법은 일회용 프로그램으로 시작하여 계속 개선하는 것입니다. 이 접근 방식은 덜 부담스럽고, 프로그램의 설계는 진화의 혜택을 받습니다. 제가 살펴보면, 대부분의 큰 프로그램이 이런 식으로 개발되었을 것이라고 생각합니다. 그리고 이런 식으로 진화한 프로그램들은 아마도 처음에 작성된 언어로 여전히 작성되어 있을 것입니다. 정치적인 이유 외에는 프로그램을 이식하는 경우가 드물기 때문입니다. 따라서 역설적으로, 대규모 시스템에 사용되는 언어를 만들고 싶다면, 일회용 프로그램을 작성하는 데 적합하게 만들어야 합니다. 큰 시스템은 거기에서 비롯되기 때문입니다.

펄은 이 아이디어의 대표적인 예시입니다. 펄은 일회용 프로그램을 작성하기 위해 설계되었을 뿐만 아니라, 그 자체로 거의 일회용 프로그램이었습니다. 펄은 보고서 생성을 위한 유틸리티 모음으로 시작했으며, 사람들이 펄로 작성한 일회용 프로그램이 점점 커지면서 프로그래밍 언어로 진화했습니다. 펄 5(만약 그렇다면)가 되어서야 언어가 심각한 프로그램을 작성하는 데 적합했지만, 그때 이미 엄청나게 인기가 있었습니다.

무엇이 언어를 일회용 프로그램에 좋게 만들까요? 우선, 쉽게 사용 가능해야 합니다. 일회용 프로그램은 한 시간 내에 작성할 것으로 예상하는 것입니다. 따라서 언어는 아마도 사용 중인 컴퓨터에 이미 설치되어 있어야 합니다. 사용하기 전에 설치해야 하는 것이어서는 안 됩니다. 거기 있어야 합니다. C는 운영체제와 함께 제공되었기 때문에 거기에 있었습니다. 펄은 원래 시스템 관리자를 위한 도구였기 때문에 이미 설치되어 있었습니다.

그러나 사용 가능하다는 것은 설치되어 있다는 것 이상의 의미입니다. 명령줄 인터페이스(command-line interface)가 있는 대화형 언어는 별도로 컴파일하고 실행해야 하는 언어보다 더 사용 가능합니다. 인기 있는 프로그래밍 언어는 대화형이어야 하고 빠르게 시작되어야 합니다.

일회용 프로그램에서 원하는 또 다른 것은 간결함입니다. 간결함은 해커들에게 항상 매력적이며, 한 시간 내에 작성할 것으로 예상하는 프로그램에서는 더욱 그렇습니다.

## 6. 라이브러리 (Libraries)

물론 간결함의 궁극은 프로그램이 이미 작성되어 있고, 단지 그것을 호출하기만 하면 되는 것입니다. 그리고 이것은 제가 프로그래밍 언어의 점점 더 중요해질 특징이라고 생각하는 것, 즉 라이브러리 함수(library function)로 이어집니다. 펄은 문자열을 조작하는 데 필요한 대규모 라이브러리를 가지고 있기 때문에 성공합니다. 이러한 종류의 라이브러리 함수는 일회용 프로그램에 특히 중요합니다. 일회용 프로그램은 종종 데이터 변환이나 추출을 위해 처음 작성되기 때문입니다. 많은 펄 프로그램은 아마도 몇 개의 라이브러리 호출을 연결하는 것으로 시작될 것입니다.

향후 50년 동안 프로그래밍 언어에서 일어날 많은 발전이 라이브러리 함수와 관련이 있을 것이라고 생각합니다. 미래의 프로그래밍 언어는 핵심 언어만큼이나 신중하게 설계된 라이브러리를 갖게 될 것이라고 생각합니다. 프로그래밍 언어 설계는 언어를 강타입(strongly typed)으로 만들지 약타입(weakly typed)으로 만들지, 객체 지향으로 만들지 함수형으로 만들지 등이 아니라, 훌륭한 라이브러리를 어떻게 설계할지에 대한 것이 될 것입니다. 타입 시스템(type system) 설계에 대해 생각하기를 좋아하는 언어 설계자들은 이 말에 몸서리칠지도 모릅니다. 거의 애플리케이션을 작성하는 것과 같으니까요! 안타깝습니다. 언어는 프로그래머를 위한 것이고, 라이브러리는 프로그래머에게 필요한 것입니다.

좋은 라이브러리를 설계하는 것은 어렵습니다. 단순히 많은 코드를 작성하는 문제가 아닙니다. 라이브러리가 너무 커지면 필요한 함수를 찾는 데 코드를 직접 작성하는 것보다 시간이 더 오래 걸릴 수도 있습니다. 라이브러리는 핵심 언어처럼 소수의 직교적 연산자를 사용하여 설계되어야 합니다. 프로그래머가 어떤 라이브러리 호출이 자신이 필요한 것을 할 것인지 추측할 수 있어야 합니다.

라이브러리는 커먼 리스프가 부족한 부분 중 하나입니다. 문자열을 조작하는 기본적인 라이브러리만 있을 뿐이며, 운영체제(OS)와 통신하는 라이브러리는 거의 없습니다. 역사적인 이유로 커먼 리스프는 OS가 존재하지 않는 척하려고 합니다. 그리고 OS와 통신할 수 없기 때문에, 커먼 리스프의 내장 연산자만으로는 심각한 프로그램을 작성하기 어려울 것입니다. 구현에 특화된 해킹을 사용해야 하며, 실제로는 이러한 해킹이 원하는 모든 것을 제공하지 않는 경향이 있습니다. 커먼 리스프가 강력한 문자열 라이브러리와 좋은 OS 지원을 갖추었다면 해커들은 리스프를 훨씬 더 높이 평가했을 것입니다.

## 7. 문법 (Syntax)

리스프의 문법, 더 정확히는 문법의 부재를 가진 언어가 인기를 얻을 수 있을까요? 이 질문에 대한 답은 모릅니다. 저는 문법이 리스프가 현재 인기 없는 주된 이유는 아니라고 생각합니다. 커먼 리스프는 낯선 문법보다 더 심각한 문제들을 가지고 있습니다. 저는 접두사(prefix) 문법에 익숙하지만, 강력한 문자열 라이브러리와 OS와 통신할 수 있다는 이유로 기본적으로 펄을 사용하는 프로그래머들을 여러 명 알고 있습니다.

접두사 표기법에는 두 가지 문제가 있을 수 있습니다. 하나는 프로그래머들에게 낯설다는 것이고, 다른 하나는 충분히 밀도가 높지 않다는 것입니다. 리스프 세계의 일반적인 통념은 첫 번째 문제가 실제 문제라는 것입니다. 저는 그렇게 확신하지 않습니다. 네, 접두사 표기법은 일반 프로그래머들을 당황하게 만듭니다. 하지만 저는 일반 프로그래머들의 의견이 중요하다고 생각하지 않습니다. 언어는 전문 해커들이 어떻게 생각하는지에 따라 인기를 얻거나 잃으며, 전문 해커들은 접두사 표기법을 다룰 수 있을 것이라고 생각합니다. 펄 문법은 상당히 이해하기 어려울 수 있지만, 그것이 펄의 인기를 방해하지는 않았습니다. 오히려 펄 컬트(cult)를 형성하는 데 도움이 되었을 수도 있습니다.

더 심각한 문제는 접두사 표기법의 확산성입니다. 전문 해커들에게는 그것이 정말 문제입니다. `a[x,y]`라고 쓸 수 있는데 `(aref a x y)`라고 쓰고 싶어 하는 사람은 아무도 없습니다.

이 특정 경우에는 문제를 영리하게 해결할 수 있는 방법이 있습니다. 데이터 구조를 인덱스에 대한 함수처럼 취급하면 `(a x y)`라고 쓸 수 있는데, 이는 펄 형식보다도 짧습니다. 비슷한 트릭으로 다른 종류의 표현식도 단축할 수 있습니다.

들여쓰기를 의미 있게 만들면 많은 괄호를 제거하거나 (선택 사항으로) 만들 수 있습니다. 프로그래머들은 어차피 코드를 그렇게 읽습니다. 들여쓰기가 한 가지를 말하고 구분자가 다른 것을 말할 때, 우리는 들여쓰기를 따릅니다. 들여쓰기를 의미 있게 취급하는 것은 이러한 흔한 버그의 원인을 제거할 뿐만 아니라 프로그램을 더 짧게 만들 것입니다.

때로는 중위(infix) 문법이 더 읽기 쉬울 때가 있습니다. 특히 수학 표현식의 경우 더욱 그렇습니다. 저는 평생 리스프를 사용해 왔지만 여전히 접두사 수학 표현식이 자연스럽게 느껴지지 않습니다. 하지만 연산자가 임의의 개수의 인수를 취할 수 있다는 것은 편리하며, 특히 코드를 생성할 때 그렇습니다. 따라서 중위 문법을 도입한다면, 아마도 어떤 종류의 읽기 매크로(read-macro)로 구현되어야 할 것입니다.

리스프에 문법을 도입하는 것을 종교적으로 반대해서는 안 된다고 생각합니다. 이해하기 쉬운 방식으로 기본 S-표현식(s-expression)으로 번역되는 한 말입니다. 리스프에는 이미 상당한 문법이 있습니다. 아무도 강제로 사용하지 않는 한, 더 많은 문법을 도입하는 것이 반드시 나쁘지는 않습니다. 커먼 리스프에서는 일부 구분자가 언어에 예약되어 있어, 적어도 일부 설계자는 미래에 더 많은 문법을 가질 의도를 가지고 있었음을 시사합니다.

커먼 리스프에서 가장 터무니없이 리스프답지 않은 문법 조각 중 하나는 포맷 문자열(format string)에 나타납니다. 포맷은 그 자체로 하나의 언어이며, 그 언어는 리스프가 아닙니다. 만약 리스프에 더 많은 문법을 도입하려는 계획이 있다면, 포맷 지정자(format specifier)도 그 안에 포함될 수 있을 것입니다. 매크로가 다른 종류의 코드를 생성하는 방식과 동일하게 포맷 지정자를 생성할 수 있다면 좋은 일일 것입니다.

한 저명한 리스프 해커가 CLTL(Common Lisp the Language) 책이 포맷 섹션에서 펼쳐진다고 말했습니다. 저도 그렇습니다. 이것은 아마도 개선의 여지가 있음을 나타냅니다. 또한 프로그램이 많은 I/O를 수행한다는 것을 의미할 수도 있습니다.

## 8. 효율성 (Efficiency)

모두가 알다시피 좋은 언어는 빠른 코드를 생성해야 합니다. 하지만 실제로는 빠른 코드가 주로 언어 설계에서 하는 일에서 비롯된다고 생각하지 않습니다. 크누스(Knuth)가 오래전에 지적했듯이, 속도는 특정 중요한 병목 현상(bottleneck)에서만 중요합니다. 그리고 많은 프로그래머들이 이후에 관찰했듯이, 이러한 병목 현상이 어디에 있는지 종종 착각합니다.

따라서 실제로는 빠른 코드를 얻는 방법은 언어를 강타입으로 만드는 것보다 아주 좋은 프로파일러(profiler)를 가지는 것입니다. 프로그램의 모든 호출에서 모든 인수의 타입을 알 필요는 없습니다. 병목 현상에서 인수의 타입을 선언할 수 있어야 합니다. 그리고 더욱이, 병목 현상이 어디에 있는지 알아낼 수 있어야 합니다.

사람들이 리스프에 대해 불평했던 것 중 하나는 무엇이 비싼지 알기 어렵다는 것입니다. 이것은 사실일 수 있습니다. 또한, 매우 추상적인 언어를 원한다면 피할 수 없는 것일 수도 있습니다. 그리고 어떤 경우든 좋은 프로파일링이 문제를 해결하는 데 큰 도움이 될 것이라고 생각합니다. 무엇이 비싼지 곧 알게 될 것입니다.

여기서 문제의 일부는 사회적인 것입니다. 언어 설계자들은 빠른 컴파일러를 작성하는 것을 좋아합니다. 그것이 그들의 기술을 측정하는 방식입니다. 그들은 프로파일러를 기껏해야 부가 기능 정도로 생각합니다. 하지만 실제로는 좋은 프로파일러가 빠른 코드를 생성하는 컴파일러보다 언어로 작성된 실제 프로그램의 속도를 향상시키는 데 더 많은 기여를 할 수 있습니다. 여기서도 언어 설계자들은 사용자들과 다소 동떨어져 있습니다. 그들은 약간 잘못된 문제를 아주 잘 해결하고 있습니다.

활동적인 프로파일러를 갖는 것이 좋은 아이디어일 수 있습니다. 즉, 프로그래머가 요청하기를 기다리지 않고 성능 데이터를 프로그래머에게 푸시하는 것입니다. 예를 들어, 프로그래머가 소스 코드를 편집할 때 편집기가 병목 현상을 빨간색으로 표시할 수 있습니다. 또 다른 접근 방식은 실행 중인 프로그램에서 무슨 일이 일어나고 있는지 어떤 식으로든 시각화하는 것입니다. 이는 특히 서버 기반 애플리케이션에서 많은 실행 중인 프로그램을 볼 수 있으므로 매우 큰 이점이 될 것입니다. 활동적인 프로파일러는 프로그램이 실행될 때 메모리에서 무슨 일이 일어나고 있는지 그래픽으로 보여주거나, 심지어 무슨 일이 일어나고 있는지 알려주는 소리를 낼 수도 있습니다.

소리는 문제에 대한 좋은 단서입니다. 제가 일했던 곳 중 한 곳에서는 웹 서버에서 무슨 일이 일어나고 있는지 보여주는 큰 계기판이 있었습니다. 바늘은 작은 서보 모터(servomotor)에 의해 움직였고, 회전할 때 미세한 소리를 냈습니다. 저는 제 책상에서 계기판을 볼 수 없었지만, 소리를 통해 서버에 문제가 발생했음을 즉시 알 수 있었습니다.

심지어 비효율적인 알고리즘을 자동으로 감지하는 프로파일러를 작성하는 것도 가능할 수 있습니다. 특정 메모리 접근 패턴이 나쁜 알고리즘의 확실한 징후로 밝혀져도 놀라지 않을 것입니다. 만약 우리 프로그램을 실행하는 작은 사람이 컴퓨터 안을 돌아다닌다면, 그는 아마 연방 정부 공무원만큼이나 자신의 직업에 대해 길고 애절한 이야기를 들려줄 것입니다. 저는 종종 프로세서를 쓸데없는 일에 많이 보내고 있다는 느낌을 받지만, 그 프로세서가 무엇을 하고 있는지 제대로 볼 수 있는 방법이 없었습니다.

현재 여러 리스프는 바이트코드(byte code)로 컴파일된 다음 인터프리터(interpreter)에 의해 실행됩니다. 이는 일반적으로 구현을 더 쉽게 이식할 수 있도록 하기 위함이지만, 유용한 언어 기능이 될 수도 있습니다. 바이트코드를 언어의 공식적인 부분으로 만들고, 프로그래머가 병목 현상에서 인라인 바이트코드를 사용할 수 있도록 허용하는 것이 좋은 아이디어일 수 있습니다. 그러면 그러한 최적화도 이식 가능하게 될 것입니다.

최종 사용자가 인지하는 속성의 본질은 변하고 있을 수 있습니다. 서버 기반 애플리케이션의 등장으로 점점 더 많은 프로그램이 I/O 바운드(I/O-bound)가 될 수 있습니다. I/O를 빠르게 만드는 것이 중요해질 것입니다. 언어는 간단하고 빠른 포맷된 출력 함수와 같은 직접적인 조치뿐만 아니라 캐싱(caching) 및 영속 객체(persistent object)와 같은 심층적인 구조적 변화를 통해 도움이 될 수 있습니다.

사용자들은 응답 시간에 관심이 있습니다. 하지만 또 다른 종류의 효율성이 점점 더 중요해질 것입니다. 프로세서당 지원할 수 있는 동시 사용자 수입니다. 가까운 미래에 작성될 흥미로운 애플리케이션 중 상당수는 서버 기반이 될 것이며, 서버당 사용자 수는 그러한 애플리케이션을 호스팅하는 모든 사람에게 중요한 질문입니다. 서버 기반 애플리케이션을 제공하는 비즈니스의 자본 비용에서 이것은 제수(divisor)입니다.

오랫동안 효율성은 대부분의 최종 사용자 애플리케이션에서 크게 중요하지 않았습니다. 개발자들은 각 사용자가 점점 더 강력한 프로세서를 책상에 두고 있을 것이라고 가정할 수 있었습니다. 그리고 파킨슨의 법칙(Parkinson's Law)에 따라 소프트웨어는 사용 가능한 리소스를 사용하도록 확장되었습니다. 이것은 서버 기반 애플리케이션에서는 바뀔 것입니다. 그 세상에서는 하드웨어와 소프트웨어가 함께 공급될 것입니다. 서버 기반 애플리케이션을 제공하는 회사에게는 서버당 지원할 수 있는 사용자 수가 수익에 매우 큰 영향을 미칠 것입니다.

일부 애플리케이션에서는 프로세서가 제한 요소가 될 것이며, 실행 속도가 최적화해야 할 가장 중요한 것이 될 것입니다. 그러나 종종 메모리가 한계가 될 것입니다. 동시 사용자 수는 각 사용자의 데이터에 필요한 메모리 양에 따라 결정될 것입니다. 언어도 여기서 도움이 될 수 있습니다. 스레드(thread)에 대한 좋은 지원은 모든 사용자가 단일 힙(heap)을 공유할 수 있도록 할 것입니다. 또한 영속 객체 및/또는 지연 로딩(lazy loading)에 대한 언어 수준 지원이 도움이 될 수도 있습니다.

## 9. 시간 (Time)

인기 있는 언어가 필요로 하는 마지막 요소는 시간입니다. 너무나 많은 프로그래밍 언어들이 그러하듯, 언제 사라질지 모르는 언어로 프로그램을 작성하고 싶어 하는 사람은 아무도 없습니다. 그래서 대부분의 해커들은 언어를 사용하기 전에 몇 년 동안 기다리는 경향이 있습니다.

놀랍도록 새로운 것을 발명한 사람들은 종종 이 사실을 깨닫고 놀라지만, 어떤 메시지든 사람들에게 전달하려면 시간이 필요합니다. 제 친구는 누군가 그에게 처음 부탁하는 일은 거의 하지 않습니다. 그는 사람들이 때때로 원하지 않는 것을 요구하기도 한다는 것을 알고 있습니다. 시간을 낭비하지 않기 위해 그는 세 번째나 네 번째 요청을 받을 때까지 기다립니다. 그때쯤이면 요청하는 사람은 꽤 짜증이 나겠지만, 적어도 그들이 정말로 원하는 것을 요청하고 있을 가능성이 높습니다.

대부분의 사람들은 새로운 소식에 대해 비슷한 종류의 필터링을 하는 법을 배웠습니다. 그들은 무언가에 대해 열 번을 들을 때까지는 관심을 기울이지도 않습니다. 그들은 충분히 정당합니다. 대부분의 인기 있는 새로운 것들은 결국 시간 낭비로 판명되고 결국 사라집니다. VRML을 배우는 것을 미루면서, 저는 결국 그것을 전혀 배울 필요가 없었습니다.

그래서 새로운 것을 발명한 사람은 사람들이 이해하기 시작하기까지 수년간 자신의 메시지를 계속 반복해야 할 것을 예상해야 합니다. 저희는 제가 아는 한 최초의 웹 서버 기반 애플리케이션을 만들었지만, 사람들이 다운로드할 필요가 없다는 것을 이해시키기까지 몇 년이 걸렸습니다. 그들이 멍청해서가 아니었습니다. 그들은 단지 저희에게 귀를 닫았을 뿐입니다.

좋은 소식은, 단순한 반복이 문제를 해결한다는 것입니다. 당신이 할 일은 당신의 이야기를 계속 들려주는 것이고, 결국 사람들은 듣기 시작할 것입니다. 사람들이 당신이 있다는 것을 알아차릴 때가 아니라, 당신이 여전히 그곳에 있다는 것을 알아차릴 때 관심을 기울입니다.

보통 추진력을 얻는 데 시간이 걸리는 것이 다행입니다. 대부분의 기술은 처음 출시된 후에도 많은 발전을 거듭하며, 특히 프로그래밍 언어는 더욱 그렇습니다. 새로운 기술에게는 소수의 얼리 어답터(early adopter)들만이 몇 년 동안 사용하는 것보다 더 좋은 것은 없습니다. 얼리 어답터들은 세련되고 까다로우며, 당신의 기술에 남아있는 모든 결함을 빠르게 찾아냅니다. 소수의 사용자만 있을 때는 그들 모두와 긴밀하게 연락할 수 있습니다. 그리고 얼리 어답터들은 당신이 시스템을 개선할 때, 비록 일부 호환성 문제가 발생하더라도 관대합니다.

새로운 기술이 도입되는 방식에는 두 가지가 있습니다. 유기적 성장 방식과 빅뱅(big bang) 방식입니다. 유기적 성장 방식은 전형적인 주먹구구식, 자금 부족의 차고 스타트업(startup)으로 대표됩니다. 두어 명의 사람들이 무명으로 새로운 기술을 개발합니다. 마케팅 없이 출시하고 처음에는 소수의 (광적으로 헌신적인) 사용자만 확보합니다. 그들은 기술을 계속 개선하고, 그동안 사용자 기반은 입소문으로 성장합니다. 자신들도 모르는 사이에 그들은 거대해집니다.

다른 접근 방식인 빅뱅 방식은 벤처캐피탈(VC)의 지원을 받고 대대적으로 마케팅되는 스타트업으로 대표됩니다. 그들은 제품 개발을 서두르고, 대대적인 홍보와 함께 출시하며, 즉시 (그들이 희망하는 대로) 대규모 사용자 기반을 확보합니다.

일반적으로 차고에서 시작한 사람들은 빅뱅 방식으로 시작한 사람들을 부러워합니다. 빅뱅 방식의 사람들은 세련되고 자신감 있으며 벤처캐피탈로부터 존경받습니다. 그들은 모든 최고급 서비스를 이용할 수 있으며, 출시를 둘러싼 홍보 캠페인은 그들을 유명인사로 만드는 부수적인 효과를 낳습니다. 차고에 앉아있는 유기적 성장 방식의 사람들은 가난하고 사랑받지 못한다고 느낍니다. 하지만 저는 그들이 스스로를 불쌍히 여기는 것이 종종 착각이라고 생각합니다.

유기적 성장이 빅뱅 방식보다 더 나은 기술과 더 부유한 창업자들을 낳는 것 같습니다. 오늘날 지배적인 기술들을 살펴보면, 대부분이 유기적으로 성장했다는 것을 알 수 있을 것입니다.

이러한 패턴은 회사에만 적용되는 것이 아닙니다. 스폰서 연구에서도 볼 수 있습니다. 멀틱스(Multics)와 커먼 리스프는 빅뱅 프로젝트였고, 유닉스와 매클리스프는 유기적 성장 프로젝트였습니다.

## 10. 재설계 (Redesign)

"최고의 글쓰기는 다시 쓰기다"라고 E. B. 화이트(E. B. White)는 썼습니다. 모든 좋은 작가는 이 사실을 알고 있으며, 소프트웨어에도 마찬가지입니다. 디자인의 가장 중요한 부분은 재설계입니다. 특히 프로그래밍 언어는 충분히 재설계되지 않습니다.

좋은 소프트웨어를 작성하려면 두 가지 상반된 아이디어를 동시에 머릿속에 담고 있어야 합니다. 젊은 해커의 능력에 대한 순진한 믿음과 동시에 베테랑의 회의적인 태도를 가져야 합니다. 한쪽 뇌로는 '얼마나 어려울까?'라고 생각하면서 다른 쪽 뇌로는 '절대 안 될 거야'라고 생각할 수 있어야 합니다.

핵심은 여기에는 실제 모순이 없다는 것을 깨닫는 것입니다. 당신은 두 가지 다른 것에 대해 낙관적이고 회의적이어야 합니다. 문제를 해결할 가능성에 대해서는 낙관적이어야 하지만, 지금까지 얻은 어떤 해결책의 가치에 대해서는 회의적이어야 합니다.

훌륭한 일을 하는 사람들은 종종 자신이 작업하는 것이 좋지 않다고 생각합니다. 다른 사람들은 그들이 한 일을 보고 경이로움을 느끼지만, 창작자는 걱정으로 가득 차 있습니다. 이러한 패턴은 우연이 아닙니다. 걱정 때문에 작업이 훌륭해진 것입니다.

희망과 걱정의 균형을 유지할 수 있다면, 이 두 가지는 두 발이 자전거를 앞으로 나아가게 하는 것처럼 프로젝트를 앞으로 나아가게 할 것입니다. 두 주기 혁신 엔진의 첫 번째 단계에서는 문제를 해결할 수 있다는 자신감에 영감을 받아 어떤 문제에 대해 맹렬히 작업합니다. 두 번째 단계에서는 아침의 차가운 빛 속에서 자신이 한 일을 바라보고 모든 결함을 명확하게 봅니다. 그러나 비판적인 정신이 희망보다 더 중요해지지 않는 한, 인정할 수밖에 없는 불완전한 시스템을 보고 "나머지를 완성하는 것이 얼마나 어려울까?"라고 생각하며 주기를 계속할 수 있을 것입니다.

두 힘의 균형을 유지하는 것은 까다롭습니다. 젊은 해커들에게는 낙관주의가 지배적입니다. 그들은 무언가를 만들고, 그것이 훌륭하다고 확신하며, 결코 개선하지 않습니다. 나이 든 해커들에게는 회의론이 지배적이며, 그들은 야심찬 프로젝트에 감히 도전하지도 않습니다.

재설계 주기를 계속 유지하는 데 도움이 되는 것은 무엇이든 좋습니다. 산문은 마음에 들 때까지 계속해서 다시 쓸 수 있습니다. 하지만 소프트웨어는 일반적으로 충분히 재설계되지 않습니다. 산문에는 독자가 있지만, 소프트웨어에는 사용자가 있습니다. 작가가 에세이를 다시 쓴다고 해서, 이전 버전을 읽었던 사람들이 새로 도입된 비호환성 때문에 생각이 망가졌다고 불평할 가능성은 거의 없습니다.

사용자는 양날의 검입니다. 그들은 당신이 언어를 개선하는 데 도움이 될 수 있지만, 개선을 방해할 수도 있습니다. 그러므로 사용자를 신중하게 선택하고, 그 수를 천천히 늘려가십시오. 사용자를 갖는 것은 최적화와 같습니다. 현명한 방법은 그것을 미루는 것입니다. 또한, 일반적으로 당신이 생각하는 것보다 더 많은 것을 한 번에 바꿀 수 있습니다. 변화를 도입하는 것은 밴드를 떼어내는 것과 같습니다. 고통은 느끼는 순간 거의 기억이 됩니다.

모두가 언어를 위원회에서 설계하는 것이 좋지 않다는 것을 알고 있습니다. 위원회는 나쁜 디자인을 낳습니다. 하지만 위원회의 가장 큰 위험은 재설계를 방해한다는 점이라고 생각합니다. 변경 사항을 도입하는 것이 너무 많은 작업이라 아무도 신경 쓰고 싶어 하지 않습니다. 위원회가 결정하는 것은 대부분의 구성원이 마음에 들지 않더라도 그대로 유지되는 경향이 있습니다.

두 명으로 구성된 위원회조차 재설계를 방해합니다. 이것은 특히 두 명의 다른 사람이 작성한 소프트웨어 부분 사이의 인터페이스에서 발생합니다. 인터페이스를 변경하려면 두 사람이 동시에 변경에 동의해야 합니다. 따라서 인터페이스는 전혀 변경되지 않는 경향이 있으며, 이는 모든 시스템에서 가장 임시적인 부분 중 하나인 경향이 있기 때문에 문제입니다.

여기서 한 가지 해결책은 시스템을 수직이 아닌 수평으로 인터페이스가 설계되도록 하는 것입니다. 즉, 모듈이 항상 수직으로 쌓인 추상화 계층이 되도록 하는 것입니다. 그러면 인터페이스는 그들 중 하나가 소유하는 경향이 있을 것입니다. 두 레벨 중 하위 레벨은 상위 레벨이 작성된 언어가 될 것이며, 이 경우 하위 레벨이 인터페이스를 소유하게 됩니다. 그렇지 않으면 하위 레벨은 종속적인 것이 될 것이며, 이 경우 인터페이스는 상위 레벨에 의해 결정될 수 있습니다.

## 11. 리스프 (Lisp)

이 모든 것이 의미하는 바는 새로운 리스프에 대한 희망이 있다는 것입니다. 리스프를 포함하여 해커들이 원하는 것을 제공하는 어떤 언어에도 희망이 있습니다. 우리는 해커들이 리스프의 기이함 때문에 외면한다고 생각한 것이 실수였을지도 모른다고 생각합니다. 이 편안한 환상 때문에 리스프, 또는 적어도 커먼 리스프의 실제 문제, 즉 해커들이 하고 싶어 하는 일을 하는 데 최악이라는 점을 보지 못했을 수도 있습니다. 해커의 언어는 강력한 라이브러리와 해킹할 대상을 필요로 합니다. 커먼 리스프는 둘 다 가지고 있지 않습니다. 해커의 언어는 간결하고 해킹 가능해야 합니다. 커먼 리스프는 그렇지 않습니다.

좋은 소식은 리스프 자체가 최악이 아니라 커먼 리스프가 최악이라는 것입니다. 만약 우리가 진정한 해커의 언어인 새로운 리스프를 개발할 수 있다면, 해커들이 그것을 사용할 것이라고 생각합니다. 그들은 주어진 작업을 더 잘 수행하는 어떤 언어든 사용할 것입니다. 우리가 해야 할 일은 이 새로운 리스프가 다른 언어보다 더 중요한 작업을 더 잘 수행하도록 하는 것입니다.

역사는 고무적인 메시지를 줍니다. 시간이 지남에 따라 연속적인 새로운 프로그래밍 언어들은 리스프에서 점점 더 많은 기능을 가져왔습니다. 이제 당신이 만든 언어가 리스프가 되기 전에 복사할 것이 거의 남아있지 않습니다. 가장 최근의 인기 있는 언어인 파이썬(Python)은 중위 문법(infix syntax)과 매크로가 없는 희석된 리스프입니다. 새로운 리스프는 이러한 발전의 자연스러운 단계가 될 것입니다.

때로는 이것을 '파이썬의 개선된 버전'이라고 부르는 것이 좋은 마케팅 전략이 될 것이라고 생각합니다. 리스프보다 더 세련되게 들리니까요. 많은 사람들에게 리스프는 괄호가 많은 느린 인공지능 언어입니다. 프리츠 쿤체(Fritz Kunze)의 공식 전기에는 'L-단어'를 언급하는 것을 신중하게 피합니다. 하지만 저는 새로운 리스프를 리스프라고 부르는 것을 두려워해서는 안 된다고 생각합니다. 리스프는 여전히 최고의 해커들, 예를 들어 6.001을 듣고 이해했던 사람들에게 잠재적인 존경심을 가지고 있습니다. 그리고 그들이 바로 당신이 사로잡아야 할 사용자들입니다.

"해커가 되는 법"에서 에릭 레이먼드(Eric Raymond)는 리스프를 라틴어나 그리스어 같은 것으로 묘사합니다. 지적인 훈련으로 배워야 할 언어지만, 실제로는 많이 사용하지는 않을 것이라고 말이죠.

> 리스프는 마침내 그것을 이해할 때 얻게 될 심오한 깨달음의 경험을 위해 배울 가치가 있습니다. 그 경험은 당신이 리스프 자체를 많이 사용하지 않더라도 평생 더 나은 프로그래머가 되도록 해줄 것입니다.

만약 제가 리스프를 몰랐다면, 이 글을 읽고 질문을 던졌을 것입니다. 나를 더 나은 프로그래머로 만들어 줄 언어라면, 무엇이든 프로그래밍에 더 좋다는 것을 의미합니다. 그리고 그것이 사실 에릭이 말하는 함의입니다.

그러한 아이디어가 여전히 떠돌고 있는 한, 저는 해커들이 리스프라고 불리더라도 새로운 리스프를 충분히 수용할 것이라고 생각합니다. 하지만 이 리스프는 1970년대의 고전적인 리스프처럼 해커의 언어여야 합니다. 간결하고, 단순하며, 해킹 가능해야 합니다. 그리고 해커들이 지금 하고 싶어 하는 일을 할 수 있는 강력한 라이브러리를 가져야 합니다.

라이브러리 문제에서는 펄이나 파이썬 같은 언어들을 그들 자신의 게임에서 이길 여지가 있다고 생각합니다. 향후 몇 년 안에 작성되어야 할 새로운 애플리케이션 중 상당수는 서버 기반 애플리케이션이 될 것입니다. 새로운 리스프가 펄만큼 좋은 문자열 라이브러리를 가지지 못할 이유가 없으며, 만약 이 새로운 리스프가 서버 기반 애플리케이션을 위한 강력한 라이브러리도 가진다면 매우 인기가 많을 수 있습니다. 진정한 해커들은 몇 번의 라이브러리 호출로 어려운 문제를 해결할 수 있게 해주는 새로운 도구를 외면하지 않을 것입니다. 기억하십시오, 해커들은 게으릅니다.

서버 기반 애플리케이션에 대한 핵심 언어 지원이 있다면 훨씬 더 큰 성공을 거둘 수 있습니다. 예를 들어, 다중 사용자 프로그램에 대한 명시적 지원이나 타입 태그(type tag) 수준에서의 데이터 소유권 같은 것입니다. 서버 기반 애플리케이션은 또한 이 새로운 리스프가 무엇을 해킹하는 데 사용될지에 대한 답도 제공합니다. 리스프를 유닉스 스크립팅 언어로 더 좋게 만드는 것도 나쁘지 않을 것입니다. (더 나쁘게 만들기는 어려울 것입니다.) 하지만 저는 기존 언어들을 이기기 더 쉬운 분야가 있다고 생각합니다. Tcl의 모델을 따라 리스프를 서버 기반 애플리케이션을 지원하는 완전한 시스템과 함께 제공하는 것이 더 나을 수도 있다고 생각합니다. 리스프는 서버 기반 애플리케이션에 자연스럽게 잘 맞습니다. 렉시컬 클로저(lexical closure)는 UI가 일련의 웹 페이지일 때 서브루틴(subroutine)의 효과를 얻는 방법을 제공합니다. S-표현식은 HTML에 잘 매핑되며, 매크로는 HTML 생성을 잘합니다. 서버 기반 애플리케이션을 작성하기 위한 더 나은 도구들이 필요하며, 새로운 리스프도 필요하며, 이 두 가지는 매우 잘 어울릴 것입니다.

## 12. 꿈의 언어 (The Dream Language)

요약하자면, 해커의 꿈의 언어를 묘사해 봅시다.

꿈의 언어는 **아름답고**, 깔끔하며, 간결합니다. 빠르게 시작되는 대화형 최상위 수준(interactive toplevel)을 가지고 있습니다. 아주 적은 코드로 일반적인 문제를 해결하는 프로그램을 작성할 수 있습니다. 작성하는 어떤 프로그램에서든 거의 모든 코드는 애플리케이션에 특화된 코드입니다. 다른 모든 것은 이미 당신을 위해 처리되었습니다.

언어의 문법은 지나치게 간결합니다. 불필요한 문자를 입력할 필요가 없으며, 시프트 키(shift key)를 거의 사용할 필요도 없습니다. 큰 추상화를 사용하여 프로그램의 첫 번째 버전을 매우 빠르게 작성할 수 있습니다. 나중에 최적화하고 싶을 때는, 주의를 집중할 곳을 알려주는 정말 좋은 프로파일러가 있습니다. 내부 루프를 눈부시게 빠르게 만들 수 있으며, 필요한 경우 인라인 바이트코드를 작성할 수도 있습니다.

배울 만한 좋은 예제들이 많으며, 언어가 충분히 직관적이어서 몇 분 안에 예제를 통해 사용법을 배울 수 있습니다. 설명서를 많이 찾아볼 필요가 없습니다. 설명서는 얇고, 경고나 조건이 거의 없습니다.

언어는 작은 핵심(core)과, 핵심 언어만큼 신중하게 설계된 강력하고 고도로 직교적인 라이브러리를 가지고 있습니다. 모든 라이브러리는 서로 잘 작동하며, 언어의 모든 부분이 정교한 카메라의 부품처럼 딱 맞습니다. 더 이상 사용되지 않거나 호환성을 위해 유지되는 것은 없습니다. 모든 라이브러리의 소스 코드는 쉽게 구할 수 있습니다. 운영체제 및 다른 언어로 작성된 애플리케이션과 쉽게 통신할 수 있습니다.

언어는 계층적으로 구성됩니다. 고수준 추상화는 하위 수준 추상화에서 매우 투명한 방식으로 구축되며, 원한다면 하위 수준 추상화에 접근할 수 있습니다.

절대적으로 숨겨야 할 것이 아니면 당신에게서 숨겨지는 것은 없습니다. 언어는 당신에게 무엇을 하라고 지시하는 방식이 아니라, 작업을 절약해 주는 방식으로만 추상화를 제공합니다. 사실 언어는 당신이 언어 설계에 동등하게 참여하도록 장려합니다. 당신은 문법을 포함하여 언어의 모든 것을 변경할 수 있으며, 당신이 작성하는 모든 것은 가능한 한 미리 정의된 것과 동일한 지위를 가집니다.

---
참고

[1] 현대적인 아이디어와 매우 유사한 매크로는 리스프 1.5가 출시된 지 2년 후인 1964년에 티모시 하트(Timothy Hart)에 의해 제안되었습니다. 초기에는 변수 포획과 다중 평가를 피하는 방법이 없었습니다. 하트의 예제들은 두 가지 모두에 취약했습니다.

[2] 신경외과 의사 프랭크 베르토시크(Frank Vertosick)는 '뇌를 자극할 때(When the Air Hits Your Brain)'라는 책에서 그의 수석 레지던트 게리(Gary)가 외과의사와 내과의사("벼룩")의 차이에 대해 이야기하는 대화를 회상합니다.

> 게리와 나는 큰 피자를 주문하고 비어있는 부스를 찾았다. 수석 레지던트가 담배에 불을 붙였다. "저 망할 벼룩들을 봐, 평생 한 번 볼까 말까 한 질병에 대해 지껄이고 있잖아. 그게 벼룩들의 문제야, 그들은 기이한 것만 좋아해. 그들은 자신들의 주요한 사례들을 싫어하지. 우리와 그 망할 벼룩들의 차이야. 봐, 우리는 크고 즙이 많은 요추 디스크 탈출증을 좋아하지만, 그들은 고혈압을 싫어해..."

요추 디스크 탈출증이 '즙이 많다'고 생각하기는 어렵습니다(문자 그대로는 제외하고). 하지만 저는 그들이 무슨 의미인지 아는 것 같습니다. 저도 종종 '즙이 많은' 버그를 추적해야 했습니다. 프로그래머가 아닌 사람은 버그에 즐거움이 있을 수 있다는 것을 상상하기 어려울 것입니다. 모든 것이 그냥 작동하는 것이 확실히 더 좋습니다. 어떤 면에서는 그렇습니다. 하지만 어떤 종류의 버그를 추적하는 데는 부인할 수 없는 냉혹한 만족감이 있습니다.