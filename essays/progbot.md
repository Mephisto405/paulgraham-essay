# 상향식 프로그래밍 (Programming Bottom-Up)

1993년

(이 에세이는 『On Lisp』의 서문에서 발췌했습니다.)

프로그램의 기능적 요소들이 너무 커서는 안 된다는 것은 프로그래밍 스타일의 오랜 원칙입니다. 프로그램의 어떤 구성 요소가 쉽게 이해할 수 있는 단계를 넘어 커지게 되면, 그것은 큰 도시가 도망자를 숨기듯이 오류를 쉽게 숨기는 복잡한 덩어리가 됩니다. 이러한 소프트웨어는 읽기 어렵고, 테스트하기 어려우며, 디버깅하기 어려울 것입니다.

이 원칙에 따라, 큰 프로그램은 조각으로 나누어져야 하며, 프로그램이 커질수록 더 많이 나누어야 합니다. 프로그램을 어떻게 나눌까요? 전통적인 접근 방식은 하향식 설계(top-down design)라고 불립니다. 즉, "이 프로그램의 목적은 이 7가지 일을 하는 것이므로, 7개의 주요 서브루틴(subroutine)으로 나눈다. 첫 번째 서브루틴은 이 4가지 일을 해야 하므로, 그것 자체로 4개의 자체 서브루틴을 갖게 될 것이다"와 같이 진행됩니다. 이 과정은 전체 프로그램이 적절한 세분화 수준(granularity)을 가질 때까지 계속됩니다. 즉, 각 부분이 실질적인 작업을 수행하기에 충분히 크지만, 단일 단위로 이해될 만큼 충분히 작아야 합니다.

숙련된 리스프(Lisp) 프로그래머들은 프로그램을 다르게 나눕니다. 하향식 설계 외에도, 그들은 상향식 설계(bottom-up design)라고 부를 수 있는 원칙, 즉 문제를 해결하기 위해 언어를 변경하는 원칙을 따릅니다. 리스프에서는 프로그램을 언어에 맞춰서만 작성하는 것이 아니라, 언어를 프로그램에 맞춰서 구축하기도 합니다. 프로그램을 작성하면서 "리스프에 이런저런 연산자(operator)가 있었으면 좋겠다"고 생각할 수 있습니다. 그래서 직접 작성합니다. 나중에 새로운 연산자를 사용하면 프로그램의 다른 부분 설계가 단순해진다는 것을 깨닫는 식입니다. 언어와 프로그램은 함께 진화합니다. 마치 두 전쟁 중인 국가 사이의 국경처럼, 언어와 프로그램 사이의 경계는 그려지고 다시 그려지다가 결국 당신의 문제의 산과 강, 즉 자연적인 경계선을 따라 정착됩니다. 결국 당신의 프로그램은 마치 그 언어가 프로그램을 위해 설계된 것처럼 보일 것입니다. 그리고 언어와 프로그램이 서로 잘 맞으면, 명확하고 작으며 효율적인 코드를 얻게 됩니다.

상향식 설계가 단순히 같은 프로그램을 다른 순서로 작성하는 것을 의미하지 않는다는 점을 강조할 필요가 있습니다. 상향식으로 작업할 때, 당신은 보통 다른 프로그램으로 끝을 맺습니다. 단일하고 거대한 프로그램 대신, 더 추상적인 연산자를 가진 더 큰 언어와 그 언어로 작성된 더 작은 프로그램을 얻게 될 것입니다. 인방(lintel) 대신 아치(arch)를 얻게 될 것입니다.

일반적인 코드에서 단순히 정리 작업(bookkeeping)을 하는 부분을 추상화하면, 남는 것은 훨씬 짧아집니다. 언어를 높이 구축할수록, 상위에서 하위로 내려가는 거리가 짧아집니다. 이것은 몇 가지 장점을 가져옵니다:

언어가 더 많은 작업을 수행하게 함으로써, 상향식 설계는 더 작고 민첩한 프로그램을 만들어냅니다. 프로그램이 짧으면 그렇게 많은 구성 요소로 나눌 필요가 없으며, 구성 요소가 적다는 것은 프로그램을 더 쉽게 읽거나 수정할 수 있다는 것을 의미합니다. 구성 요소가 적다는 것은 구성 요소 간의 연결도 적어서 오류 발생 가능성이 줄어든다는 것을 의미합니다. 산업 디자이너들이 기계의 움직이는 부품 수를 줄이려고 노력하듯이, 숙련된 리스프 프로그래머들은 상향식 설계를 사용하여 프로그램의 크기와 복잡성을 줄입니다.

상향식 설계는 코드 재사용을 촉진합니다. 두 개 이상의 프로그램을 작성할 때, 첫 번째 프로그램을 위해 작성한 유틸리티(utilities) 중 많은 부분이 다음 프로그램에서도 유용할 것입니다. 일단 많은 유틸리티의 기반(large substrate)을 확보하면, 새로운 프로그램을 작성하는 데는 원시 리스프(raw Lisp)에서 시작해야 할 때 필요한 노력의 일부만 필요할 수 있습니다.

상향식 설계는 프로그램을 더 쉽게 읽을 수 있도록 합니다. 이러한 유형의 추상화(abstraction)의 한 예는 독자에게 범용 연산자(general-purpose operator)를 이해하도록 요청하는 것이고, 기능적 추상화(functional abstraction)의 한 예는 독자에게 특수 목적 서브루틴(special-purpose subroutine)을 이해하도록 요청하는 것입니다.

코드에서 패턴을 항상 찾아보게 만들기 때문에, 상향식 작업은 프로그램 설계에 대한 아이디어를 명확히 하는 데 도움이 됩니다. 프로그램의 두 개의 멀리 떨어진 구성 요소가 형태가 비슷하다면, 그 유사성을 알아차리게 되고 아마도 프로그램을 더 간단한 방식으로 재설계하게 될 것입니다.

상향식 설계는 리스프 외의 다른 언어에서도 어느 정도 가능합니다. 라이브러리 함수(library functions)를 볼 때마다 상향식 설계가 일어나고 있습니다. 그러나 리스프는 이 분야에서 훨씬 더 넓은 권한을 제공하며, 언어를 확장하는 것이 리스프 스타일에서 비례적으로 더 큰 역할을 합니다. 리스프는 단순히 다른 언어가 아니라 완전히 다른 프로그래밍 방식이라고 할 수 있을 정도입니다.

이러한 개발 스타일이 소규모 그룹이 작성할 수 있는 프로그램에 더 적합하다는 것은 사실입니다. 그러나 동시에, 그것은 소규모 그룹이 할 수 있는 일의 한계를 확장합니다. 『미신적인 맨먼스 (The Mythical Man-Month)』에서 프레데릭 브룩스(Frederick Brooks)는 프로그래머 그룹의 생산성이 그 규모에 비례하여 선형적으로 증가하지 않는다고 제안했습니다. 그룹의 규모가 커질수록 개별 프로그래머의 생산성은 떨어집니다. 리스프 프로그래밍의 경험은 이 법칙을 더 즐거운 방식으로 표현할 수 있음을 시사합니다. 그룹의 규모가 작아질수록 개별 프로그래머의 생산성은 증가합니다. 소규모 그룹은 단순히 규모가 작기 때문에 상대적으로 승리합니다. 소규모 그룹이 리스프가 가능하게 하는 기술을 활용하면, 완전한 승리를 거둘 수 있습니다.

**참고 (Notes)**

[1] "하지만 아무도 당신의 새로운 유틸리티를 모두 이해하지 않고는 프로그램을 읽을 수 없습니다." 그러한 진술이 왜 대개 잘못되었는지 보려면, 섹션 4.8을 참조하십시오.