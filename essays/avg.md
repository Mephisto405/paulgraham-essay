# 평균을 넘어서 (Beating the Averages)

스타트업을 시작하고 싶으신가요? Y Combinator에서 투자를 받으세요.

2001년 4월, 개정 2001년 4월
(이 글은 2001년 Franz Developer Symposium에서 한 강연을 바탕으로 작성되었습니다.)

1995년 여름, 제 친구 로버트 모리스와 저는 Viaweb이라는 스타트업을 시작했습니다. 우리의 계획은 최종 사용자가 온라인 스토어를 구축할 수 있는 소프트웨어를 만드는 것이었습니다. 당시 이 소프트웨어의 참신함은 ordinary Web pages를 인터페이스로 사용하여 우리 서버에서 실행된다는 점이었습니다. 물론 많은 사람들이 동시에 이 아이디어를 떠올릴 수도 있었겠지만, 제가 알기로 Viaweb은 최초의 웹 기반 애플리케이션이었습니다. 이는 우리에게 너무나 참신한 아이디어였기에, 회사 이름도 그에 맞춰 Viaweb이라고 지었습니다. 우리 소프트웨어가 데스크톱 컴퓨터에서 실행되는 대신 웹을 통해 작동했기 때문입니다.

이 소프트웨어의 또 다른 특이한 점은 주로 Lisp라는 프로그래밍 언어로 작성되었다는 것입니다. Lisp는 당시 주로 대학과 연구실에서 사용되었던 언어인데, Lisp로 작성된 최초의 대규모 최종 사용자 애플리케이션 중 하나였습니다.[1]

## 비밀 병기

에릭 레이먼드는 "해커가 되는 법"이라는 에세이에서, 다른 것들 중에서도 예비 해커들에게 어떤 언어를 배워야 하는지 조언합니다. 그는 배우기 쉽기 때문에 파이썬(Python)과 자바(Java)로 시작할 것을 제안합니다. 진정한 해커는 유닉스(Unix)를 다루기 위해 C를, 시스템 관리와 CGI 스크립트를 위해 펄(Perl)도 배우고 싶어할 것입니다. 마지막으로, 정말 진지한 해커는 Lisp를 배우는 것을 고려해야 합니다:

> Lisp는 마침내 그것을 이해했을 때 얻게 될 심오한 깨달음의 경험을 위해 배울 가치가 있습니다. 그 경험은 실제 Lisp 자체를 많이 사용하지 않더라도 평생 동안 여러분을 더 나은 프로그래머로 만들어 줄 것입니다.

이는 라틴어를 배우는 것에 대해 흔히 듣는 주장과 같습니다. 고전 학과 교수 같은 직업을 제외하고는 직업을 얻는 데 도움이 되지 않겠지만, 정신을 향상시키고 영어와 같이 실제로 사용하고 싶은 언어로 글을 쓰는 데 더 나은 작가가 되도록 도와줄 것입니다.

하지만 잠시만요. 이 비유는 모든 면에서 맞지 않습니다. 라틴어가 직업을 얻는 데 도움이 되지 않는 이유는 아무도 그것을 사용하지 않기 때문입니다. 라틴어로 글을 쓰면 아무도 이해하지 못합니다. 하지만 Lisp는 컴퓨터 언어이고, 컴퓨터는 프로그래머인 당신이 지시하는 언어를 말합니다.

그렇다면 Lisp가 레이먼드가 말한 대로 당신을 더 나은 프로그래머로 만든다면, 왜 그것을 사용하지 않겠습니까? 만약 화가에게 자신을 더 나은 화가로 만들어 줄 붓이 주어진다면, 그는 모든 그림에 그 붓을 사용하고 싶어하지 않을까요? 저는 에릭 레이먼드를 놀리려는 것이 아닙니다. 전반적으로 그의 조언은 좋습니다. Lisp에 대해 그가 말하는 것은 거의 통념입니다. 하지만 통념에는 모순이 있습니다. Lisp는 당신을 더 나은 프로그래머로 만들지만, 당신은 그것을 사용하지 않을 것입니다.

왜 사용하지 않을까요? 결국 프로그래밍 언어는 도구일 뿐입니다. Lisp가 정말로 더 나은 프로그램을 만든다면, 당신은 그것을 사용해야 합니다. 만약 그렇지 않다면, 누가 그것을 필요로 하겠습니까?

이것은 단순한 이론적인 질문이 아닙니다. 소프트웨어는 매우 경쟁적인 비즈니스이며, 자연 독점의 경향이 있습니다. 다른 모든 조건이 동일하다면, 소프트웨어를 더 빠르고 더 잘 작성하는 회사는 경쟁사를 파산시킬 것입니다. 그리고 스타트업을 시작할 때, 당신은 이것을 매우 절실하게 느낍니다. 스타트업은 종종 전부 아니면 전무의 상황으로 이어집니다. 부자가 되거나, 아무것도 얻지 못하거나 둘 중 하나입니다. 스타트업에서 잘못된 기술에 베팅하면, 경쟁자가 당신을 짓밟을 것입니다.

로버트와 저는 둘 다 Lisp를 잘 알고 있었고, 우리의 직감을 믿고 Lisp를 선택하지 않을 이유가 없었습니다. 우리는 다른 모든 사람들이 C++나 Perl로 소프트웨어를 작성하고 있다는 것을 알았습니다. 하지만 그것이 아무것도 의미하지 않는다는 것도 알았습니다. 만약 당신이 그런 방식으로 기술을 선택한다면, 당신은 Windows를 실행하고 있을 것입니다. 기술을 선택할 때는 다른 사람들이 무엇을 하고 있는지 무시하고, 무엇이 가장 잘 작동할지만 고려해야 합니다.

이것은 스타트업에서 특히 그렇습니다. 대기업에서는 다른 모든 대기업이 하는 대로 할 수 있습니다. 하지만 스타트업은 다른 모든 스타트업이 하는 대로 할 수 없습니다. 저는 많은 사람들이 이것을 스타트업 내부에서도 깨닫지 못한다고 생각합니다.

평균적인 대기업은 연간 약 10%씩 성장합니다. 따라서 대기업을 운영하고 있고 평균적인 대기업과 모든 것을 똑같이 한다면, 평균적인 대기업만큼, 즉 연간 약 10%의 성장률을 기대할 수 있습니다. 스타트업을 운영하는 경우에도 마찬가지입니다. 만약 평균적인 스타트업이 하는 모든 것을 그대로 따른다면, 평균적인 성과를 기대해야 합니다. 여기서 문제는 평균적인 성과가 곧 파산을 의미한다는 것입니다. 스타트업의 생존율은 50%보다 훨씬 낮습니다. 따라서 스타트업을 운영하고 있다면, 뭔가 이상한 일을 하는 편이 좋습니다. 그렇지 않으면 곤란해질 것입니다.

1995년으로 돌아가서, 우리는 경쟁사들이 이해하지 못했고 지금도 이해하는 사람이 거의 없는 무언가를 알고 있었습니다. 바로 자신의 서버에서만 실행되면 되는 소프트웨어를 작성할 때는 원하는 언어를 무엇이든 사용할 수 있다는 것입니다. 데스크톱 소프트웨어를 작성할 때는 운영체제와 같은 언어로 애플리케이션을 작성하려는 강한 경향이 있습니다. 10년 전에는 애플리케이션을 작성한다는 것은 C로 애플리케이션을 작성하는 것을 의미했습니다. 하지만 웹 기반 소프트웨어, 특히 언어와 운영체제의 소스 코드를 모두 가지고 있을 때는 원하는 언어를 무엇이든 사용할 수 있습니다.

그러나 이 새로운 자유는 양날의 검입니다. 이제 어떤 언어든 사용할 수 있으므로, 어떤 언어를 사용할지 생각해야 합니다. 아무것도 변하지 않은 것처럼 행동하려는 회사는 경쟁자들이 그렇게 하지 않을 경우 위험에 처할 수 있습니다.

어떤 언어든 사용할 수 있다면, 어떤 언어를 사용해야 할까요? 우리는 Lisp를 선택했습니다. 한 가지 이유는 이 시장에서 빠른 개발이 중요할 것이라는 점이 명백했기 때문입니다. 우리 모두 처음부터 시작했으므로, 경쟁자보다 먼저 새로운 기능을 완료할 수 있는 회사는 큰 이점을 가질 것입니다. 우리는 Lisp가 소프트웨어를 빠르게 작성하는 데 정말 좋은 언어라는 것을 알았고, 서버 기반 애플리케이션은 빠른 개발의 효과를 증폭시킵니다. 왜냐하면 소프트웨어가 완료되는 즉시 출시할 수 있기 때문입니다.

다른 회사들이 Lisp를 사용하고 싶어하지 않는다면, 더 좋습니다. 그것이 우리에게 기술적 우위를 줄 수 있고, 우리는 우리가 얻을 수 있는 모든 도움을 필요로 했습니다. Viaweb을 시작했을 때, 우리는 비즈니스 경험이 전혀 없었습니다. 마케팅, 사람 고용, 자금 조달, 고객 확보 등에 대해 아무것도 몰랐습니다. 우리 둘 다 제대로 된 직장 경험조차 가져본 적이 없었습니다. 우리가 잘했던 유일한 것은 소프트웨어를 작성하는 것이었습니다. 그것이 우리를 살려주기를 바랐습니다. 소프트웨어 부문에서 얻을 수 있는 이점은 무엇이든 취할 것입니다.

그래서 Lisp를 사용한 것은 실험이라고 말할 수 있습니다. 우리의 가설은 Lisp로 소프트웨어를 작성하면 경쟁자보다 빠르게 기능을 완료할 수 있고, 소프트웨어에서 그들이 할 수 없는 일을 할 수 있을 것이라는 것이었습니다. 그리고 Lisp는 매우 고급 언어였기 때문에 대규모 개발팀이 필요하지 않아 비용이 더 낮아질 것이었습니다. 만약 그렇다면, 우리는 더 적은 비용으로 더 나은 제품을 제공하면서도 이익을 남길 수 있을 것입니다. 결국 모든 사용자를 확보하고 경쟁자들은 아무것도 얻지 못하며 결국 파산하게 될 것입니다. 적어도 우리는 그렇게 되기를 바랐습니다.

이 실험의 결과는 어떠했을까요? 다소 놀랍게도, 그것은 효과가 있었습니다. 우리는 결국 20~30개에 달하는 많은 경쟁자를 갖게 되었지만, 그들의 소프트웨어 중 어느 것도 우리 것과 경쟁할 수 없었습니다. 우리는 서버에서 실행되면서도 데스크톱 애플리케이션처럼 느껴지는 wysiwyg 온라인 스토어 빌더를 보유했습니다. 경쟁자들은 CGI 스크립트를 가지고 있었습니다. 그리고 우리는 항상 기능 면에서 그들보다 훨씬 앞서 있었습니다. 때로는 절박함 속에서 경쟁자들이 우리가 가지고 있지 않은 기능을 도입하려고 시도하기도 했습니다. 하지만 Lisp를 사용하면 개발 주기가 매우 빨라서 경쟁자가 보도 자료를 통해 새로운 기능을 발표한 지 하루 이틀 만에 이를 복제할 수도 있었습니다. 보도 자료를 다루는 기자들이 우리에게 전화를 걸 때쯤이면, 우리도 이미 새로운 기능을 갖추고 있었습니다.

경쟁자들에게는 우리가 마치 비밀 병기라도 가진 것처럼 보였을 것입니다. 마치 에니그마(Enigma) 통신을 해독하고 있는 것처럼 말입니다. 사실 우리는 비밀 병기를 가지고 있었지만, 그들이 생각하는 것보다 훨씬 단순했습니다. 아무도 우리에게 그들의 기능에 대한 소식을 누설하지 않았습니다. 우리는 단지 누구도 생각하지 못했던 속도로 소프트웨어를 개발할 수 있었을 뿐입니다.

제가 아홉 살쯤 되었을 때 우연히 프레더릭 포사이스의 "자칼의 날(The Day of the Jackal)" 사본을 손에 넣게 되었습니다. 주인공은 프랑스 대통령을 암살하기 위해 고용된 암살자입니다. 암살자는 대통령 경로를 내려다보는 아파트에 잠입하기 위해 경찰을 통과해야 합니다. 그는 절뚝발이 노인으로 변장하고 경찰 앞을 지나가지만, 그들은 전혀 의심하지 않습니다.

우리의 비밀 병기도 비슷했습니다. 우리는 괄호로 가득 찬 기괴한 구문을 가진, 특이한 AI 언어로 소프트웨어를 작성했습니다. 몇 년 동안 Lisp가 그렇게 묘사되는 것을 듣는 것이 저를 괴롭혔습니다. 하지만 이제 그것이 우리의 이점으로 작용했습니다. 비즈니스에서 경쟁자들이 이해하지 못하는 기술적 이점보다 더 가치 있는 것은 없습니다. 비즈니스에서든 전쟁에서든, 기습은 힘만큼이나 가치가 있습니다.

그래서 솔직히 말하자면, Viaweb을 개발하는 동안 Lisp에 대해 공개적으로 아무 말도 하지 않았습니다. 언론에 전혀 언급하지 않았고, 웹사이트에서 Lisp를 검색해도 제 소개란에 있는 두 권의 책 제목만 찾을 수 있었을 것입니다. 이것은 우연이 아니었습니다. 스타트업은 경쟁자들에게 가능한 한 적은 정보를 제공해야 합니다. 만약 그들이 우리 소프트웨어가 어떤 언어로 작성되었는지 알지 못하거나 신경 쓰지 않는다면, 저는 그 상태를 유지하고 싶었습니다.[2]

우리 기술을 가장 잘 이해했던 사람들은 고객들이었습니다. 그들 역시 Viaweb이 어떤 언어로 작성되었는지 신경 쓰지 않았지만, 그것이 정말 잘 작동한다는 점에 주목했습니다. 그것을 통해 몇 분 만에 멋져 보이는 온라인 스토어를 만들 수 있었습니다. 그래서 대부분 입소문을 통해 사용자 수가 점점 늘어났습니다. 1996년 말에는 약 70개의 스토어를 온라인으로 운영했습니다. 1997년 말에는 500개가 되었습니다. 6개월 후 야후(Yahoo)가 우리를 인수했을 때, 우리는 1070명의 사용자를 보유하고 있었습니다. 오늘날 Yahoo Store로서 이 소프트웨어는 해당 시장을 계속해서 장악하고 있습니다. 야후의 수익성이 가장 좋은 부분 중 하나이며, 이를 통해 구축된 스토어는 Yahoo Shopping의 기반이 되었습니다. 저는 1999년에 야후를 떠났기 때문에 현재 정확히 몇 명의 사용자가 있는지 알지 못하지만, 마지막으로 들었을 때는 약 20,000명이었습니다.

## 블럽 역설 (The Blub Paradox)

Lisp가 무엇이 그렇게 대단한가요? 그리고 Lisp가 그렇게 대단하다면 왜 모두가 그것을 사용하지 않나요? 이 질문들은 수사적인 것처럼 들릴 수 있지만, 사실 명쾌한 답변이 있습니다. Lisp가 대단한 이유는 숭배자들만 볼 수 있는 어떤 마법 같은 품질 때문이 아니라, 단순히 사용 가능한 가장 강력한 언어이기 때문입니다. 그리고 모두가 Lisp를 사용하지 않는 이유는 프로그래밍 언어가 단순히 기술일 뿐만 아니라 사고방식이기도 하며, 사고방식은 좀처럼 변하지 않기 때문입니다. 물론 이 두 가지 답변 모두 설명이 필요합니다.

충격적일 정도로 논쟁적인 진술로 시작하겠습니다. 프로그래밍 언어는 힘에 있어 차이가 있습니다.

적어도 고수준 언어가 기계어보다 더 강력하다는 것을 거의 부정하지 못할 것입니다. 오늘날 대부분의 프로그래머는 일반적으로 기계어로 프로그래밍하고 싶지 않다는 점에 동의할 것입니다. 대신 고수준 언어로 프로그래밍하고, 컴파일러가 그것을 기계어로 번역하게 해야 합니다. 이 아이디어는 이제 하드웨어에도 내장되어 있습니다. 1980년대부터 명령어 세트는 인간 프로그래머보다는 컴파일러를 위해 설계되었습니다.

프로그램 전체를 기계어로 손으로 작성하는 것이 실수라는 것은 누구나 알고 있습니다. 덜 이해되는 점은 여기에 더 일반적인 원리가 있다는 것입니다. 즉, 여러 언어 중에서 선택할 수 있다면, 다른 모든 것이 동등하다면 가장 강력한 언어로 프로그래밍하지 않는 것이 실수라는 것입니다.[3]

이 규칙에는 많은 예외가 있습니다. 특정 언어로 작성된 프로그램과 매우 긴밀하게 작동해야 하는 프로그램을 작성하는 경우, 새 프로그램을 같은 언어로 작성하는 것이 좋을 수 있습니다. 단순히 숫자 계산이나 비트 조작과 같이 매우 간단한 작업을 수행해야 하는 프로그램을 작성하는 경우, 특히 약간 더 빠를 수 있으므로 덜 추상적인 언어를 사용하는 것이 좋습니다. 그리고 짧고 일회성 프로그램을 작성하는 경우, 해당 작업을 위한 최고의 라이브러리 함수를 갖춘 언어를 사용하는 것이 더 나을 수 있습니다. 하지만 일반적으로 애플리케이션 소프트웨어의 경우, 가능한 가장 강력한(합리적으로 효율적인) 언어를 사용하고 싶을 것이며, 다른 것을 사용하는 것은 기계어로 프로그래밍하는 것과 동일한 종류의 실수이지만, 정도는 덜할 수 있습니다.

기계어는 매우 저수준이라는 것을 알 수 있습니다. 그러나 최소한 사회적 관습의 한 형태로, 고수준 언어는 종종 동등하게 취급됩니다. 그렇지 않습니다. 기술적으로 "고수준 언어"는 매우 명확한 의미를 갖지 않습니다. 기계어와 다른 모든 고수준 언어를 구분하는 경계선은 없습니다. 언어는 가장 강력한 언어부터 기계어에 이르기까지 추상화의 연속체[4]를 따라 분포하며, 기계어 자체도 힘에 있어 다양합니다.

코볼(Cobol)을 생각해 봅시다. 코볼은 기계어로 컴파일된다는 의미에서 고수준 언어입니다. 코볼의 힘이 예를 들어 파이썬과 동등하다고 진지하게 주장할 사람이 있을까요? 아마 파이썬보다 기계어에 더 가까울 것입니다.

펄 4(Perl 4)는 어떻습니까? 펄 4와 펄 5 사이에서 렉시컬 클로저(lexical closures)가 언어에 추가되었습니다. 대부분의 펄 해커들은 펄 5가 펄 4보다 더 강력하다는 데 동의할 것입니다. 하지만 일단 그것을 인정하면, 하나의 고수준 언어가 다른 언어보다 더 강력할 수 있다는 것을 인정하게 된 것입니다. 그리고 특별한 경우가 아니라면, 가능한 가장 강력한 것을 사용해야 한다는 결론에 불가피하게 이르게 됩니다.

하지만 이 아이디어는 거의 결론까지 이어지지 않습니다. 특정 나이가 지나면 프로그래머는 자발적으로 언어를 거의 바꾸지 않습니다. 사람들이 익숙해진 언어는 그냥 충분하다고 여기는 경향이 있습니다.

프로그래머들은 자신이 좋아하는 언어에 매우 애착을 갖기 때문에, 이 점을 설명하기 위해 제 감정을 상하게 하고 싶지 않아 가상의 언어인 블럽(Blub)을 사용하겠습니다. 블럽은 추상화 연속체에서 중간쯤에 위치합니다. 가장 강력한 언어는 아니지만, 코볼이나 기계어보다는 강력합니다.

그리고 사실, 우리의 가상 블럽 프로그래머는 둘 중 어느 것도 사용하지 않을 것입니다. 물론 그는 기계어로 프로그래밍하지 않을 것입니다. 그것은 컴파일러를 위한 것입니다. 코볼에 관해서는, 그것으로 어떻게든 일을 할 수 있는지 모르겠다고 생각할 것입니다. 그것에는 x(원하는 블럽 기능)조차 없습니다.

가상의 블럽 프로그래머가 힘의 연속체를 따라 내려다보는 한, 그는 자신이 내려다보고 있다는 것을 압니다. 블럽보다 덜 강력한 언어는 명백히 덜 강력합니다. 왜냐하면 그들은 자신이 익숙한 어떤 기능을 놓치고 있기 때문입니다. 하지만 우리의 가상 블럽 프로그래머가 다른 방향, 즉 힘의 연속체를 따라 위를 바라볼 때, 그는 위를 바라보고 있다는 것을 깨닫지 못합니다. 그가 보는 것은 단순히 특이한 언어들입니다. 그는 아마도 그것들을 블럽과 거의 동등한 힘을 가지고 있다고 여기지만, 그 외에 이 모든 복잡한 것들이 추가되었다고 생각할 것입니다. 블럽은 그에게 충분히 좋습니다. 왜냐하면 그는 블럽으로 생각하기 때문입니다.

하지만 이제 힘의 연속체에서 더 높은 위치에 있는 언어를 사용하는 프로그래머의 관점으로 전환하면, 그가 블럽을 깔보는 것을 발견합니다. 블럽으로 어떻게든 일을 할 수 있습니까? y조차 없습니다.

귀납법적으로, 다양한 언어 간의 모든 힘의 차이를 볼 수 있는 유일한 프로그래머는 가장 강력한 언어를 이해하는 사람들입니다. (아마 이것이 에릭 레이먼드가 Lisp가 당신을 더 나은 프로그래머로 만든다고 말한 이유일 것입니다.) 블럽 역설 때문에 다른 사람들의 의견은 신뢰할 수 없습니다. 그들은 자신이 우연히 사용하는 언어에 만족합니다. 왜냐하면 그 언어가 프로그램에 대한 그들의 사고방식을 결정하기 때문입니다.

저는 제 자신의 경험, 즉 고등학교 시절 베이직(Basic)으로 프로그램을 작성했던 경험을 통해 이것을 알고 있습니다. 그 언어는 재귀(recursion)조차 지원하지 않았습니다. 재귀를 사용하지 않고 프로그램을 작성하는 것은 상상하기 어렵지만, 당시에는 그것을 놓치지 않았습니다. 저는 베이직으로 생각했습니다. 그리고 저는 그것에 아주 능숙했습니다. 제가 바라보는 모든 것의 주인처럼 말입니다.

에릭 레이먼드가 해커에게 추천하는 다섯 가지 언어는 힘의 연속체에서 다양한 지점에 위치합니다. 그들이 서로 상대적으로 어디에 위치하는지는 민감한 주제입니다. 제가 말할 수 있는 것은 Lisp가 맨 위에 있다고 생각한다는 것입니다. 그리고 이 주장을 뒷받침하기 위해 다른 네 가지 언어를 볼 때 빠져 있다고 생각하는 것 중 하나에 대해 이야기해 드리겠습니다. 매크로(macros) 없이는 어떻게 그 언어들로 아무것도 할 수 있겠습니까? 라고 생각합니다.[5]

많은 언어들이 매크로라고 불리는 것을 가지고 있습니다. 하지만 Lisp 매크로는 독특합니다. 그리고 믿거나 말거나, 그것들이 하는 일은 괄호와 관련이 있습니다. Lisp 설계자들이 언어에 그렇게 많은 괄호를 넣은 것은 단지 다르기 위해서가 아닙니다. 블럽 프로그래머에게 Lisp 코드는 이상하게 보입니다. 하지만 그 괄호는 이유가 있어서 거기에 있습니다. 그것들은 Lisp와 다른 언어들 간의 근본적인 차이의 외부 증거입니다.

Lisp 코드는 Lisp 데이터 객체로 만들어집니다. 그리고 소스 파일에 문자가 포함되어 있고 문자열이 언어에서 지원하는 데이터 유형 중 하나라는 사소한 의미가 아닙니다. Lisp 코드는 파서(parser)에 의해 읽힌 후, 여러분이 순회할 수 있는 데이터 구조로 만들어집니다.

컴파일러가 어떻게 작동하는지 이해한다면, 정말로 일어나고 있는 일은 Lisp가 이상한 구문을 가지고 있다기보다는 Lisp는 구문이 없다는 것입니다. 여러분은 다른 언어의 구문 분석이 이루어질 때 컴파일러 내에서 생성되는 파스 트리(parse trees)로 프로그램을 작성합니다. 하지만 이 파스 트리는 프로그램에서 완전히 접근 가능합니다. 여러분은 그것들을 조작하는 프로그램을 작성할 수 있습니다. Lisp에서는 이러한 프로그램을 매크로라고 합니다. 그것들은 프로그램을 작성하는 프로그램입니다.

프로그램을 작성하는 프로그램? 언제 그런 것을 사용하고 싶겠습니까? 코볼로 생각한다면, 별로 그렇지 않을 것입니다. Lisp로 생각한다면, 항상 그렇습니다. 여기서 강력한 매크로의 예를 들고 "자, 어떻습니까?"라고 말하면 편리하겠지만, 만약 그렇게 한다면 Lisp를 모르는 사람에게는 그냥 암호처럼 보일 것입니다. 그것이 무엇을 의미하는지 이해하기 위해 필요한 모든 것을 설명할 공간이 여기에 없습니다. "Ansi Common Lisp"에서는 최대한 빨리 진행하려고 노력했지만, 그래도 매크로에 도달하려면 160페이지까지 가야 했습니다.

하지만 설득력 있을 만한 종류의 주장을 할 수 있다고 생각합니다. Viaweb 편집기의 소스 코드는 아마도 20-25%가 매크로였습니다. 매크로는 일반 Lisp 함수보다 작성하기 어렵고, 필요하지 않을 때 사용하는 것은 좋지 않은 스타일로 간주됩니다. 따라서 해당 코드의 모든 매크로는 그것이 반드시 필요했기 때문에 존재합니다. 그것이 의미하는 바는 이 프로그램 코드의 최소 20-25%가 다른 언어에서는 쉽게 할 수 없는 작업을 수행하고 있다는 것입니다. 블럽 프로그래머가 Lisp의 신비한 힘에 대한 제 주장에 대해 아무리 회의적이더라도, 이것은 그를 궁금하게 만들어야 합니다. 우리는 우리 자신의 즐거움을 위해 이 코드를 작성한 것이 아닙니다. 우리는 작은 스타트업이었고, 우리와 경쟁자들 사이에 기술적 장벽을 세우기 위해 가능한 한 열심히 프로그래밍했습니다.

의심 많은 사람은 여기에 어떤 상관관계가 있는지 궁금해하기 시작할지도 모릅니다. 우리 코드의 큰 부분은 다른 언어에서는 매우 어려운 작업을 수행하고 있었습니다. 결과 소프트웨어는 경쟁사 소프트웨어가 할 수 없는 일을 했습니다. 아마도 어떤 종류의 연결이 있었을 것입니다. 그 스레드를 따라가 보시길 권합니다. 목발을 짚고 절뚝거리며 걷는 그 노인에게는 보이는 것 이상이 있을지도 모릅니다.

## 스타트업을 위한 아이키도 (Aikido for Startups)

하지만 저는 (25세 이상의) 누구도 Lisp를 배우러 나설 것이라고 설득할 것이라고 기대하지 않습니다. 이 글의 목적은 누구의 마음을 바꾸려는 것이 아니라, Lisp를 사용하려는 기존 사람들에게 확신을 주려는 것입니다. Lisp가 강력한 언어라는 것을 알지만 널리 사용되지 않는다는 점을 걱정하는 사람들 말입니다. 경쟁 상황에서는 그것이 이점입니다.

스타트업에서 Lisp 사용을 고려할 때, 널리 이해되지 않는다는 점을 걱정해서는 안 됩니다. 오히려 그렇게 되기를 바라야 합니다. 그리고 아마도 그렇게 될 것입니다. 프로그래밍 언어의 본질은 대부분의 사람들을 현재 사용하는 언어에 만족하게 만드는 것입니다.

컴퓨터 하드웨어는 개인 습관보다 훨씬 빠르게 변하기 때문에 프로그래밍 관행은 일반적으로 프로세서보다 10~20년 뒤처져 있습니다. MIT 같은 곳에서는 1960년대 초에 고수준 언어로 프로그램을 작성했지만, 많은 회사들은 1980년대 중반까지도 기계어로 코드를 계속 작성했습니다. 아마 많은 사람들이 프로세서가 바텐더가 문을 닫고 집으로 가고 싶어하듯 RISC 명령어 세트로 전환하여 그들을 내쫓을 때까지 계속 기계어로 코드를 작성했을 것입니다.

일반적으로 기술은 빠르게 변합니다. 하지만 프로그래밍 언어는 다릅니다. 프로그래밍 언어는 단순한 기술이 아니라 프로그래머가 생각하는 방식입니다. 그것들은 절반은 기술이고 절반은 종교입니다.[6]

따라서 중간 언어, 즉 중간 프로그래머가 사용하는 언어를 의미하는 것은 빙산처럼 느리게 움직입니다. Lisp가 1960년경에 도입한 가비지 컬렉션(garbage collection)은 이제 널리 좋은 것으로 간주됩니다. 런타임 타이핑(Runtime typing) 역시 인기가 높아지고 있습니다. 1970년대 초 Lisp가 도입한 렉시컬 클로저(lexical closures)는 이제 겨우 레이더 화면에 등장했습니다. 1960년대 중반 Lisp가 도입한 매크로는 여전히 미지의 영역입니다.

명백히 중간 언어는 막대한 추진력을 가지고 있습니다. 저는 이 강력한 힘에 맞서 싸울 것을 제안하는 것이 아닙니다. 제가 제안하는 것은 정반대입니다. 아이키도(Aikido) 수련자처럼, 그것을 상대방에게 이용할 수 있다는 것입니다.

대기업에서 일한다면 이것이 쉽지 않을 수 있습니다. 상사가 20년 전 Ada처럼 세상을 장악할 것이라고 신문에서 막 읽은 다른 언어로 무언가를 구축하도록 허락해 달라고 설득하는 데 어려움을 겪을 것입니다. 하지만 아직 고지식한 상사가 없는 스타트업에서 일한다면, 우리처럼 블럽 역설을 당신의 이점으로 활용할 수 있습니다. 즉, 중간 언어에 확고하게 고정된 경쟁자들이 결코 따라잡을 수 없는 기술을 사용할 수 있습니다.

만약 스타트업에서 일하게 된다면, 경쟁자를 평가하는 데 유용한 팁이 있습니다. 채용 공고를 읽어보세요. 웹사이트의 다른 모든 내용은 스톡 사진이나 그에 상응하는 문구일 수 있지만, 채용 공고는 올바른 지원자를 받기 위해 원하는 것에 대해 구체적이어야 합니다.

Viaweb을 개발하는 동안 저는 많은 채용 공고를 읽었습니다. 매달 새로운 경쟁자가 나타나는 것 같았습니다. 제가 가장 먼저 했던 일은 라이브 온라인 데모가 있는지 확인한 후, 채용 공고를 살펴보는 것이었습니다. 몇 년간 이렇게 한 후, 어떤 회사를 걱정해야 하고 어떤 회사를 걱정하지 않아도 되는지 알 수 있었습니다. IT 관련 내용이 많을수록 해당 회사는 덜 위험했습니다. 가장 안전한 종류는 Oracle 경험을 원하는 회사였습니다. 그런 회사들은 결코 걱정할 필요가 없었습니다. C++ 또는 Java 개발자를 원한다고 명시한 회사들도 마찬가지로 안전했습니다. 만약 Perl 또는 Python 프로그래머를 원한다면, 그것은 약간 걱정스러운 신호였습니다. 그것은 적어도 기술적인 측면에서는 실제 해커들이 운영하는 회사처럼 들리기 시작합니다. 만약 Lisp 해커를 찾는 채용 공고를 본 적이 있다면, 저는 정말로 걱정했을 것입니다.

---
[^1]: Viaweb은 처음에는 두 부분으로 나뉘었습니다. 사람들이 사이트를 구축하는 데 사용한 Lisp로 작성된 편집기와 주문을 처리한 C로 작성된 주문 시스템입니다. 첫 번째 버전은 주문 시스템이 작았기 때문에 대부분 Lisp로 작성되었습니다. 나중에 C로 작성된 이미지 생성기와 주로 Perl로 작성된 백오피스 관리자라는 두 개의 모듈을 더 추가했습니다.
2003년 1월, Yahoo는 C++와 Perl로 작성된 편집기의 새 버전을 출시했습니다. 그러나 이 프로그램을 C++로 변환하기 위해 말 그대로 Lisp 인터프리터를 작성해야 했기 때문에, 프로그램이 더 이상 Lisp로 작성되지 않았는지 여부는 말하기 어렵습니다. 제가 알기로는 모든 페이지 생성 템플릿의 소스 파일은 여전히 Lisp 코드입니다. (Greenspun의 열 번째 규칙 참조.)

[^2]: 로버트 모리스는 제가 비밀로 할 필요가 없었다고 말합니다. 왜냐하면 경쟁자들이 우리가 Lisp를 사용하고 있다는 것을 알았더라도 왜 사용하는지는 이해하지 못했을 것이기 때문입니다. "만약 그들이 그렇게 똑똑했다면 이미 Lisp로 프로그래밍하고 있었을 것입니다."

[^3]: 모든 언어는 튜링 동등(Turing equivalent)이라는 점에서 동등하게 강력하지만, 이것은 프로그래머들이 신경 쓰는 단어의 의미가 아닙니다. (아무도 튜링 기계를 프로그래밍하고 싶어하지 않습니다.) 프로그래머들이 신경 쓰는 힘의 종류는 형식적으로 정의하기 어려울 수 있지만, 한 가지 설명 방식은 더 강력한 언어를 위해 더 강력한 언어의 인터프리터를 작성하여 얻을 수 있는 기능만을 갖춘 것이라고 말하는 것입니다. 만약 언어 A에 문자열에서 공백을 제거하는 연산자가 있고 언어 B에는 없다면, 그것이 A를 더 강력하게 만들지는 않을 것입니다. 왜냐하면 B에서는 그것을 수행하는 서브루틴을 작성할 수 있기 때문입니다. 하지만 만약 A가 예를 들어 재귀를 지원하고 B가 지원하지 않는다면, 그것은 라이브러리 함수를 작성하여 해결할 수 있는 것이 아닐 것입니다.

[^4]: 괴짜들을 위한 참고: 또는 격자일 수도 있습니다. 위쪽으로 좁아지는 격자일 수도 있습니다. 여기서 중요한 것은 모양이 아니라 최소한 부분 순서가 있다는 아이디어입니다.

[^5]: 매크로를 별도의 기능으로 취급하는 것은 약간 오해의 소지가 있습니다. 실제로는 렉시컬 클로저와 나머지 매개변수와 같은 다른 Lisp 기능에 의해 그 유용성이 크게 향상됩니다.

[^6]: 그 결과, 프로그래밍 언어 비교는 종교 전쟁의 형태를 띠거나, 너무나 중립적이어서 사실상 인류학적 작품인 학부 교과서의 형태를 띕니다. 평화를 소중히 여기거나 종신 재직을 원하는 사람들은 이 주제를 피합니다. 하지만 이 질문은 절반만 종교적인 문제입니다. 특히 새로운 언어를 설계하고 싶다면 연구할 가치가 있는 무언가가 있습니다.