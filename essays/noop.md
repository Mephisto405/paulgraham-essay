# 왜 Arc가 특별히 객체 지향적이지 않은가 (Why Arc Isn't Especially Object-Oriented)

2002년 10월

## 객체 지향 프로그래밍 (Object-Oriented Programming)

요즘 객체 지향 프로그래밍(Object-Oriented Programming, OOP)에 대한 일종의 열풍이 불고 있습니다만, 제가 아는 가장 똑똑한 프로그래머들 중 일부는 이에 대해 별로 흥미를 느끼지 못하고 있습니다. 저 또한 객체 지향 프로그래밍이 어떤 경우에는 유용한 기법이라고 생각하지만, 작성하는 모든 프로그램을 객체 지향 방식으로 표현해야만 하는 것은 아니라고 봅니다. 새로운 타입을 정의할 수는 있어야 하지만, 모든 프로그램을 새로운 타입의 정의로만 표현해야 할 필요는 없습니다.

사람들이 객체 지향 프로그래밍을 좋아하는 데에는 다섯 가지 이유가 있다고 생각하는데, 그중 세 개 반은 잘못된 이유입니다.

객체 지향 프로그래밍은 정적 타입 언어(statically-typed language)를 사용하면서 어휘적 클로저(lexical closures)나 매크로(macros)가 없는 경우 흥미롭게 느껴질 수 있습니다. 어떤 면에서는 이러한 제약 사항을 우회할 방법을 제공하기 때문입니다. (Greenspun의 열 번째 규칙[^1]을 참조하세요.)

객체 지향 프로그래밍은 대기업에서 인기가 있습니다. 이는 대기업의 소프트웨어 개발 방식에 부합하기 때문입니다. 대기업에서는 소프트웨어가 대규모(그리고 자주 바뀌는)의 평범한 프로그래머들로 구성된 팀에 의해 작성되는 경향이 있습니다. 객체 지향 프로그래밍은 이러한 프로그래머들에게 규율을 강제하여, 개별 프로그래머가 너무 큰 손상을 입히는 것을 방지합니다. 그 대가로 결과물인 코드는 프로토콜(protocols)로 인해 비대해지고 중복으로 가득 차게 됩니다. 대기업에게는 이것이 그리 높은 대가는 아닙니다. 어차피 그들의 소프트웨어는 비대하고 중복으로 가득 찰 가능성이 높기 때문입니다.

객체 지향 프로그래밍은 많은 '일처럼 보이는 것'을 생성합니다. 과거 연속 용지(fanfold) 시절에는, 페이지당 코드를 다섯 줄이나 열 줄만 작성하고 그 앞에 20줄의 정교하게 형식화된 주석을 붙이던 프로그래머 유형이 있었습니다. 객체 지향 프로그래밍은 이런 사람들에게는 마약과도 같습니다. 이런 방식은 비계(scaffolding)[^2] 전체를 소스 코드 안으로 끌어들일 수 있게 해주기 때문입니다. Lisp 해커(Lisp hacker)라면 리스트(list)에 기호(symbol)를 하나 푸시하는 것으로 처리했을 법한 일을, 객체 지향 프로그래밍에서는 클래스(class)와 메소드(method) 전체 파일로 만들어 버립니다. 따라서 자신이 많은 일을 하고 있다고 스스로나 다른 사람을 설득하고 싶을 때 좋은 도구가 될 수 있습니다.

만약 언어 자체가 객체 지향 프로그램이라면, 사용자들이 이를 확장할 수 있습니다. 뭐, 그럴 수도 있겠지요. 혹은 객체 지향 프로그래밍의 하위 개념들을 필요에 따라 선택적으로 제공하는 것이 더 나을 수도 있습니다. 예를 들어, 오버로딩(Overloading)은 본질적으로 클래스와 묶여 있지 않습니다. 지켜봐야 알겠지요.

객체 지향 추상화는 시뮬레이션(simulations)이나 CAD 시스템(CAD systems)과 같은 특정 종류의 프로그램 도메인에 깔끔하게 매핑됩니다.

개인적으로는 객체 지향 추상화가 필요했던 적은 없습니다. Common Lisp에는 매우 강력한 객체 시스템(object system)이 있지만, 저는 단 한 번도 사용해 본 적이 없습니다. 저는 (클로저(closures)로 가득 찬 해시 테이블(hash tables)을 만드는 것 등)[^3] '기능이 제한적인 언어(wimpier languages)'[^4]에서는 객체 지향 기법이 필요했을 법한 일들을 많이 해봤지만, CLOS[^5]를 사용해야 했던 적은 없었습니다.

어쩌면 제가 멍청하거나, 혹은 제한된 범위의 애플리케이션만 다뤄왔을 수도 있습니다. 자신의 프로그래밍 경험에 기반하여 언어를 설계하는 데에는 위험이 따릅니다. 하지만 좋다고 여겨지는 아이디어라는 이유만으로, 정작 자신은 한 번도 필요하지 않았던 기능들을 언어에 넣는 것은 더 위험해 보입니다.

[^1]: Greenspun의 열 번째 규칙은 "Lisp에서 모든 것은 매크로다"라는 격언을 언급하며, Lisp의 강력한 매크로 기능이 복잡한 추상화도 쉽게 구현하게 해준다는 맥락에서 사용될 수 있습니다. OOP가 이러한 Lisp의 기능을 일부 대체하려는 시도로 볼 수 있다는 의미로 해석될 수 있습니다.
[^2]: 여기서 '비계(scaffolding)'는 건축에서 임시로 설치하는 지지 구조물을 의미하는 말로, OOP의 클래스, 메소드, 상속 등의 구조가 실제 코드 구현에 필요한 핵심 로직 외에 추가되는 부가적인 틀이나 구조를 비유적으로 나타내는 데 사용되었습니다.
[^3]: Common Lisp에서는 함수(클로저)를 해시 테이블의 값으로 저장하는 것이 일반적이며, 이는 다른 언어에서는 객체 지향 기법(예: 메소드를 가진 객체를 값으로 저장)이 필요할 수 있는 작업임을 시사합니다.
[^4]: 'Wimpier languages'는 여기서 객체 지향 프로그래밍이 필요하다고 여겨지는, 상대적으로 기능이 제한적이거나 표현력이 부족한 언어들을 지칭하는 Paul Graham의 비유적인 표현입니다.
[^5]: CLOS는 Common Lisp Object System의 약자로, Common Lisp에서 사용되는 강력한 객체 지향 시스템입니다.