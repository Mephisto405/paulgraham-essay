# Arc가 특별히 객체 지향적이지 않은 이유 (Why Arc Isn't Especially Object-Oriented)

요즘 객체 지향 프로그래밍(Object-Oriented Programming, OOP)에 대한 일종의 열풍이 불고 있지만, 제가 아는 가장 똑똑한 프로그래머들 중 일부는 OOP에 대해 가장 흥미를 느끼지 못하고 있습니다.

제 개인적인 생각으로는 객체 지향 프로그래밍은 어떤 경우에는 유용한 기술이지만, 모든 프로그램에 스며들 필요는 없다고 봅니다. 새로운 타입을 정의할 수 있어야 하지만, 모든 프로그램을 새로운 타입의 정의로 표현할 필요는 없다는 말입니다.

사람들이 객체 지향 프로그래밍을 좋아하는 데는 다섯 가지 이유가 있다고 생각하며, 그 중 세 개 반은 잘못된 이유입니다.

객체 지향 프로그래밍은 렉시컬 클로저(lexical closures)나 매크로(macros)가 없는 정적 타입 언어(statically-typed language)를 사용한다면 흥미롭습니다. 어느 정도는 이러한 제약 사항을 우회하는 방법을 제공합니다. (그린스푼의 10번째 규칙[1] 참조).

객체 지향 프로그래밍은 대기업에서 인기가 많습니다. 소프트웨어를 개발하는 방식에 적합하기 때문입니다. 대기업에서는 소프트웨어가 대규모(그리고 자주 바뀌는) 보통 수준의(mediocre) 프로그래머들로 구성된 팀에 의해 작성되는 경향이 있습니다. 객체 지향 프로그래밍은 이 프로그래머들에게 규율을 부과하여 어느 누구도 너무 큰 피해를 입히지 않도록 합니다. 그 대가는 결과 코드가 프로토콜(protocols)로 부풀려지고 중복이 가득하다는 것입니다. 이는 대기업에게는 그리 비싼 대가가 아닙니다. 어차피 그들의 소프트웨어는 부풀려지고 중복으로 가득할 가능성이 높기 때문입니다.

객체 지향 프로그래밍은 많은 양의 '일'처럼 보이는 것을 생성합니다. 예전에 연속 용지(fanfold)를 사용하던 시절에는 페이지당 5~10줄의 코드만 작성하고 그 앞에 20줄의 정교하게 형식화된 주석을 붙이는 프로그래머 유형이 있었습니다. 객체 지향 프로그래밍은 이런 사람들에게 '마약'과 같습니다. 이 모든 스캐폴딩(scaffolding)을 소스 코드 안에 직접 포함시킬 수 있게 해주기 때문입니다. 리스프(Lisp) 해커라면 심볼을 리스트에 푸시하는 것으로 처리할 일을 객체 지향 프로그래밍에서는 전체 클래스와 메서드 파일로 만듭니다. 따라서 자신이 많은 일을 하고 있다고 스스로에게 또는 다른 사람에게 확신시키고 싶다면 좋은 도구입니다.

언어 자체가 객체 지향 프로그램이라면 사용자에게 확장될 수 있습니다. 글쎄요, 그럴 수도 있고 아닐 수도 있습니다. 아니면 객체 지향 프로그래밍의 하위 개념을 '단품으로(a la carte)' 제공함으로써 훨씬 더 나은 결과를 얻을 수도 있습니다. 예를 들어, 오버로딩(Overloading)은 본질적으로 클래스에 묶여 있지 않습니다. 두고 볼 일입니다.

객체 지향 추상화는 시뮬레이션이나 CAD 시스템과 같은 특정 유형 프로그램의 도메인(domains)에 깔끔하게 매핑됩니다.

저는 개인적으로 객체 지향 추상화가 필요했던 적이 없습니다. 커먼 리스프(Common Lisp)에는 엄청나게 강력한 객체 시스템이 있지만, 저는 단 한 번도 사용해 본 적이 없습니다. 더 취약한 언어에서는 객체 지향 기술이 필요했을 많은 일들(예: 클로저로 가득 찬 해시 테이블 만들기)을 했지만, CLOS[2]를 사용해야 했던 적은 한 번도 없었습니다.

어쩌면 제가 어리석거나, 제한된 범위의 애플리케이션만 작업해 본 것일 수도 있습니다. 프로그래밍에 대한 자신의 경험을 바탕으로 언어를 설계하는 데는 위험이 따릅니다. 하지만 한 번도 필요하지 않았던 것을 좋은 아이디어라고 생각하여 포함시키는 것이 더 위험해 보입니다.

---

[1] 그린스푼의 10번째 규칙 (Greenspun's Tenth Rule): "충분히 복잡한 모든 C 또는 포트란 프로그램은 느리거나 버그가 있는, 애드혹하게 지정된 Common Lisp의 구현을 포함한다." (Any sufficiently complicated C or Fortran program contains an ad hoc, informally-specified, bug-ridden, slow implementation of half of Common Lisp.)
[2] CLOS: Common Lisp Object System의 약자로, 커먼 리스프의 표준 객체 시스템입니다.