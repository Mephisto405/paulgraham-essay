# 해커와 화가 (Hackers and Painters)

2003년 5월
(이 에세이는 하버드 대학교에서 진행한 초청 강연을 바탕으로 작성되었으며, 이전에 노스이스턴 대학교에서 진행한 강연 내용을 포함하고 있습니다.)

제가 컴퓨터 과학 대학원 과정을 마치고 미술 학교에 가서 회화를 공부했을 때, 많은 사람들이 컴퓨터에 관심 있는 사람이 그림에도 관심이 있다는 사실에 놀라는 듯했습니다. 그들은 해킹과 회화가 매우 다른 종류의 일이라고 생각하는 것 같았습니다. 해킹은 차갑고, 정확하며, 체계적인 반면, 회화는 원시적인 충동의 광란적인 표현이라고 말이죠.

하지만 이 두 가지 이미지는 모두 틀렸습니다. 해킹과 회화는 공통점이 많습니다. 사실, 제가 아는 여러 유형의 사람들 중 해커와 화가가 가장 비슷하다고 할 수 있습니다.

해커와 화가의 공통점은 둘 다 ‘만드는 사람(makers)’이라는 것입니다. 작곡가, 건축가, 작가와 마찬가지로, 해커와 화가는 좋은 것을 만들려고 노력합니다. 그들은 그 자체로 연구를 하는 것은 아니지만, 좋은 것을 만들다가 새로운 기술을 발견하게 된다면 더할 나위 없이 좋겠죠.

저는 "컴퓨터 과학(computer science)"이라는 용어를 한 번도 좋아한 적이 없습니다. 가장 큰 이유는 그런 것이 없기 때문입니다. 컴퓨터 과학은 마치 유고슬라비아처럼 역사의 우연으로 인해 느슨하게 관련된 분야들이 뒤섞여 있는 잡동사니 같은 것입니다.

한쪽 끝에는 실제로 수학자이지만 DARPA 보조금을 받기 위해 자신이 하는 일을 컴퓨터 과학이라고 부르는 사람들이 있습니다. 중간에는 네트워크를 통해 데이터를 라우팅하는 알고리즘의 동작을 연구하는 등 컴퓨터의 자연사 같은 것을 연구하는 사람들이 있습니다. 그리고 다른 극단에는 흥미로운 소프트웨어를 작성하려고 노력하는 해커들이 있습니다. 이들에게 컴퓨터는 건축가에게 콘크리트나 화가에게 물감처럼 표현의 매개체일 뿐입니다. 마치 수학자, 물리학자, 건축가가 모두 같은 학과에 있어야 하는 것과 같습니다.

때때로 해커들이 하는 일을 "소프트웨어 공학(software engineering)"이라고 부르기도 하지만, 이 용어 역시 마찬가지로 오해의 소지가 있습니다. 훌륭한 소프트웨어 디자이너는 건축가와 마찬가지로 공학자가 아닙니다. 건축과 공학의 경계는 명확하게 정의되어 있지 않지만, 분명히 존재합니다. 그 경계는 무엇(what)과 어떻게(how) 사이에 있습니다. 건축가는 무엇을 할지 결정하고, 공학자는 그것을 어떻게 할지 파악합니다.

무엇과 어떻게를 너무 분리해서는 안 됩니다. 어떻게 할지 이해하지 않고 무엇을 할지 결정하려고 한다면 문제에 봉착할 것입니다. 하지만 해킹은 단순히 어떤 사양(spec)을 어떻게 구현할지 결정하는 것 이상일 수 있습니다. 최고 수준의 해킹은 사양을 만들어내는 것입니다. 물론 가장 좋은 방법은 그것을 구현하는 것이죠.

아마 언젠가 "컴퓨터 과학"은 유고슬라비아처럼 구성 요소로 분해될 것입니다. 그것은 좋은 일이 될 수도 있습니다. 특히 저의 고향인 해킹에게 독립을 의미한다면 더욱 말이죠.

이 모든 다른 유형의 작업을 하나의 학과에 묶는 것은 행정적으로 편리할 수 있지만, 지적으로는 혼란스럽습니다. 이것이 제가 "컴퓨터 과학"이라는 이름을 좋아하지 않는 또 다른 이유입니다. 논쟁의 여지는 있지만 중간에 있는 사람들은 실험 과학과 비슷한 일을 하고 있습니다. 하지만 양쪽 끝에 있는 사람들, 즉 해커와 수학자들은 실제로는 과학을 하는 것이 아닙니다.

수학자들은 이에 대해 별로 개의치 않는 듯합니다. 그들은 수학과에 있는 다른 수학자들처럼 행복하게 정리를 증명하는 일을 시작하고, 아마도 곧 그들이 일하는 건물의 외부에 '컴퓨터 과학'이라고 쓰여 있다는 사실을 알아채지 못하게 될 것입니다. 하지만 해커들에게 이 명칭은 문제입니다. 그들이 하는 일이 과학이라고 불리면, 그들은 과학적으로 행동해야 한다고 느끼기 때문입니다.

그래서 그들이 정말 하고 싶은 일, 즉 아름다운 소프트웨어를 설계하는 대신, 대학과 연구소의 해커들은 연구 논문을 작성해야 한다고 느낍니다. 최상의 경우, 논문은 형식적인 것에 불과합니다. 해커는 멋진 소프트웨어를 만들고, 그에 대한 논문을 작성하며, 논문은 소프트웨어가 나타내는 성과를 대변하는 대리인이 됩니다.

하지만 종종 이러한 불일치는 문제를 야기합니다. 아름다운 것을 만드는 것에서 벗어나 연구 논문의 더 적합한 주제가 되는 못생긴 것을 만드는 쪽으로 쉽게 흘러갈 수 있습니다. 불행히도 아름다운 것들이 항상 논문의 최고의 주제가 되는 것은 아닙니다.

첫째, 연구는 독창적이어야 합니다. 박사 학위 논문을 써본 사람이라면 누구나 알겠지만, 처녀지를 탐험하고 있다는 것을 확실히 하는 방법은 아무도 원하지 않는 땅을 점유하는 것입니다. 둘째, 연구는 실질적이어야 합니다. 그리고 어설픈 시스템은 더 많은 내용을 담은 논문을 만들어냅니다. 왜냐하면 일을 완수하기 위해 극복해야 할 장애물에 대해 쓸 수 있기 때문입니다. 잘못된 가정에서 시작하는 것만큼 많은 문제를 만들어내는 것은 없습니다. AI의 대부분이 이 규칙의 예시입니다. 지식을 추상적인 개념을 나타내는 인수가 있는 술어 논리 표현식의 목록으로 표현할 수 있다고 가정하면, 이것을 작동하게 만드는 방법에 대해 쓸 논문이 많아질 것입니다. 리키 리카르도(Ricky Ricardo)가 "루시, 할 말이 많아"라고 말했던 것처럼 말이죠.

아름다운 것을 만드는 방법은 종종 이미 존재하는 것에 미묘한 조정을 가하거나, 기존 아이디어를 약간 새로운 방식으로 결합하는 것입니다. 이런 종류의 작업은 연구 논문에서 전달하기 어렵습니다.

그렇다면 왜 대학과 연구소는 계속해서 출판물로 해커를 평가할까요? "학업 적성"이 단순한 표준화된 시험으로 측정되거나, 프로그래머의 생산성이 코드 줄 수로 측정되는 것과 같은 이유입니다. 이러한 테스트는 적용하기 쉽고, 어느 정도 작동하는 쉬운 테스트만큼 유혹적인 것은 없습니다.

해커가 실제로 하려는 일, 즉 아름다운 소프트웨어를 설계하는 것을 측정하는 것은 훨씬 더 어려울 것입니다. 좋은 디자인을 판단하려면 좋은 디자인 감각이 필요합니다. 그리고 좋은 디자인을 인식하는 사람들의 능력과 그들이 할 수 있다는 자신감 사이에는 어떠한 상관관계도, 어쩌면 부정적인 상관관계만 있을 뿐입니다.

유일한 외부 시험은 시간입니다. 시간이 흐르면서 아름다운 것들은 번성하고, 못생긴 것들은 버려지는 경향이 있습니다. 불행히도 관련된 시간은 인간의 수명보다 길 수 있습니다. 사무엘 존슨(Samuel Johnson)은 작가의 명성이 수렴하는 데 100년이 걸린다고 말했습니다. 작가의 영향력 있는 친구들이 죽고, 그들의 모든 추종자들이 죽기를 기다려야 합니다.

해커들은 자신의 명성에 큰 무작위적 요소가 있음을 체념해야 한다고 생각합니다. 이 점에서 그들은 다른 창작자들과 다르지 않습니다. 사실, 그들은 상대적으로 운이 좋습니다. 해킹에서 유행의 영향력은 회화만큼 크지 않습니다.

자신의 작품을 사람들이 오해하는 것보다 더 나쁜 것이 있습니다. 더 나쁜 위험은 스스로 자신의 작품을 오해하는 것입니다. 아이디어를 찾으러 가는 곳은 관련 분야입니다. 만약 자신이 컴퓨터 과학 학과에 있다면, 예를 들어 해킹이 이론 컴퓨터 과학의 이론에 대한 응용 버전이라고 믿으려는 자연스러운 유혹이 있습니다. 대학원 내내 저는 더 많은 이론을 알아야 한다는 불편한 느낌을 마음 한편에 가지고 있었고, 기말고사 후 3주 안에 그 모든 것을 잊어버린 것이 매우 부주의했다고 생각했습니다.

이제 저는 제가 착각했음을 깨달았습니다. 해커는 화가가 물감 화학을 이해해야 하는 것만큼 계산 이론을 이해해야 합니다. 시간 및 공간 복잡성과 튜링 완전성(Turing completeness)에 대해 알아야 합니다. 파서(parser)나 정규 표현식 라이브러리를 작성해야 할 경우 최소한 상태 기계(state machine)의 개념이라도 기억해두는 것이 좋습니다. 사실 화가들은 물감 화학에 대해 그보다 훨씬 더 많은 것을 기억해야 합니다.

제가 발견한 최고의 아이디어 원천은 이름에 "컴퓨터"라는 단어가 들어간 다른 분야가 아니라, 만드는 사람들이 거주하는 다른 분야들이었습니다. 회화는 계산 이론보다 훨씬 더 풍부한 아이디어 원천이었습니다.

예를 들어, 저는 대학에서 컴퓨터 근처에도 가기 전에 프로그램을 종이에 완벽하게 구상해야 한다고 배웠습니다. 저는 그렇게 프로그래밍하지 않았습니다. 저는 종이 대신 컴퓨터 앞에 앉아서 프로그래밍하는 것을 좋아한다는 것을 알았습니다. 더 나쁜 것은, 인내심을 가지고 완전한 프로그램을 작성하고 그것이 올바르다는 것을 확인하는 대신, 저는 절망적으로 망가진 코드를 마구 쏟아내고 점차 고쳐나가는 경향이 있었습니다. 디버깅(debugging)은 오타나 누락을 잡아내는 일종의 최종 검사라고 배웠습니다. 제가 일하는 방식에서는 프로그래밍 자체가 디버깅으로 이루어진 것 같았습니다.

오랫동안 저는 이것에 대해 죄책감을 느꼈습니다. 마치 초등학교 때 연필을 잡는 법을 배운 대로 잡지 못해서 죄책감을 느꼈던 것처럼 말이죠. 다른 창작자들, 즉 화가나 건축가들을 둘러봤다면 제가 하고 있던 일에 스케치(sketching)라는 이름이 있다는 것을 알았을 것입니다. 제가 알기로는 대학에서 저에게 가르친 프로그래밍 방식은 완전히 잘못되었습니다. 작가, 화가, 건축가가 하는 것처럼 프로그램을 작성하면서 구상해야 합니다.

이것을 깨닫는 것은 소프트웨어 설계에 실제적인 의미를 가집니다. 즉, 프로그래밍 언어는 무엇보다도 유연해야 합니다. 프로그래밍 언어는 이미 구상한 프로그램을 표현하기 위한 것이 아니라, 프로그램을 생각하기 위한 것입니다. 그것은 펜이 아니라 연필이어야 합니다. 사람들이 대학에서 저에게 가르친 대로 프로그램을 작성한다면 정적 타입(static typing)은 좋은 아이디어가 될 것입니다. 하지만 제가 아는 해커 중 누구도 그렇게 프로그램을 작성하지 않습니다. 우리는 휘갈겨 쓰고, 번지고, 뭉개트릴 수 있는 언어가 필요합니다. 무릎에 찻잔을 조심스럽게 올려놓고 엄격한 옛날 컴파일러 아주머니와 점잖게 대화해야 하는 언어가 아니라 말이죠.

정적 타입에 대해 이야기하는 김에, 창작자들과 자신을 동일시하는 것은 과학 분야를 괴롭히는 또 다른 문제, 즉 수학 부러움(math envy)으로부터 우리를 구할 것입니다. 과학 분야의 모든 사람들은 수학자들이 자신들보다 똑똑하다고 은밀히 믿습니다. 수학자들도 그렇게 믿는다고 생각합니다. 어쨌든 그 결과 과학자들은 자신의 작업을 가능한 한 수학적으로 보이게 만드는 경향이 있습니다. 물리학과 같은 분야에서는 이것이 큰 해를 끼치지 않을 수 있지만, 자연 과학에서 멀어질수록 문제가 됩니다.

수식으로 가득 찬 페이지는 정말 인상적으로 보입니다. (팁: 더 인상적으로 보이려면 그리스어 변수를 사용하세요.) 그래서 형식적으로 다룰 수 있는 문제에 집중하고 싶은 유혹이 큽니다. 예를 들어, 중요한 문제가 아닌 것에 말이죠.

만약 해커들이 작가나 화가와 같은 다른 창작자들과 자신을 동일시한다면, 이런 유혹을 느끼지 않을 것입니다. 작가와 화가는 수학 부러움에 시달리지 않습니다. 그들은 자신들이 완전히 관련 없는 일을 하고 있다고 느낍니다. 해커도 마찬가지라고 생각합니다.

만약 대학과 연구소가 해커들이 원하는 종류의 일을 하지 못하게 한다면, 아마도 그들에게 적합한 곳은 회사일 것입니다. 불행히도 대부분의 회사도 해커들이 원하는 것을 하지 못하게 합니다. 대학과 연구소는 해커를 과학자로 만들고, 회사는 해커를 엔지니어로 만듭니다.

저 자신도 최근에야 이 사실을 깨달았습니다. 야후(Yahoo)가 비아웹(Viaweb)을 인수했을 때, 그들은 제가 무엇을 하고 싶은지 물었습니다. 저는 사업 측면을 별로 좋아하지 않았기 때문에, 그냥 해킹하고 싶다고 말했습니다. 야후에 가서 제가 알게 된 것은 그들이 생각하는 해킹은 소프트웨어를 설계하는 것이 아니라 구현하는 것이었습니다. 프로그래머는 제품 관리자들의 비전(그것이 적절한 단어라면)을 코드로 번역하는 기술자로 여겨졌습니다.

이것이 대기업의 기본 계획인 것 같습니다. 그들이 이렇게 하는 이유는 결과의 표준 편차를 줄이기 위함입니다. 해커 중 극소수만이 실제로 소프트웨어를 설계할 수 있으며, 회사를 운영하는 사람들은 이들을 가려내기가 어렵습니다. 그래서 대부분의 회사는 소프트웨어의 미래를 한 명의 뛰어난 해커에게 맡기는 대신, 위원회가 설계하고 해커는 단순히 설계를 구현하도록 시스템을 설정합니다.

언젠가 돈을 벌고 싶다면 이것을 기억하세요. 왜냐하면 이것이 스타트업이 승리하는 이유 중 하나이기 때문입니다. 대기업은 재앙을 피하기 위해 디자인 결과의 표준 편차를 줄이기를 원합니다. 하지만 진동을 억제하면 낮은 점수뿐만 아니라 높은 점수도 잃게 됩니다. 이것은 대기업에게 문제가 되지 않습니다. 왜냐하면 그들은 훌륭한 제품을 만들어서 이기는 것이 아니기 때문입니다. 대기업은 다른 대기업보다 덜 형편없어서 이기는 것입니다.

그러므로 소프트웨어가 제품 관리자에 의해 설계되는 거대 기업과 디자인 전쟁을 벌일 방법을 찾을 수 있다면, 그들은 당신을 따라올 수 없을 것입니다. 그러나 이러한 기회는 찾기 쉽지 않습니다. 거대 기업과 디자인 전쟁을 벌이는 것은 어렵습니다. 마치 성 안에 있는 상대와 백병전을 벌이는 것이 어려운 것처럼 말이죠. 예를 들어, 마이크로소프트 워드(Microsoft Word)보다 더 나은 워드 프로세서를 만드는 것은 꽤 쉬울 것이지만, 마이크로소프트는 운영체제 독점이라는 성 안에 있어서 당신이 그렇게 하더라도 아마 알아채지 못할 것입니다.

디자인 전쟁을 벌일 장소는 아무도 아직 요새를 구축하지 못한 새로운 시장입니다. 그곳에서 과감한 디자인 접근 방식을 취하고, 동일한 사람들이 제품을 설계하고 구현함으로써 크게 승리할 수 있습니다. 마이크로소프트 자신도 초창기에는 이렇게 했습니다. 애플(Apple)도 그랬습니다. 그리고 휴렛팩커드(Hewlett-Packard)도 마찬가지입니다. 거의 모든 성공적인 스타트업이 그랬을 것이라고 생각합니다.

그러므로 훌륭한 소프트웨어를 만드는 한 가지 방법은 자신만의 스타트업을 시작하는 것입니다. 하지만 여기에는 두 가지 문제가 있습니다. 하나는 스타트업에서는 소프트웨어 작성 외에도 해야 할 일이 너무 많다는 것입니다. 비아웹에 있을 때, 저는 전체 시간의 4분의 1이라도 해킹할 수 있으면 운이 좋다고 생각했습니다. 그리고 나머지 4분의 3 동안 해야 했던 일들은 지루한 것부터 끔찍한 것까지 다양했습니다. 저에게는 이에 대한 기준점이 있습니다. 한 번은 이사회 회의를 나와 충치 치료를 받아야 했던 적이 있기 때문입니다. 저는 치과 의자(dentist's chair)에 앉아 드릴 소리를 기다리면서 마치 휴가 온 것 같은 기분을 느꼈던 것을 기억합니다.

스타트업의 또 다른 문제는 돈이 되는 소프트웨어와 작성하기 흥미로운 소프트웨어 사이의 공통점이 많지 않다는 것입니다. 프로그래밍 언어는 작성하기 흥미롭고, 마이크로소프트의 첫 번째 제품도 사실 프로그래밍 언어였지만, 지금은 아무도 프로그래밍 언어에 돈을 지불하지 않습니다. 돈을 벌고 싶다면, 아무도 공짜로 해결하고 싶어 하지 않는 너무나 불쾌한 문제들을 다루도록 강요받는 경향이 있습니다.

모든 창작자들은 이 문제에 직면합니다. 가격은 공급과 수요에 의해 결정되는데, 작업하기 재미있는 것에 대한 수요는 개인 고객의 일상적인 문제를 해결하는 것에 대한 수요만큼 많지 않습니다. 오프 브로드웨이 연극에 출연하는 것은 누군가의 전시 부스에서 고릴라 복장을 입는 것만큼 돈을 벌지 못합니다. 소설을 쓰는 것은 음식물 처리기 광고 문구를 쓰는 것만큼 돈이 되지 않습니다. 그리고 프로그래밍 언어를 해킹하는 것은 어떤 회사의 레거시 데이터베이스(legacy database)를 웹 서버에 연결하는 방법을 알아내는 것만큼 돈이 되지 않습니다.

이 문제에 대한 해결책은 소프트웨어의 경우, 거의 모든 창작자들이 아는 개념인 '낮잡이(day job)'라고 생각합니다. 이 용어는 밤에 공연하는 음악가들로부터 시작되었습니다. 더 일반적으로 말하면, 돈을 벌기 위해 하는 일과 사랑 때문에 하는 일이 따로 있다는 뜻입니다.

거의 모든 창작자들은 경력 초기에 낮잡이를 가지고 있습니다. 화가와 작가는 특히 그렇습니다. 운이 좋다면 자신의 본업과 밀접하게 관련된 낮잡이를 구할 수 있습니다. 음악가들은 종종 레코드 가게에서 일하는 것 같습니다. 어떤 프로그래밍 언어나 운영체제에서 작업하는 해커도 마찬가지로 그것을 사용하는 낮잡이를 구할 수 있을 것입니다. [1]

해커들이 낮잡이를 갖고 아름다운 소프트웨어는 부업으로 개발해야 한다고 말할 때, 저는 이것을 새로운 아이디어로 제안하는 것이 아닙니다. 이것이 바로 오픈소스 해킹의 전부입니다. 제가 말하는 것은 오픈소스가 아마도 올바른 모델일 것이라는 점입니다. 왜냐하면 다른 모든 창작자들에 의해 독립적으로 확인되었기 때문입니다.

어떤 고용주라도 해커들이 오픈소스 프로젝트에서 작업하는 것을 꺼린다는 사실은 저에게 놀랍게 느껴집니다. 비아웹에서는 그렇게 하지 않는 사람은 고용하기를 꺼렸을 것입니다. 프로그래머를 면접할 때, 우리가 가장 중요하게 생각했던 것은 그들이 여가 시간에 어떤 종류의 소프트웨어를 작성했느냐였습니다.

정말로 사랑하지 않으면 어떤 것도 잘할 수 없습니다. 그리고 해킹을 사랑한다면 필연적으로 자신만의 프로젝트에서 작업하게 될 것입니다. [2]

해커는 과학자가 아니라 창작자이기 때문에, 은유를 찾을 올바른 곳은 과학 분야가 아니라 다른 종류의 창작자들 사이입니다. 회화는 해킹에 대해 또 무엇을 가르쳐줄 수 있을까요?

우리가 회화의 예시에서 배울 수 있는, 또는 적어도 확인할 수 있는 한 가지는 해킹을 배우는 방법입니다. 회화는 주로 직접 해봄으로써 배웁니다. 해킹도 마찬가지입니다. 대부분의 해커는 대학에서 프로그래밍 강의를 수강하여 해킹을 배우지 않습니다. 그들은 13세에 자신만의 프로그램을 작성하면서 해킹을 배웁니다. 대학 수업에서도 해킹은 주로 직접 해봄으로써 배웁니다. [3]

화가들은 자신의 작업 흔적을 남기기 때문에, 그들이 직접 해보면서 배우는 것을 볼 수 있습니다. 화가의 작품을 연대순으로 보면, 각 그림이 이전 그림에서 배운 것을 바탕으로 만들어졌다는 것을 알 수 있습니다. 그림에서 매우 잘 작동하는 부분이 있다면, 대개 이전 그림에서 더 작은 형태로 버전 1을 찾을 수 있습니다.

대부분의 창작자들이 이런 식으로 작업한다고 생각합니다. 작가와 건축가도 마찬가지인 것 같습니다. 아마 해커들이 화가처럼 행동하여 하나의 프로젝트에서 몇 년 동안 계속 작업하고 나중에 떠오른 모든 아이디어를 수정으로 통합하려고 하기보다는, 정기적으로 처음부터 다시 시작하는 것이 좋을 것입니다.

해커들이 직접 해보면서 해킹을 배운다는 사실은 해킹이 과학과 얼마나 다른지를 보여주는 또 다른 증거입니다. 과학자들은 직접 과학을 하는 것이 아니라 실험실 실습과 문제 풀이를 통해 과학을 배웁니다. 과학자들은 처음에는 완벽한 작업을 수행합니다. 즉, 다른 사람이 이미 해 놓은 작업을 재현하려고 노력할 뿐입니다. 결국 그들은 독창적인 작업을 할 수 있는 단계에 이릅니다. 반면에 해커들은 처음부터 독창적인 작업을 합니다. 단지 그것이 매우 나쁠 뿐입니다. 그래서 해커들은 독창적으로 시작하여 잘하게 되고, 과학자들은 잘하게 시작하여 독창적이 됩니다.

창작자들이 배우는 또 다른 방법은 예시를 통해서입니다. 화가에게 박물관은 기술의 참고 도서관입니다. 수백 년 동안 위대한 거장들의 작품을 모사하는 것은 화가들의 전통적인 교육의 일부였습니다. 모사는 그림이 어떻게 만들어졌는지 면밀히 살펴보게 만들기 때문입니다. 작가들도 마찬가지로 이것을 합니다. 벤자민 프랭클린(Benjamin Franklin)은 애디슨(Addison)과 스틸(Steele)의 에세이에서 요점을 요약하고 그것을 재현하려고 노력하면서 글쓰기를 배웠습니다. 레이먼드 챈들러(Raymond Chandler)도 탐정 소설로 같은 일을 했습니다.

해커도 마찬가지로 좋은 프로그램을 보면서 프로그래밍을 배울 수 있습니다. 그들이 무엇을 하는지뿐만 아니라 소스 코드도 말이죠. 오픈소스 운동의 덜 알려진 이점 중 하나는 프로그래밍을 배우기가 더 쉬워졌다는 것입니다. 제가 프로그래밍을 배울 때, 우리는 주로 책에 있는 예시에 의존해야 했습니다. 당시 사용할 수 있었던 큰 코드 덩어리는 유닉스(Unix)였지만, 이것조차 오픈소스는 아니었습니다. 소스 코드를 읽은 대부분의 사람들은 존 라이온스(John Lions)의 책을 불법 복사한 것을 읽었습니다. 이 책은 1977년에 작성되었지만 1996년까지 출판이 허용되지 않았습니다.

회화에서 얻을 수 있는 또 다른 예시는 그림이 점진적인 개선을 통해 만들어진다는 방식입니다. 그림은 대개 스케치로 시작합니다. 점차 세부 사항이 채워집니다. 그러나 이것은 단순히 채워 넣는 과정이 아닙니다. 때로는 원래의 계획이 잘못된 것으로 판명되기도 합니다. 수많은 그림들이 엑스레이로 보면 팔이 움직였거나 얼굴 특징이 재조정된 것으로 드러납니다.

여기서 우리는 회화에서 배울 수 있는 사례가 있습니다. 해킹도 이런 방식으로 작동해야 한다고 생각합니다. 프로그램의 사양이 완벽할 것이라고 기대하는 것은 비현실적입니다. 이 사실을 미리 인정하고, 사양이 즉시 변경될 수 있도록 프로그램을 작성하는 것이 더 좋습니다. (대기업의 구조는 이것을 어렵게 만듭니다. 그래서 여기서 스타트업이 또 다른 이점을 가집니다.)

이제는 성급한 최적화(premature optimization)의 위험에 대해 모두가 알고 있을 것입니다. 우리는 성급한 설계, 즉 프로그램이 무엇을 해야 할지 너무 일찍 결정하는 것에 대해서도 마찬가지로 걱정해야 한다고 생각합니다. 올바른 도구는 이 위험을 피하는 데 도움이 될 수 있습니다.

좋은 프로그래밍 언어는 유화처럼 마음을 바꾸기 쉽게 만들어야 합니다. 동적 타이핑(dynamic typing)은 미리 특정 데이터 표현에 얽매일 필요가 없으므로 여기서 승리합니다. 하지만 유연성의 핵심은 언어를 매우 추상적으로 만드는 것이라고 생각합니다.

가장 쉽게 변경할 수 있는 프로그램은 매우 짧은 프로그램입니다. 이것은 역설처럼 들리지만, 위대한 그림은 반드시 필요한 것보다 더 뛰어나야 합니다.

예를 들어, 레오나르도 다빈치(Leonardo da Vinci)가 내셔널 갤러리(National Gallery)의 '지네브라 데 벤치(Ginevra de Benci)' 초상화를 그렸을 때, 그녀의 머리 뒤에 노간주나무 덤불을 그려 넣었습니다. 그는 그 덤불의 잎사귀 하나하나를 세심하게 그렸습니다. 많은 화가들은 이렇게 생각했을 것입니다. '이것은 그녀의 머리를 감싸기 위해 배경에 넣는 것일 뿐이야. 아무도 그렇게 자세히 보지 않을 거야.'

하지만 레오나르도는 그렇지 않았습니다. 그가 그림의 어떤 부분에 얼마나 열심히 작업했는지는 아무도 그 부분을 얼마나 자세히 볼 것인지에 전혀 의존하지 않았습니다. 그는 마이클 조던(Michael Jordan)과 같았습니다. 끊임없이 노력하는 사람이었죠.

끊임없는 노력은 결국 보이지 않는 세부 사항들이 합쳐져 드러나기 때문에 승리합니다. 사람들이 지네브라 데 벤치 초상화 앞을 지나갈 때, 그들은 레오나르도 다빈치의 작품임을 알리는 명판을 보기도 전에 종종 즉시 그림에 매료됩니다. 그 모든 보이지 않는 세부 사항들이 합쳐져 마치 수천 개의 거의 들리지 않는 목소리들이 모두 조화롭게 노래하는 것처럼, 그저 압도적인 아름다움을 만들어냅니다.

위대한 소프트웨어 역시 아름다움에 대한 광적인 헌신을 요구합니다. 좋은 소프트웨어의 내부를 들여다보면, 아무도 보지 못할 부분들조차 아름답다는 것을 알 수 있습니다. 제가 위대한 소프트웨어를 만든다고 주장하는 것은 아니지만, 코딩에 있어서는 제가 일상생활에서도 똑같이 행동한다면 약물 처방을 받아야 할 정도로 행동한다는 것을 알고 있습니다.

들여쓰기가 엉망이거나, 보기 싫은 변수 이름을 사용하는 코드를 보면 미쳐버릴 것 같습니다.

해커가 단지 사양을 코드로 변환하는 단순한 구현자라면, 그는 도랑을 파는 사람처럼 처음부터 끝까지 작업을 해나갈 수 있을 것입니다. 하지만 해커가 창작자라면, 우리는 영감(inspiration)을 고려해야 합니다.

해킹도 회화와 마찬가지로 작업이 주기적으로 이루어집니다. 때로는 어떤 새로운 프로젝트에 흥분하여 하루에 16시간씩 작업하고 싶을 때도 있습니다. 다른 때에는 아무것도 흥미롭게 느껴지지 않을 때도 있습니다.

좋은 작업을 하려면 이러한 주기를 고려해야 합니다. 왜냐하면 당신이 이 주기에 어떻게 반응하느냐에 따라 영향을 받기 때문입니다. 수동 변속기(manual transmission) 자동차를 타고 언덕을 오를 때, 시동이 꺼지지 않도록 때때로 클러치에서 발을 떼야 합니다. 마찬가지로, 뒤로 물러나는 것은 야망이 멈추는 것을 막을 수 있습니다.

회화와 해킹 모두에는 엄청나게 야심 찬 작업과 편안하게 일상적인 작업이 있습니다. 다른 때라면 멈춰버릴 순간을 위해 쉬운 작업을 남겨두는 것이 좋은 생각입니다. 해킹에서는 말 그대로 버그를 남겨두는 것을 의미할 수 있습니다.

저는 디버깅을 좋아합니다. 해킹이 사람들이 생각하는 것처럼 간단한 유일한 때이기 때문입니다. 완벽하게 제약된 문제가 주어지고, 당신은 그것을 해결하기만 하면 됩니다. 당신의 프로그램은 X를 해야 합니다. 그런데 Y를 합니다. 어디서 잘못된 것일까요? 결국 당신이 이길 것이라는 것을 압니다. 그것은 벽을 칠하는 것만큼 편안합니다.

회화의 예시는 우리 자신의 작업을 관리하는 방법뿐만 아니라 협력하는 방법도 가르쳐줄 수 있습니다. 과거의 위대한 예술 작품 중 많은 부분이 여러 사람의 손으로 만들어졌지만, 박물관에 걸린 작품 옆에는 단 한 사람의 이름만 있을 수 있습니다. 레오나르도는 베로키오(Verrocchio)의 작업실에서 견습생으로 일했으며, 그의 '그리스도의 세례(Baptism of Christ)'에 나오는 천사 중 한 명을 그렸습니다. 이런 종류의 일은 예외가 아니라 일반적이었습니다. 미켈란젤로(Michelangelo)는 시스티나 성당(Sistine Chapel) 천장의 모든 인물을 자신이 직접 그리는 것을 고집했기 때문에 특히 헌신적인 인물로 여겨졌습니다.

제가 아는 한, 화가들이 그림을 함께 작업할 때, 그들은 결코 같은 부분을 작업하지 않았습니다. 거장이 주요 인물을 그리고 조수들이 다른 인물이나 배경을 그리는 것이 일반적이었습니다. 그러나 한 사람이 다른 사람의 작품 위에 덧칠하는 경우는 결코 없었습니다.

저는 이것이 소프트웨어 협업에도 올바른 모델이라고 생각합니다. 너무 지나치게 밀어붙이지 마세요. 세 명 또는 네 명의 다른 사람들이 코드를 해킹하고 있는데, 아무도 그 코드를 진정으로 소유하지 않는다면, 그것은 공용 공간처럼 될 것입니다. 황량하고 버려진 느낌이 들 것이며, 쓰레기가 쌓일 것입니다. 올바른 협업 방식은 프로젝트를 명확하게 정의된 모듈로 나누고, 각 모듈에 명확한 소유자를 두며, 그들 사이의 인터페이스는 프로그래밍 언어처럼 신중하게 설계되고, 가능하다면 명확하게 표현되어야 한다고 생각합니다.

회화처럼 대부분의 소프트웨어는 인간 관객을 위한 것입니다. 따라서 해커는 화가와 마찬가지로 진정으로 훌륭한 작업을 하기 위해 공감 능력을 갖춰야 합니다. 사용자의 관점에서 사물을 볼 수 있어야 합니다.

제가 어렸을 때, 항상 다른 사람의 관점에서 사물을 보라는 말을 들었습니다. 이것은 실제로 항상 제가 원하는 것 대신 다른 사람이 원하는 것을 하라는 의미였습니다. 물론 이것은 공감 능력에 대한 나쁜 인상을 주었고, 저는 공감 능력을 키우지 않기로 결심했습니다.

제가 얼마나 틀렸던가요. 다른 사람의 관점에서 사물을 보는 것이 사실상 성공의 비결이라는 것이 밝혀졌습니다. 그것이 반드시 자신을 희생하는 것을 의미하지는 않습니다. 전혀 그렇지 않습니다. 다른 사람이 사물을 어떻게 보는지 이해한다고 해서 그들의 이익을 위해 행동해야 하는 것은 아닙니다. 어떤 상황에서는—예를 들어 전쟁에서는—정확히 반대로 행동해야 합니다. [4]

대부분의 창작자들은 인간 관객을 위해 물건을 만듭니다. 그리고 관객의 마음을 사로잡으려면 그들이 무엇을 필요로 하는지 이해해야 합니다. 예를 들어, 거의 모든 위대한 그림들은 사람들의 그림입니다. 왜냐하면 사람들은 사람들에게 관심이 있기 때문입니다.

공감 능력은 아마도 좋은 해커와 위대한 해커 사이의 가장 중요한 단일 차이점일 것입니다. 어떤 해커는 매우 똑똑하지만, 공감 능력에 있어서는 거의 독아론자(solipsist)에 가깝습니다. 이런 사람들은 훌륭한 소프트웨어를 설계하기 어렵습니다. [5] 왜냐하면 그들은 사용자의 관점에서 사물을 볼 수 없기 때문입니다.

사람들이 공감 능력이 얼마나 뛰어난지 알 수 있는 한 가지 방법은 기술적 배경이 없는 사람에게 기술적인 질문을 설명하는 것을 지켜보는 것입니다. 우리는 아마도 다른 면에서는 똑똑하지만, 이런 면에서는 우스꽝스러울 정도로 형편없는 사람들을 모두 알 것입니다. 만약 누군가가 저녁 식사 자리에서 그들에게 프로그래밍 언어가 무엇이냐고 묻는다면, 그들은 "아, 고급 언어(high-level language)는 컴파일러(compiler)가 오브젝트 코드(object code)를 생성하기 위한 입력으로 사용하는 것입니다."라고 말할 것입니다. 고급 언어? 컴파일러? 오브젝트 코드? 프로그래밍 언어가 무엇인지 모르는 사람은 당연히 이런 것들도 모를 것입니다.

소프트웨어가 해야 할 일 중 하나는 스스로를 설명하는 것입니다. 따라서 좋은 소프트웨어를 작성하려면 사용자가 얼마나 이해하지 못하는지 이해해야 합니다. 그들은 아무런 준비 없이 소프트웨어에 다가갈 것이고, 매뉴얼을 읽지 않을 것이므로 그들이 예상하는 대로 작동해야 합니다. 이 점에서 제가 본 최고의 시스템은 1985년의 오리지널 매킨토시(Macintosh)였습니다. 그것은 소프트웨어가 거의 하지 않는 일을 했습니다. 그저 작동했습니다. [6]

소스 코드 또한 스스로를 설명해야 합니다. 제가 사람들에게 프로그래밍에 대한 단 한 구절만 기억하게 할 수 있다면, 그것은 '컴퓨터 프로그램의 구조와 해석(Structure and Interpretation of Computer Programs)'의 서문에 나오는 구절일 것입니다.

프로그램은 사람들이 읽기 위해 작성되어야 하며, 기계가 실행하기 위한 것은 부수적이다.

사용자뿐만 아니라 독자에 대한 공감 능력도 필요합니다. 당신은 그들 중 한 명이 될 것이므로, 이것은 당신에게 이익이 됩니다. 많은 해커가 프로그램을 작성하고 6개월 후에 다시 돌아와 자신이 어떻게 작동하는지 전혀 모른다는 것을 발견했습니다. 저는 그런 경험 후 펄(Perl) 사용을 그만둔 사람들을 몇 명 알고 있습니다. [7]

공감 능력의 부족은 지능과 연관되어 있으며, 심지어 어떤 곳에서는 유행처럼 여겨지기도 합니다. 하지만 저는 아무런 상관관계가 없다고 생각합니다. 수학과 자연 과학에서는 공감 능력을 배울 필요 없이 잘할 수 있고, 이 분야의 사람들은 똑똑한 경향이 있어서 이 두 가지 특성이 연관된 것처럼 보이게 되었습니다. 하지만 공감 능력이 부족한 멍청한 사람들도 많습니다. 토크쇼에서 전화로 질문하는 사람들의 말을 들어보세요. 그들은 자신이 묻고자 하는 것을 너무 우회적으로 물어서 진행자가 종종 질문을 다시 표현해야 합니다.

그렇다면 해킹이 회화나 글쓰기처럼 작동한다면, 해킹도 그만큼 멋있을까요? 결국, 우리는 한 번의 삶밖에 살지 못합니다. 어차피 훌륭한 일을 하는 데 시간을 보내는 편이 낫지 않을까요.

불행히도 이 질문에 답하기는 어렵습니다. 명성에는 항상 큰 시간 지연이 있습니다. 마치 먼 별에서 오는 빛과 같습니다. 회화는 500년 전 사람들이 한 위대한 작품 때문에 지금 명성을 얻고 있습니다. 당시에는 아무도 이 그림들이 오늘날 우리가 생각하는 만큼 중요하다고 여기지 않았습니다. 당시 사람들에게 우르비노 공작 페데리코 다 몬테펠트로(Federico da Montefeltro)가 언젠가 피에로 델라 프란체스카(Piero della Francesca)의 그림 속 이상한 코를 가진 사람으로 주로 알려질 것이라는 사실은 매우 이상하게 들렸을 것입니다.

따라서 지금은 해킹이 회화만큼 멋있어 보이지 않는다는 것을 인정하지만, 회화 자체도 전성기에는 지금처럼 멋있어 보이지 않았다는 것을 기억해야 합니다.

우리가 확신할 수 있는 것은 지금이 해킹의 전성기라는 것입니다. 대부분의 분야에서 위대한 작업은 초기에 이루어집니다. 1430년에서 1500년 사이에 제작된 그림들은 여전히 능가할 수 없습니다. 셰익스피어(Shakespeare)는 전문 연극이 막 탄생할 무렵에 등장하여 매체를 너무나 발전시켜 그 이후의 모든 극작가들은 그의 그림자 속에서 살아야 했습니다. 알브레히트 뒤러(Albrecht Durer)는 판화로, 제인 오스틴(Jane Austen)은 소설로 같은 일을 했습니다.

같은 패턴이 반복적으로 나타나는 것을 볼 수 있습니다. 새로운 매체가 등장하면 사람들은 그 매체에 너무나 흥분해서 처음 몇 세대에 걸쳐 대부분의 가능성을 탐구합니다. 해킹은 지금 이 단계에 있는 것 같습니다.

레오나르도 시대에 회화는 그의 작품이 기여한 만큼 멋있지 않았습니다. 해킹이 얼마나 멋진 분야가 될지는 우리가 이 새로운 매체로 무엇을 할 수 있느냐에 달려 있을 것입니다.

각주
[1] 사진술이 회화에 가한 가장 큰 해악은 아마도 최고의 낮잡이를 죽였다는 사실일 것입니다. 역사상 위대한 화가들 대부분은 초상화를 그려 생계를 유지했습니다.

[2] 마이크로소프트는 직원들이 여가 시간에도 오픈소스 프로젝트에 기여하는 것을 discourage한다고 들었습니다. 하지만 지금은 너무 많은 최고의 해커들이 오픈소스 프로젝트에 참여하고 있어서, 이 정책의 주요 효과는 그들이 일류 프로그래머를 고용할 수 없도록 만드는 것일 수 있습니다.

[3] 대학에서 프로그래밍에 대해 배우는 것은 책이나 옷, 데이트에 대해 배우는 것과 매우 유사합니다. 고등학생 때 얼마나 취향이 나빴는지 깨닫는 것과 같습니다.

[4] 여기에 응용된 공감의 예시가 있습니다. 비아웹에서 두 가지 대안 중 결정할 수 없을 때, 우리는 '경쟁자들이 무엇을 가장 싫어할까?'라고 물었습니다. 한때 경쟁사가 자사 소프트웨어에 기본적으로 쓸모없는 기능을 추가했지만, 우리가 가지지 못한 몇 안 되는 기능 중 하나였기 때문에 업계지에서 크게 다루었습니다. 우리는 그 기능이 쓸모없다고 설명할 수도 있었지만, 우리가 직접 구현하면 경쟁사를 더 짜증나게 할 것이라고 판단했고, 그래서 그날 오후 우리만의 버전을 급조했습니다.

[5] 텍스트 편집기와 컴파일러는 제외합니다. 해커는 이러한 것들을 설계하는 데 공감 능력이 필요하지 않습니다. 왜냐하면 그들 자신이 전형적인 사용자이기 때문입니다.

[6] 거의 그랬습니다. 사용 가능한 RAM을 다소 초과하여 불편한 디스크 스와핑(disk swapping)을 유발했지만, 이는 몇 달 안에 추가 디스크 드라이브를 구매하여 해결할 수 있었습니다.

[7] 프로그램을 읽기 쉽게 만드는 방법은 주석으로 가득 채우는 것이 아닙니다. 저는 아벨슨(Abelson)과 서스만(Sussman)의 인용구를 한 단계 더 나아가고 싶습니다. 프로그래밍 언어는 알고리즘을 표현하도록 설계되어야 하며, 컴퓨터에 실행 방법을 알려주는 것은 부수적이어야 합니다. 좋은 프로그래밍 언어는 영어보다 소프트웨어를 설명하는 데 더 적합해야 합니다. 도로에 예상치 못한 급커브가 있는 부분에만 화살표가 있는 것처럼, 독자들에게 경고해야 할 일종의 임시방편(kludge)이 있을 때만 주석이 필요합니다.

초고를 읽어준 트레버 블랙웰, 로버트 모리스, 댄 기핀, 리사 랜들, 그리고 연설에 초대해 준 헨리 라이트너와 래리 핀켈스타인에게 감사드립니다.