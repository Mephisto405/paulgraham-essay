# 해커와 화가 (Hackers and Painters)

(이 에세이는 하버드에서 있었던 초청 강연을 바탕으로 하며, 이에 앞서 노스이스턴 대학교에서 진행했던 강연 내용을 포함하고 있습니다.)

2003년 5월

##

제가 컴퓨터 과학 대학원을 마치고 미술 대학원에 들어가 회화(painting)를 공부했을 때, 많은 사람들이 컴퓨터에 관심 있는 사람이 왜 그림에도 관심을 갖는지 놀라워하는 것 같았습니다. 그들은 해킹(hacking)과 회화가 매우 다른 종류의 작업이라고 생각하는 듯했습니다. 해킹은 냉철하고, 정밀하며, 체계적인 작업이고, 회화는 원초적인 충동의 격렬한 표현이라고 말입니다.

이 두 가지 이미지 모두 잘못되었습니다. 해킹과 회화는 많은 공통점을 가지고 있습니다. 사실 제가 아는 모든 종류의 사람들 중에서 해커와 화가가 가장 비슷합니다.

해커와 화가가 공통적으로 가진 것은 둘 다 '만드는 사람'이라는 점입니다. 작곡가, 건축가, 작가와 더불어 해커와 화가가 추구하는 것은 좋은 것을 만드는 것입니다. 그들이 그 자체로 연구를 하는 것은 아니지만, 좋은 것을 만들기 위해 노력하는 과정에서 새로운 기법을 발견한다면, 그것은 더 좋을수록 좋습니다.

저는 '컴퓨터 과학'이라는 용어를 좋아하지 않습니다. 제가 그것을 좋아하지 않는 주된 이유는 그런 것이 존재하지 않기 때문입니다. 컴퓨터 과학은 역사의 우연으로, 유고슬라비아처럼 느슨하게 관련된 여러 분야를 한데 묶어 놓은 잡동사니에 불과합니다.

한쪽 끝에는 정말로 수학자인 사람들이 있지만, DARPA grants를 받기 위해 자신들의 작업을 컴퓨터 과학이라고 부릅니다. 중간에는 컴퓨터의 자연사 같은 것을 연구하는 사람들, 예를 들어 네트워크를 통해 데이터를 라우팅하는 알고리즘의 행동을 연구하는 사람들이 있습니다. 그리고 다른 극단에는 흥미로운 소프트웨어를 작성하려는 해커들이 있으며, 이들에게 컴퓨터는 건축가에게 콘크리트가 그렇듯, 화가에게 물감이 그렇듯, 단순히 표현의 매체일 뿐입니다. 마치 수학자, 물리학자, 건축가가 모두 같은 학과에 있어야 하는 것과 같습니다.

때때로 해커들이 하는 일을 "소프트웨어 엔지니어링"이라고 부르기도 하지만, 이 용어 역시 마찬가지로 오해의 소지가 있습니다. 훌륭한 소프트웨어 디자이너는 건축가만큼이나 엔지니어와는 거리가 멉니다. 건축과 엔지니어링의 경계는 명확하게 정의되어 있지는 않지만, 분명히 존재합니다.

그것은 '무엇을 할 것인가(what)'와 '어떻게 할 것인가(how)' 사이에 있습니다. 건축가는 무엇을 할지 결정하고, 엔지니어는 그것을 어떻게 할지 알아냅니다. '무엇'과 '어떻게'는 너무 분리되어서는 안 됩니다. 어떻게 할지 이해하지 못한 채 무엇을 할지 결정하려고 하면 문제가 발생하기 쉽습니다.

하지만 해킹은 분명 명세(spec)를 어떻게 구현할지에 대한 결정 이상이 될 수 있습니다. 최상의 상태에서는 그것이 명세를 만드는 것입니다. 비록 그렇게 하는 가장 좋은 방법은 그것을 구현하는 것임이 드러나지만 말입니다.

어쩌면 언젠가는 '컴퓨터 과학'이 유고슬라비아처럼 구성 요소로 분해될지도 모릅니다. 그것은 좋은 일일 수 있습니다. 특히 그것이 나의 고향, 해킹의 독립을 의미한다면 말입니다.

이러한 다양한 종류의 작업을 한 학과에 묶어두는 것이 행정적으로는 편리할 수 있지만, 지적으로는 혼란스럽습니다. 이것이 제가 '컴퓨터 과학'이라는 이름을 좋아하지 않는 또 다른 이유입니다. 중간에 있는 사람들은 실험 과학과 유사한 것을 하고 있다고 주장할 수 있습니다. 하지만 양극단에 있는 사람들, 즉 해커들과 수학자들은 실제로 과학을 하고 있는 것이 아닙니다.

수학자들은 이것에 대해 크게 신경 쓰지 않는 것 같습니다. 그들은 수학과에 있는 다른 수학자들처럼 열심히 정리(theorem)를 증명하러 가고, 아마 곧 자신들이 일하는 건물이 바깥에는 "컴퓨터 과학"이라고 쓰여 있다는 사실을 알아차리지 못하게 될 것입니다. 하지만 해커들에게 이 명칭은 문제입니다. 만약 그들이 하는 일이 과학이라고 불린다면, 그들은 과학적으로 행동해야 한다는 느낌을 받게 됩니다.

그래서 대학과 연구소의 해커들은 자신이 진정으로 하고 싶은 것, 즉 아름다운 소프트웨어를 디자인하는 대신, 과학적으로 행동해야 한다고 느끼며 연구 논문을 작성해야 한다고 생각합니다. 최상의 경우, 논문은 단순한 형식일 뿐입니다. 해커는 멋진 소프트웨어를 작성하고, 그것에 대한 논문을 씁니다. 그리고 그 논문은 소프트웨어로 표현되는 성과의 대리물(proxy)이 됩니다.

하지만 종종 이러한 불일치는 문제를 야기합니다. 아름다운 것을 만드는 것에서 벗어나 연구 논문에 더 적합한 추한 것을 만드는 방향으로 흘러가기 쉽습니다. 불행하게도 아름다운 것이 항상 논문에 가장 적합한 주제가 되는 것은 아닙니다.

첫째, 연구는 독창적이어야 합니다. 박사 학위 논문을 써본 사람이라면 누구나 알겠지만, 미개척지를 탐험하는 확실한 방법은 아무도 원하지 않는 땅을 선점하는 것입니다. 둘째, 연구는 실질적이어야 합니다. 서투른 시스템이 더 풍부한 논문을 만들어냅니다. 왜냐하면 일을 완료하기 위해 극복해야 했던 장애물에 대해 쓸 수 있기 때문입니다. 잘못된 가정에서 시작하는 것만큼 풍부한 문제를 만들어내는 것은 없습니다. 대부분의 인공지능(AI)은 이 규칙의 예시입니다. 만약 지식이 추상적인 개념을 나타내는 변수들의 술어 논리 표현식 목록으로 표현될 수 있다고 가정한다면, 이 방식이 어떻게 작동하게 할지에 대해 써야 할 논문이 아주 많아질 것입니다. Ricky Ricardo가 말했듯이, "Lucy, 설명할 게 아주 많아."

아름다운 것을 창조하는 방법은 종종 이미 존재하는 것에 미묘한 조정을 가하거나, 기존 아이디어를 약간 새로운 방식으로 결합하는 것입니다. 이러한 종류의 작업은 연구 논문으로 전달하기 어렵습니다.

그렇다면 왜 대학과 연구소는 계속해서 해커를 출판물로 평가하는 것일까요? '학업 적성'이 단순한 표준화된 시험으로 측정되거나, 프로그래머의 생산성이 코드 라인 수로 측정되는 것과 같은 이유입니다. 이러한 시험은 적용하기 쉽고, 어느 정도 작동하는 쉬운 시험만큼 유혹적인 것은 없습니다.

해커가 실제로 하려는 것, 즉 아름다운 소프트웨어를 디자인하는 것을 측정하는 것은 훨씬 더 어려울 것입니다. 훌륭한 디자인을 평가하려면 좋은 디자인 감각이 필요합니다. 그리고 사람들의 좋은 디자인을 인식하는 능력과 그것을 할 수 있다는 확신 사이에는 아무런 상관관계가 없으며, 아마도 역 상관관계만 있을 뿐입니다.

유일한 외부적인 시험은 시간입니다. 시간이 지남에 따라 아름다운 것은 번성하는 경향이 있고, 추한 것은 버려지는 경향이 있습니다. 불행하게도 관련된 시간은 인간의 수명보다 길 수 있습니다. Samuel Johnson은 작가의 명성이 수렴하는 데 백 년이 걸린다고 말했습니다. 작가의 영향력 있는 친구들이 죽기를 기다려야 하고, 그들의 추종자들이 모두 죽기를 기다려야 합니다.

해커들은 자신의 명성에 상당 부분 무작위적인 요소가 있다는 것을 받아들여야 한다고 생각합니다. 이 점에서 그들은 다른 만드는 사람들과 다르지 않습니다. 사실, 그들은 비교적 운이 좋은 편입니다. 패션의 영향력은 회화만큼 해킹에서는 크지 않습니다.

자신의 작업을 사람들이 오해하는 것보다 더 나쁜 일도 있습니다. 더 나쁜 위험은 자신이 자신의 작업을 오해하는 것입니다. 관련 분야는 아이디어를 찾는 곳입니다. 만약 자신이 컴퓨터 과학과에 있다면, 예를 들어 해킹은 이론 컴퓨터 과학이 이론으로 삼는 것의 응용 버전이라고 믿는 자연스러운 유혹이 있습니다. 제가 대학원 과정 내내 마음 한구석에는 이론을 더 알아야 한다는 불편한 느낌을 가지고 있었고, 기말고사 후 삼 주 만에 그 모든 것을 잊어버린 것은 매우 태만했기 때문입니다.

이제 저는 제가 틀렸다는 것을 깨달았습니다. 해커는 계산 이론(theory of computation)을 알아야 하는 정도가 화가가 물감 화학(paint chemistry)을 아는 정도와 같습니다. 시간 및 공간 복잡도(time and space complexity)를 계산하는 방법과 튜링 완전성(Turing completeness)에 대해 알아야 합니다. 파서(parser)나 정규 표현식 라이브러리를 작성해야 할 경우를 대비해 상태 기계(state machine)의 개념이라도 최소한 기억해 두는 것이 좋을 수도 있습니다. 사실 화가들은 물감 화학에 대해 그보다 훨씬 더 많이 기억해야 합니다.

저는 아이디어의 가장 좋은 원천이 '컴퓨터'라는 단어가 이름에 포함된 다른 분야가 아니라, '만드는 사람들'이 거주하는 다른 분야라는 것을 발견했습니다. 회화는 계산 이론보다 훨씬 더 풍부한 아이디어의 원천이었습니다.

예를 들어, 저는 대학에서 컴퓨터에 손댈 생각조차 하기 전에 종이 위에서 프로그램을 완전히 구상해야 한다고 배웠습니다. 저는 제가 그렇게 프로그래밍하지 않는다는 것을 발견했습니다. 종이가 아니라 컴퓨터 앞에 앉아서 프로그래밍하는 것을 좋아했습니다. 더 나쁜 것은, 프로그램을 참을성 있게 완성하고 그것이 정확하다고 확신하는 대신, 저는 끔찍하게 잘못된 코드를 쏟아내고 점차 모양을 다듬는 경향이 있었습니다. 제가 배운 바로는, 디버깅(debugging)은 오타와 실수를 잡아내는 일종의 최종 단계였습니다. 제가 일하는 방식으로는 프로그래밍이 디버깅으로 구성되는 것처럼 보였습니다.

오랫동안 저는 이 점에 대해 죄책감을 느꼈습니다. 마치 초등학교에서 가르쳐 준 대로 연필을 쥐는 방식대로 하지 못했던 것에 대해 죄책감을 느꼈던 것처럼 말입니다.

만약 제가 다른 만드는 사람들, 즉 화가나 건축가를 돌아보기만 했더라면, 제가 하고 있는 일에 이름이 있다는 것을 깨달았을 것입니다: 바로 스케치(sketching)였습니다. 제가 알기로는, 대학에서 저에게 프로그래밍을 가르친 방식은 완전히 잘못되었습니다. 작가, 화가, 건축가가 하듯이, 프로그램을 작성하면서 그것을 구상해야 합니다.

이것을 깨닫는 것은 소프트웨어 디자인에 실질적인 영향을 미칩니다. 프로그래밍 언어는 무엇보다도 유연해야(malleable) 한다는 것을 의미합니다. 프로그래밍 언어는 이미 생각한 프로그램을 표현하는 것이 아니라, 프로그램을 생각하는 것을 위한 것입니다. 그것은 펜이 아니라 연필이어야 합니다. 만약 사람들이 대학에서 저에게 가르쳤던 방식대로 실제로 프로그램을 작성한다면, 정적 타입(Static typing)은 훌륭한 아이디어일 것입니다. 하지만 제가 아는 해커 중 누구도 그런 식으로 프로그램을 작성하지 않습니다. 우리는 낙서하고, 문지르고, 얼룩을 묻힐 수 있는 언어가 필요합니다. 마치 무릎 위에 균형을 잡고 있는 차 한 잔의 타입들과 함께, 컴파일러라는 엄격한 노부인과 예의 바른 대화를 해야 하는 언어가 아니라 말입니다.

정적 타입에 관한 이야기가 나온 김에, 만드는 사람들과 자신을 동일시하면 과학계를 괴롭히는 또 다른 문제, 즉 '수학 선망(math envy)'으로부터 우리를 구할 수 있습니다. 과학계에 있는 모든 사람들은 수학자들이 자신들보다 더 똑똑하다고 은밀히 믿습니다. 수학자들도 그렇게 믿는다고 생각합니다. 어쨌든 그 결과 과학자들은 자신의 작업을 가능한 한 수학적으로 보이게 만들려는 경향이 있습니다. 물리학과 같은 분야에서는 이것이 큰 해를 끼치지 않을 수 있지만, 자연 과학에서 멀어질수록 문제는 더욱 커집니다.

공식으로 가득 찬 한 페이지는 매우 인상적으로 보입니다. (팁: 더 인상적으로 보이게 하려면 그리스 문자 변수를 사용하세요.) 그래서 중요한 문제보다는, 예를 들어 형식적으로 다룰 수 있는 문제에 집중하려는 유혹이 큽니다.

만약 해커들이 작가와 화가 같은 다른 만드는 사람들과 자신을 동일시한다면, 그들은 이런 일을 하고 싶어지지 않을 것입니다. 작가와 화가는 수학 선망으로 고통받지 않습니다. 그들은 완전히 다른 일을 하고 있다고 느낍니다. 해커들도 그렇다고 생각합니다.

만약 대학과 연구소가 해커들이 원하는 종류의 작업을 하는 것을 막는다면, 아마도 그들을 위한 장소는 기업일 것입니다. 불행하게도 대부분의 기업은 해커들이 원하는 것을 하도록 내버려 두지 않습니다. 대학과 연구소는 해커에게 과학자가 되기를 강요하고, 기업은 엔지니어가 되기를 강요합니다.

저 자신도 이것을 비교적 최근에야 발견했습니다. Yahoo가 Viaweb을 인수했을 때, 그들은 제가 무엇을 하고 싶은지 물었습니다. 저는 사업적인 측면을 별로 좋아하지 않았고, 그냥 해킹을 하고 싶다고 말했습니다. Yahoo에 도착했을 때, 해킹이라는 것이 그들에게는 디자인하는 것이 아니라 소프트웨어를 구현하는 것을 의미한다는 것을 알게 되었습니다. 프로그래머는 제품 관리자(product manager)의 비전(비전이라는 단어를 써야 한다면)을 코드로 번역하는 기술자로 여겨졌습니다.

이것이 대기업의 기본 계획인 것 같습니다. 그들은 결과의 표준 편차를 줄이기 위해 그렇게 합니다. 실제로 소프트웨어를 디자인할 수 있는 해커는 소수에 불과하며, 회사를 운영하는 사람들이 이들을 식별하기는 어렵습니다. 그래서 대부분의 회사는 소프트웨어의 미래를 한 명의 뛰어난 해커에게 맡기는 대신, 위원회에 의해 디자인되도록 시스템을 구축하고 해커는 단지 디자인을 구현하도록 합니다.

만약 어떤 시점에 돈을 벌고 싶다면, 이것을 기억하십시오. 이것이 스타트업이 이기는 이유 중 하나이기 때문입니다. 대기업은 재앙을 피하기 위해 디자인 결과의 표준 편차를 줄이고 싶어 합니다. 하지만 진동을 억제하면 낮은 지점뿐만 아니라 높은 지점도 잃게 됩니다. 이것은 대기업에게는 문제가 되지 않습니다. 왜냐하면 그들은 훌륭한 제품을 만듦으로써 이기는 것이 아니기 때문입니다. 대기업은 다른 대기업보다 덜 형편없음으로써 이깁니다.

그래서 만약 당신이 소프트웨어가 제품 관리자에 의해 디자인될 정도로 큰 회사와 디자인 전쟁을 벌일 방법을 알아낼 수 있다면, 그들은 결코 당신을 따라잡을 수 없을 것입니다. 이러한 기회는 쉽게 찾을 수 있는 것은 아닙니다. 큰 회사와 디자인 전쟁을 벌이는 것은, 성채 안의 상대와 백병전을 벌이는 것처럼 어렵습니다. 예를 들어 Microsoft Word보다 더 나은 워드 프로세서를 작성하는 것은 꽤 쉬울 수 있습니다. 하지만 Microsoft는 운영 체제 독점이라는 성채 안에서 당신이 그렇게 해도 눈치채지 못할 것입니다.

디자인 전쟁을 벌일 장소는 아무도 아직 요새를 구축하지 못한 새로운 시장입니다. 그곳에서 당신은 디자인에 대한 대담한 접근 방식과, 제품을 디자인하고 구현하는 동일한 사람들이 함께함으로써 크게 이길 수 있습니다. Microsoft 자신도 초기에 그렇게 했습니다. Apple도 마찬가지였고, Hewlett-Packard도 그랬습니다. 성공적인 스타트업이라면 거의 모두 그랬을 것이라고 생각합니다.

그래서 훌륭한 소프트웨어를 구축하는 한 가지 방법은 자신만의 스타트업을 시작하는 것입니다. 하지만 여기에는 두 가지 문제가 있습니다. 첫째, 스타트업에서는 소프트웨어를 작성하는 것 외에 너무 많은 일을 해야 합니다. Viaweb에서는 일의 4분의 1만 해킹에 쓸 수 있다면 운이 좋다고 생각했습니다. 나머지 4분의 3 동안 해야 했던 일들은 지루한 것부터 무시무시한 것까지 다양했습니다. 저는 이것에 대한 기준점을 가지고 있습니다. 왜냐하면 보드 미팅(board meeting)을 빠져나와 충치 치료를 받아야 했던 적이 있기 때문입니다. 치과 의자의 등에 기대어 드릴을 기다리며 마치 휴가를 온 것 같은 기분을 느꼈던 것을 기억합니다.

스타트업의 또 다른 문제는 돈을 벌게 해주는 소프트웨어의 종류와, 그것을 쓰는 것이 흥미로운 소프트웨어의 종류 사이에 큰 차이가 없다는 것입니다. 프로그래밍 언어를 쓰는 것은 흥미롭고, Microsoft의 첫 번째 제품도 실제로 프로그래밍 언어였지만, 이제 아무도 프로그래밍 언어에 돈을 지불하지 않을 것입니다. 돈을 벌고 싶다면, 무료로 해결하기에는 너무 까다로운 문제에 집중하도록 강요받는 경향이 있습니다.

모든 만드는 사람들이 이 문제에 직면합니다. 가격은 수요와 공급에 의해 결정되며, 재미있는 작업에 대한 수요는 개인 고객의 평범한 문제를 해결하는 것에 대한 수요만큼 많지 않습니다. 오프 브로드웨이 연극에 출연하는 것은 무역 박람회 부스에서 고릴라 복장을 하는 것만큼 돈이 되지 않습니다. 소설을 쓰는 것은 음식물 처리기에 대한 광고 문구를 작성하는 것만큼 돈이 되지 않습니다. 그리고 프로그래밍 언어를 해킹하는 것은 어떤 회사의 레거시 데이터베이스를 웹 서버에 연결하는 방법을 알아내는 것만큼 돈이 되지 않습니다.

저는 이 문제에 대한 소프트웨어 분야에서의 해결책은 거의 모든 만드는 사람들이 아는 개념, 즉 '생계 수단(day job)'이라고 생각합니다. 이 문구는 밤에 공연하는 음악가들로부터 시작되었습니다. 더 일반적으로 말하면, 돈을 위해 하는 일과 사랑으로 하는 일이 있다는 의미입니다. 거의 모든 만드는 사람들은 경력 초기에 생계 수단을 가지고 있습니다. 화가와 작가들은 악명 높을 정도로 그렇습니다. 운이 좋다면 자신의 실제 작업과 밀접하게 관련된 생계 수단을 얻을 수 있습니다. 음악가들은 종종 음반 가게에서 일하는 것처럼 보입니다. 프로그래밍 언어나 운영 체제를 작업하는 해커도 마찬가지로 그것을 사용하는 생계 수단을 얻을 수 있습니다. [1]

제가 해커들이 생계 수단을 가지고 부업으로 아름다운 소프트웨어를 작업해야 한다고 말할 때, 이것을 새로운 아이디어로 제안하는 것이 아닙니다. 이것이 바로 오픈 소스 해킹(open-source hacking)의 전부입니다. 제가 말하는 것은 오픈 소스가 아마도 올바른 모델이라는 것입니다. 왜냐하면 그것은 다른 모든 만드는 사람들이 독립적으로 확인해 준 것이기 때문입니다.

고용주가 해커들이 오픈 소스 프로젝트에 참여하는 것을 꺼린다는 것이 나에게는 놀랍게 느껴집니다. Viaweb에서는 참여하지 않는 사람을 고용하기를 꺼렸을 것입니다. 프로그래머를 인터뷰할 때, 우리가 가장 중요하게 생각했던 것은 그들이 자투리 시간에 어떤 종류의 소프트웨어를 작성하는지였습니다. 당신이 그것을 사랑하지 않으면 어떤 것도 제대로 잘할 수 없으며, 만약 당신이 해킹을 사랑한다면 필연적으로 자신만의 프로젝트를 하고 있을 것입니다. [2]

해커는 과학자가 아니라 만드는 사람이기 때문에, 비유를 찾는 가장 좋은 장소는 과학이 아니라 다른 종류의 만드는 사람들 중에서 찾아야 합니다. 회화는 해킹에 대해 무엇을 더 가르쳐 줄 수 있을까요?

회화의 예를 통해 배울 수 있는 한 가지는, 혹은 적어도 확인할 수 있는 것은 해킹을 배우는 방법입니다. 당신은 대부분 그것을 직접 해보면서 그림을 배우는 것과 같습니다. 해킹도 마찬가지입니다. 대부분의 해커는 대학 프로그래밍 강좌를 들으면서 해킹을 배우는 것이 아니라, 열세 살 때 자신만의 프로그램을 작성하면서 배웁니다. 대학 강좌에서도 당신은 대부분 해킹을 직접 해보면서 배웁니다. [3]

화가들은 자신의 작업 흔적을 뒤에 남기기 때문에, 당신은 그들이 직접 해보면서 배우는 것을 지켜볼 수 있습니다. 화가의 작업을 연대순으로 보면, 각 그림이 이전 그림에서 배운 것을 바탕으로 구축된다는 것을 알게 될 것입니다. 그림에서 매우 잘 작동하는 것이 있다면, 그것의 버전 1을 이전 그림에서 더 작은 형태로 찾는 것이 일반적입니다.

대부분의 만드는 사람들이 이런 식으로 작업한다고 생각합니다. 작가와 건축가도 마찬가지인 것 같습니다. 아마도 해커들은 화가들처럼 행동하는 것이 좋을 것입니다. 즉, 하나의 프로젝트에 몇 년 동안 계속 작업하고 나중에 떠오른 모든 아이디어를 수정 사항으로 통합하려 하기보다, 정기적으로 처음부터 다시 시작하는 것입니다.

해커들이 직접 해보면서 배운다는 사실은 해킹이 과학과 얼마나 다른지를 보여주는 또 다른 신호입니다. 과학자들은 과학을 직접 해보면서 배우는 것이 아니라, 실험과 문제 풀이를 하면서 배웁니다. 과학자들은 다른 사람이 이미 자신을 위해 해 놓은 작업을 재현하려고 하면서 시작합니다. 결국에는 독창적인 작업을 할 수 있는 지점에 도달합니다. 반면에 해커들은 처음부터 독창적인 작업을 하지만, 그것은 매우 서툴 뿐입니다. 그래서 해커는 독창적으로 시작해서 실력이 향상되고, 과학자는 훌륭하게 시작해서 독창적으로 발전합니다.

만드는 사람들이 배우는 또 다른 방법은 예시를 통해서입니다. 화가에게 미술관은 기법의 참고 도서관입니다. 수백 년 동안 화가들의 전통적인 교육의 일부는 위대한 거장들의 작품을 모사하는 것이었습니다. 왜냐하면 모사하는 것은 그림이 어떻게 만들어지는지 주의 깊게 보도록 강요하기 때문입니다.

작가들도 이렇게 합니다. Benjamin Franklin은 Addison과 Steele의 에세이 요점을 요약한 다음 그것을 재현하려고 노력함으로써 글쓰기를 배웠습니다. Raymond Chandler도 마찬가지였습니다. 마찬가지로 해커들도 훌륭한 프로그램들을 살펴보면서 프로그래밍을 배울 수 있습니다. 단순히 그들이 무엇을 하는지를 보는 것이 아니라, 소스 코드도 함께 봐야 합니다. 오픈 소스 운동의 덜 알려진 이점 중 하나는 프로그래밍을 배우는 것을 더 쉽게 만들었다는 것입니다. 제가 프로그래밍을 배울 때, 우리는 주로 책의 예제에 의존해야 했습니다. 당시 사용 가능했던 큰 코드 덩어리는 Unix였지만, 그것조차 오픈 소스가 아니었습니다. 소스를 읽는 대부분의 사람들은 John Lions의 책 복사본을 이용했는데, 이 책은 1977년에 작성되었음에도 불구하고 1996년까지 출판이 허용되지 않았습니다.

회화에서 또 다른 예시를 들자면, 그림이 점진적인 개선(gradual refinement)을 통해 만들어지는 방식입니다. 그림은 보통 스케치로 시작합니다. 점차 세부 사항이 채워집니다. 하지만 단순히 채워 넣는 과정만은 아닙니다. 때로는 원래 계획이 잘못되었음이 드러나기도 합니다. 수많은 그림들은 엑스레이로 보면 움직인 팔다리나 재조정된 얼굴 특징을 가지고 있음이 드러납니다.

여기서 우리가 배울 수 있는 사례가 있습니다. 저는 해킹도 이렇게 작동해야 한다고 생각합니다. 프로그램의 사양이 완벽할 것이라고 기대하는 것은 비현실적입니다. 이를 미리 인정하고 사양이 수시로 변경될 수 있도록 프로그램을 작성하는 것이 더 낫습니다. (대기업의 구조는 그들이 이것을 하도록 어렵게 만들므로, 여기서 스타트업이 또 다른 이점을 갖게 됩니다.)

이제 누구나 조기 최적화(premature optimization)의 위험에 대해 알고 있을 것입니다. 저는 조기 디자인(premature design), 즉 프로그램이 무엇을 해야 하는지에 대해 너무 일찍 결정하는 것에 대해서도 똑같이 걱정해야 한다고 생각합니다. 올바른 도구가 이 위험을 피하는 데 도움이 될 수 있습니다.

훌륭한 프로그래밍 언어는 유화처럼 마음을 바꾸기 쉽게 만들어야 합니다. 동적 타입(Dynamic typing)은 사람들이 대학에서 가르쳐 준 방식대로 프로그램을 작성하는 것이 아니기 때문에 여기서 유리합니다. 하지만 유연성의 핵심은 언어를 매우 추상적(abstract)으로 만드는 것이라고 생각합니다.

가장 바꾸기 쉬운 프로그램은 매우 짧은 프로그램입니다. 이것은 역설처럼 들리지만, 훌륭한 그림은 그래야 하는 것보다 더 뛰어나야 합니다. 예를 들어, Leonardo가 국립 미술관에 있는 Ginevra de Benci의 초상화를 그렸을 때, 그는 그녀의 머리 뒤에 향나무 덤불을 그려 넣었습니다. 그는 그 안에 있는 모든 잎을 조심스럽게 그렸습니다. 많은 화가들은 이것이 단지 그녀의 머리를 감싸는 배경일 뿐이며, 아무도 그렇게 자세히 보지 않을 것이라고 생각했을 것입니다. Leonardo는 그렇지 않았습니다. 그는 그림의 어느 부분에 얼마나 열심히 작업했는지가 아무도 그것을 얼마나 자세히 볼 것으로 예상하는지와 전혀 관련이 없었습니다. 그는 Michael Jordan 같았습니다. 지칠 줄 몰랐죠.

지칠 줄 모름은 총합하면 보이지 않는 세부 사항이 보이게 되기 때문에 승리합니다. Ginevra de Benci의 초상화를 지나갈 때, 사람들은 라벨을 보고 Leonardo da Vinci라고 쓰여 있다는 것을 알아차리기도 전에, 그 초상화에 시선이 즉시 사로잡힙니다. 보이지 않는 그 모든 세부 사항들이 합쳐져 놀라운 것을 만들어냅니다. 마치 거의 들리지 않는 천 개의 목소리가 모두 조화롭게 노래하는 것과 같습니다.

마찬가지로 훌륭한 소프트웨어는 아름다움에 대한 광적인 헌신을 요구합니다. 훌륭한 소프트웨어 안을 들여다보면, 아무도 보지 못하게 될 부분들조차 아름답다는 것을 발견할 수 있습니다. 저는 제가 훌륭한 소프트웨어를 작성한다고 주장하는 것은 아니지만, 코드에 관해서는 일상생활에서 그런 방식으로 접근한다면 처방 약 대상이 될 정도로 행동한다는 것을 압니다. 들여쓰기가 잘못된 코드나 추악한 변수 이름을 보면 미쳐버릴 것 같습니다.

만약 해커가 단지 명세를 코드로 바꾸는 구현자일 뿐이라면, 그는 마치 도랑을 파는 사람처럼 한쪽 끝에서 다른 쪽 끝까지 작업할 수 있을 것입니다. 하지만 해커가 창조자라면, 우리는 영감을 고려해야 합니다.

해킹에서도 회화와 마찬가지로 작업은 주기적으로 옵니다. 어떤 때는 새로운 프로젝트에 흥분해서 하루 열여섯 시간씩 일하고 싶을 때도 있습니다. 다른 때는 아무것도 흥미롭게 느껴지지 않습니다. 훌륭한 작업을 하려면 이러한 주기들을 고려해야 합니다. 왜냐하면 그것들은 당신이 그것들에 어떻게 반응하는지에 따라 달라지기 때문입니다. 언덕에서 수동 변속기 차량을 운전할 때, 시동이 꺼지는 것을 피하기 위해 가끔 클러치를 살짝 떼야 합니다. 마찬가지로 살짝 떼는 것은 야망이 시동이 꺼지는 것을 방지할 수도 있습니다.

회화와 해킹 모두에서 끔찍할 정도로 야심 찬 작업과, 안심시키는 일상적인 작업이 있습니다. 그렇지 않으면 시동이 꺼질 순간들을 위해 쉬운 작업을 좀 남겨두는 것이 좋습니다. 해킹에서는 이것이 말 그대로 버그를 비축해 두는 것을 의미할 수 있습니다. 저는 디버깅을 좋아합니다. 그것은 해킹이 사람들이 생각하는 것만큼 직설적일 수 있는 유일한 때입니다. 당신은 완전히 제약된 문제를 가지고 있고, 그것을 해결하기만 하면 됩니다. 당신의 프로그램은 x를 해야 합니다. 대신 y를 합니다. 어디서 잘못되었을까요? 결국 승리할 것을 압니다. 그것은 벽을 칠하는 것만큼 편안합니다.

회화의 예시는 자신의 작업을 관리하는 방법뿐만 아니라, 협력하는 방법도 가르쳐 줄 수 있습니다. 과거의 많은 위대한 예술 작품은 여러 사람의 손으로 만들어졌지만, 미술관의 벽에는 단 하나의 이름만 있을 수 있습니다. Leonardo는 Verrocchio의 작업실에서 도제였으며, 그의 '그리스도의 세례'에서 천사 중 하나를 그렸습니다. 이러한 일은 예외가 아니라 규칙이었습니다. Michelangelo는 시스티나 성당 천장의 모든 인물을 직접 칠하겠다고 고집한 것에 대해 특히 헌신적이라고 여겨졌습니다.

제가 아는 한, 화가들이 그림 작업을 함께 할 때 같은 부분을 작업하는 경우는 없었습니다. 거장이 주요 인물을 그리고 조수들이 다른 인물과 배경을 그리는 것이 일반적이었습니다. 하지만 한 사람이 다른 사람의 작업 위에 덧칠하는 경우는 결코 없었습니다.

저는 이것이 소프트웨어에서의 협업에도 올바른 모델이라고 생각합니다. 너무 멀리 밀어붙이지 마십시오. 세네 명의 다른 사람들이 해킹하고 있는 코드 조각에, 그 누구도 진정으로 소유권을 갖지 않을 때, 그것은 공동 휴게실과 비슷하게 될 것입니다. 황량하고 버려진 느낌이 들고, 잡동사니가 쌓이게 될 것입니다.

저는 협업의 올바른 방식은 프로젝트를 명확하게 정의된 모듈로 나누고, 각 모듈에는 확실한 소유자가 있으며, 모듈 간의 인터페이스는 프로그래밍 언어만큼이나 세심하게 설계되고, 가능하다면 정교하게 만들어야 한다고 생각합니다.

회화와 마찬가지로 대부분의 소프트웨어는 인간 관객을 대상으로 합니다. 따라서 화가처럼 해커도 진정으로 훌륭한 작업을 하기 위해서는 공감 능력(empathy)을 가져야 합니다. 사용자의 관점에서 사물을 볼 수 있어야 합니다.

어렸을 때 저는 항상 다른 사람의 관점에서 사물을 보라는 말을 들었습니다. 이것이 실제로 의미했던 것은 내가 원하는 것 대신 다른 사람이 원하는 것을 하는 것이었습니다. 이것은 물론 공감 능력에 나쁜 평판을 주었고, 저는 그것을 키우지 않기로 결정했습니다.

세상에, 제가 틀렸습니다. 다른 사람들의 관점에서 사물을 보는 것이 성공의 비결이나 다름없다는 것이 밝혀졌습니다. 그것이 반드시 자기 희생적이라는 것을 의미하지는 않습니다. 결코 그렇지 않습니다. 다른 사람이 사물을 보는 방식을 이해한다고 해서 그의 이익을 위해 행동하게 되는 것은 아닙니다. 어떤 상황에서는, 예를 들어 전쟁에서는, 정반대로 하고 싶을 것입니다. [4]

대부분의 만드는 사람들은 인간 관객을 위해 물건을 만듭니다. 그리고 관객과 소통하려면 그들이 무엇을 필요로 하는지 이해해야 합니다. 예를 들어, 역사상 가장 위대한 그림의 거의 대부분은 사람들의 그림입니다. 왜냐하면 사람들은 사람들이 관심을 갖는 대상이기 때문입니다. 공감 능력은 아마도 좋은 해커와 위대한 해커 사이의 가장 중요한 차이점일 것입니다. 어떤 해커들은 매우 똑똑하지만, 공감 능력에 관해서는 거의 자기 중심주의자(solipsists)와 같습니다. 그런 사람들이 훌륭한 소프트웨어를 디자인하는 것은 어렵습니다. [5] 왜냐하면 그들은 사용자의 관점에서 사물을 볼 수 없기 때문입니다.

사람들이 공감 능력에 얼마나 능숙한지 알 수 있는 한 가지 방법은 기술적 배경이 없는 사람에게 기술적인 질문을 설명하는 것을 지켜보는 것입니다. 우리 모두는 그렇지 않으면 똑똑하지만, 이것에 있어서 우스꽝스러울 정도로 서투른 사람들을 알고 있을 것입니다. 만약 누군가가 저녁 파티에서 프로그래밍 언어가 무엇인지 묻는다면, 그들은 "오, 고수준 언어(high-level language)는 컴파일러가 객체 코드를 생성하기 위해 입력으로 사용하는 것입니다"와 같은 말을 할 것입니다.

고수준 언어? 컴파일러? 객체 코드? 프로그래밍 언어가 무엇인지 모르는 사람은 당연히 이것들이 무엇인지도 모를 것입니다.

소프트웨어가 해야 할 일의 일부는 자체적으로 설명하는 것입니다. 따라서 좋은 소프트웨어를 작성하려면 사용자들이 얼마나 이해를 못 하는지 이해해야 합니다. 그들은 준비 없이 소프트웨어에 다가갈 것이고, 설명서를 읽지 않을 것이므로 그들이 추측한 대로 작동하는 것이 좋습니다. 이 점에서 제가 본 최고의 시스템은 1985년의 오리지널 맥킨토시였습니다. 그것은 소프트웨어가 거의 하지 않는 일을 했습니다. 그냥 작동했습니다. [6]

소스 코드 역시 자체적으로 설명해야 합니다. 만약 사람들이 프로그래밍에 관해 단 하나의 인용문이라도 기억하게 할 수 있다면, 그것은 'Structure and Interpretation of Computer Programs'의 첫 부분에 있는 인용문일 것입니다. 프로그램은 기계의 실행을 부수적으로 고려할 뿐, 사람들이 읽을 수 있도록 작성되어야 합니다. 당신은 사용자뿐만 아니라 독자에 대한 공감 능력도 가져야 합니다. 그것은 당신의 이익을 위해서입니다. 왜냐하면 당신도 그들 중 하나가 될 것이기 때문입니다.

많은 해커들이 프로그램을 작성했지만, 육 개월 후에 다시 돌아와서는 그것이 어떻게 작동하는지 전혀 알 수 없다는 것을 발견했습니다. 저는 그러한 경험 후에 Perl을 그만두기로 맹세했다는 사람들을 몇 명 알고 있습니다. [7]

공감 능력 부족은 지능과 연관되어 있습니다. 어떤 곳에서는 그것에 대한 일종의 유행까지 있습니다. 하지만 저는 어떤 상관관계도 없다고 생각합니다. 공감 능력을 배우지 않고도 수학과 자연 과학에서 잘할 수 있으며, 이 분야의 사람들은 똑똑한 경향이 있어 두 가지 특성이 연관되게 되었습니다. 하지만 공감 능력이 떨어지는 멍청한 사람들도 많습니다. 토크쇼에 전화하는 사람들의 말을 들어보세요. 그들은 무엇이든 묻지만, 너무 빙빙 돌려 말해서 진행자가 질문을 바꾸어 말해야 하는 경우가 많습니다.

그렇다면 해킹이 회화와 같다면, 그것도 멋진(cool) 일일까요? 결국 인생은 한 번뿐입니다. 훌륭한 것을 작업하는 데 시간을 쓰는 것이 좋습니다.

불행하게도 이 질문에 답하기는 어렵습니다. 명성에는 항상 큰 시간 지연이 있습니다. 그것은 먼 별에서 오는 빛과 같습니다. 회화가 지금 명성을 얻고 있는 것은 오백 년 전에 위대한 작업을 했던 사람들 덕분입니다. 당시에는 아무도 이 그림들이 오늘날 우리가 생각하는 것만큼 중요하다고 생각하지 않았습니다. 우르비노 공작 페데리코 다 몬테펠트로가 나중에 Piero della Francesca의 그림 속 이상한 코를 가진 사람으로 주로 알려지게 될 것이라고 생각하는 것은 당시 사람들에게는 매우 이상했을 것입니다.

그래서 해킹이 지금은 회화만큼 멋지게 보이지 않는다고 인정하지만, 회화 자체도 전성기에는 지금처럼 멋지게 보이지 않았다는 것을 기억해야 합니다.

우리가 어느 정도 확신을 가지고 말할 수 있는 것은 이것이 해킹의 전성기라는 것입니다. 대부분의 분야에서 위대한 작업은 초기에 이루어집니다. 1430년에서 1500년 사이에 만들어진 그림들은 여전히 타의 추종을 불허합니다. 셰익스피어는 전문 연극이 막 태동하던 시기에 등장했으며, 그 이후 모든 극작가가 그의 그림자 속에서 살아야 할 정도로 그 매체를 발전시켰습니다. Albrecht Durer도 판화에서 같은 일을 했고, Jane Austen도 소설에서 그랬습니다.

반복해서 우리는 같은 패턴을 봅니다. 새로운 매체가 등장하면 사람들은 그것에 너무 흥분하여 첫 몇 세대에 걸쳐 그 가능성의 대부분을 탐구합니다. 해킹은 지금 이 단계에 있는 것 같습니다. Leonardo의 시대에 회화는 그의 작품이 그렇게 만들었던 것만큼 멋지지 않았습니다.

해킹이 얼마나 멋지게 될지는 우리가 이 새로운 매체로 무엇을 할 수 있는지에 달려 있을 것입니다.

[^1]: 사진이 회화에 가한 가장 큰 손상은 최고의 생계 수단을 죽였다는 사실일 수 있습니다. 역사상 위대한 화가들의 대다수는 초상화 작업을 통해 생계를 유지했습니다.
[^2]: Microsoft는 직원들이 자투리 시간에도 오픈 소스 프로젝트에 기여하는 것을 권장하지 않는다고 들었습니다. 하지만 최고의 해커들 중 많은 수가 현재 오픈 소스 프로젝트에서 활동하고 있기 때문에, 이러한 정책의 주된 효과는 그들이 최상급 프로그래머를 고용할 수 없게 될 것이라는 점일 수 있습니다.
[^3]: 대학에서 프로그래밍에 대해 배우는 것은 책이나 옷, 데이트에 대해 배우는 것과 매우 유사합니다. 고등학교 시절 당신의 형편없는 취향을 보여주는 것과 같습니다.
[^4]: 적용된 공감 능력의 예시입니다. Viaweb에서는 두 가지 대안 사이에서 결정할 수 없을 때, 경쟁사들이 가장 싫어할 것은 무엇일지 물었습니다. 한 시점에서 경쟁사는 기본적으로 쓸모없는 기능을 소프트웨어에 추가했지만, 그들이 가지고 있고 우리가 가지지 못한 몇 안 되는 기능 중 하나였기 때문에 언론에서 크게 홍보했습니다. 우리는 그 기능이 쓸모없다고 설명하려고 할 수도 있었지만, 우리가 직접 구현하는 것이 경쟁사를 더 짜증나게 할 것이라고 판단하여 그날 오후에 자체 버전을 만들었습니다.
[^5]: 텍스트 편집기와 컴파일러는 제외합니다. 해커들은 이러한 것들을 디자인하기 위해 공감 능력이 필요하지 않습니다. 왜냐하면 그들 자신이 일반적인 사용자들이기 때문입니다.
[^6]: 뭐, 거의 그렇습니다. 사용 가능한 RAM을 약간 초과하여 불편한 디스크 스와핑을 많이 유발했지만, 이는 몇 달 안에 추가 디스크 드라이브를 구매함으로써 해결될 수 있었습니다.
[^7]: 프로그램을 읽기 쉽게 만드는 방법은 주석으로 가득 채우는 것이 아닙니다. 저는 Abelson과 Sussman의 인용구를 한 단계 더 나아가고 싶습니다. 프로그래밍 언어는 알고리즘을 표현하기 위해 설계되어야 하며, 컴퓨터가 그것을 어떻게 실행하는지를 알려주는 것은 부수적인 것이어야 합니다. 훌륭한 프로그래밍 언어는 영어보다 소프트웨어를 설명하는 데 더 뛰어나야 합니다. 도로에 예상치 못한 급커브가 있는 부분에만 화살표가 있는 것처럼, 독자들에게 경고해야 할 종류의 엉성한 부분이 있을 때만 주석이 필요합니다.

이 글의 초안을 검토해 준 Trevor Blackwell, Robert Morris, Dan Giffin, Lisa Randall에게 감사드리며, 발표를 초청해 준 Henry Leitner와 Larry Finkelstein에게도 감사드립니다.