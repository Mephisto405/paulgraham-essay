# 간결함은 힘이다 (Succinctness is Power)

2002년 5월

찰스 배비지, 아이버슨의 튜링 어워드 강연에서 인용
> 대수적 기호로 작은 공간에 압축된 의미의 양은 우리가 그것의 도움으로 수행하는 추론을 용이하게 하는 또 다른 요소입니다.

LL1 메일링 리스트에서 영화 '너드의 복수(Revenge of the Nerds)'가 제기한 문제에 대한 토론 중, 폴 프레스코드(Paul Prescod)가 제 마음에 와닿는 말을 했습니다.

> 파이썬의 목표는 정규성(regularity)과 가독성(readability)이지, 간결함(succinctness)이 아니다.

표면적으로 보면 이것은 프로그래밍 언어에 대해 꽤나 비판적인 주장처럼 들립니다. 제가 보기엔 간결함이 곧 힘(power)과 같기 때문입니다.

만약 그렇다면, 위 주장을 다음과 같이 바꿔볼 수 있습니다.

> 파이썬의 목표는 정규성과 가독성이지, 힘이 아니다.

그리고 이것은 (설령 그것이 트레이드오프(tradeoff)일지라도) 당신이 원할 만한 트레이드오프는 아닐 것입니다. 파이썬의 목표가 프로그래밍 언어로서 효과적이지 않는 것이라고 말하는 것과 크게 다르지 않습니다.

간결함이 곧 힘일까요? 이것은 저에게 중요한 질문, 아마도 언어 설계에 관심 있는 사람에게는 가장 중요한 질문이며, 직접적으로 다뤄볼 가치가 있는 질문이라고 생각합니다. 아직 답이 명확히 '예'라고 확신하지는 못하지만, 시작하기에 좋은 가설인 것 같습니다.

## 가설 (Hypothesis)

제 가설은 간결함이 곧 힘이거나, 병리학적(pathological) 예외를 제외하면 동일하게 취급할 수 있을 만큼 가깝다는 것입니다.

간결함이야말로 프로그래밍 언어가 존재하는 이유라고 생각합니다. 컴퓨터는 기계어로 직접 명령을 받아도 똑같이 행복할 것입니다. 우리가 고수준 언어(high-level language)를 개발하는 수고를 감수하는 주된 이유는 지렛대 효과(leverage)를 얻기 위함이라고 생각합니다. 즉, 기계어로는 1000줄이 필요한 것을 고수준 언어로는 10줄로 말하고 (더 중요하게는 생각하고) 표현하기 위함입니다. 다시 말해, 고수준 언어의 핵심은 소스 코드를 더 작게 만드는 것입니다.

만약 더 작은 소스 코드가 고수준 언어의 목적이고, 어떤 것의 힘이 그 목적을 얼마나 잘 달성하느냐로 측정된다면, 프로그래밍 언어의 힘은 프로그램이 얼마나 작아지는지로 측정될 것입니다.

반대로, 프로그램을 작게 만들지 못하는 언어는 마치 잘 잘리지 않는 칼이나 읽기 어려운 인쇄물처럼, 프로그래밍 언어가 해야 할 일을 제대로 못 하고 있는 것입니다.

## 측정 지표 (Metrics)

어떤 의미에서 작다는 것일까요? 코드 크기의 가장 일반적인 측정 지표는 코드 라인 수(lines of code)입니다. 하지만 이 지표가 가장 일반적인 이유는 측정하기 가장 쉽기 때문이라고 생각합니다. 아무도 이것이 프로그램 길이의 진정한 시험이라고 진정으로 믿지는 않을 것입니다. 언어마다 한 줄에 얼마나 많은 것을 담아야 하는지에 대한 관습이 다릅니다. C언어에서는 많은 줄이 구분자(delimiter) 한두 개 외에는 아무것도 없습니다.

또 다른 쉬운 측정 지표는 프로그램의 문자 수이지만, 이것도 그리 좋지 않습니다. 어떤 언어(예를 들어, 펄(Perl))는 다른 언어보다 식별자(identifier)를 더 짧게 사용합니다.

프로그램 크기에 대한 더 나은 측정 지표는 '요소(element)'의 수라고 생각합니다. 여기서 요소는 소스 코드를 나타내는 트리를 그렸을 때 고유한 노드가 될 수 있는 모든 것을 의미합니다. 변수나 함수의 이름은 요소입니다. 정수나 부동소수점(floating-point) 수는 요소입니다. 리터럴 텍스트(literal text)의 한 부분은 요소입니다. 패턴의 요소나 형식 지시자(format directive)도 요소입니다. 새로운 블록도 요소입니다. 모호한 경우(예: -5는 두 개의 요소인가, 한 개의 요소인가?)도 있지만, 대부분의 언어에서 동일하므로 비교에 큰 영향을 미치지는 않는다고 생각합니다.

이 측정 지표는 더 구체화되어야 하고, 특정 언어의 경우 해석이 필요할 수도 있지만, 프로그램이 가진 부분의 수를 측정하려는 올바른 시도라고 생각합니다. 이 연습에서 그리게 될 트리는 프로그램을 구상하기 위해 머릿속에서 만들어야 하는 것이므로, 그 크기는 프로그램을 작성하거나 읽는 데 필요한 작업량에 비례한다고 생각합니다.

## 설계 (Design)

이러한 종류의 측정 지표는 여러 언어를 비교할 수 있게 해주지만, 적어도 저에게는 그것이 주된 가치는 아닙니다. 간결함 테스트의 주된 가치는 언어를 설계하는 데 지침이 된다는 점입니다.

언어 간의 가장 유용한 비교는 동일한 언어의 두 가지 잠재적 변형 간의 비교입니다. 프로그램을 더 짧게 만들기 위해 언어에서 무엇을 할 수 있을까?

만약 프로그램의 개념적 부하(conceptual load)가 그 복잡성에 비례하고, 주어진 프로그래머가 고정된 개념적 부하를 견딜 수 있다면, 이는 프로그래머가 가장 많은 것을 성취할 수 있도록 무엇을 할 수 있는가라는 질문과 동일합니다. 그리고 그것은 좋은 언어를 어떻게 설계할 수 있는가라는 질문과 동일하다고 생각합니다.

(덧붙여, "모든 언어는 동등하다"는 오래된 통설이 틀렸다는 것을 언어를 설계할 때보다 더 명백하게 보여주는 것은 없습니다. 새로운 언어를 설계할 때, 당신은 끊임없이 두 언어를 비교합니다. 즉, x를 했을 때의 언어와 x를 하지 않았을 때의 언어를 비교하여 어느 것이 더 나은지 결정합니다. 이것이 정말 의미 없는 질문이라면, 동전 던지기를 하는 게 나을 것입니다.)

간결함을 목표로 하는 것은 새로운 아이디어를 찾는 좋은 방법인 것 같습니다. 만약 여러 다른 프로그램을 더 짧게 만들 수 있는 어떤 것을 해낼 수 있다면, 그것은 우연이 아닐 것입니다. 아마도 유용한 새로운 추상화(abstraction)를 발견했을 것입니다. 심지어 반복되는 패턴을 소스 코드에서 찾아내는 프로그램을 작성하여 도움을 받을 수도 있습니다. 다른 언어들 중에서도 간결함으로 명성이 높은 언어들이 새로운 아이디어를 얻을 수 있는 대상이 될 것입니다. 포스(Forth), 조이(Joy), 아이콘(Icon) 같은 언어들이요.

## 비교 (Comparison)

제가 아는 한, 이러한 문제에 대해 처음으로 글을 쓴 사람은 프레드 브룩스(Fred Brooks)의 '미신적인 맨먼스(Mythical Man Month)'에서였습니다. 그는 프로그래머들이 언어와 관계없이 하루에 거의 같은 양의 코드를 생성하는 것 같다고 썼습니다.

제가 20대 초반에 이 글을 처음 읽었을 때, 그것은 저에게 큰 놀라움이었고 엄청난 의미를 담고 있는 듯했습니다. 그것은 (a) 소프트웨어를 더 빨리 작성하는 유일한 방법은 더 간결한 언어를 사용하는 것이고, (b) 이 수고를 감수하는 사람은 그렇게 하지 않는 경쟁자들을 훨씬 뒤처지게 만들 수 있다는 것을 의미했습니다. 브룩스의 가설이 사실이라면, 그것은 해킹(hacking)의 핵심에 있는 것 같습니다.

그 이후로 저는 이 질문에 대한 어떤 증거든지, 공식적인 연구부터 개별 프로젝트에 대한 일화까지, 면밀히 주시했습니다. 그를 반박하는 것은 아무것도 보지 못했습니다.

저는 아직 설득력 있다고 생각되는 증거를 보지 못했고, 앞으로도 기대하지 않습니다. Lutz Prechelt의 프로그래밍 언어 비교와 같은 연구는 제가 예상했던 결과를 내놓았지만, 의미 있는 테스트가 되기에는 너무 짧은 문제들을 사용하는 경향이 있습니다. 언어에 대한 더 나은 테스트는 한 달 동안 작성하는 프로그램에서 어떤 일이 일어나는가입니다. 그리고 제가 생각하듯, 언어의 주된 목적이 (컴퓨터에게 무엇을 해야 할지 생각한 후 지시하는 것만이 아니라) 생각하기에 좋다는 것이라면, 유일한 진정한 테스트는 그 언어로 어떤 새로운 것을 쓸 수 있는가입니다.

따라서 미리 정의된 사양을 충족해야 하는 모든 언어 비교는 약간 잘못된 것을 테스트하고 있는 것입니다.

언어의 진정한 테스트는 새로운 문제를 얼마나 잘 발견하고 해결할 수 있는가이지, 다른 사람이 이미 공식화한 문제를 해결하기 위해 언어를 얼마나 잘 사용할 수 있는가가 아닙니다. 이 두 가지는 상당히 다른 기준입니다.

예술에서 자수나 모자이크와 같은 매체는 만들고자 하는 것을 미리 알고 있을 때 잘 작동하지만, 그렇지 않을 때는 전혀 좋지 않습니다. 그림을 만들면서 이미지를 발견하고 싶을 때, 예를 들어 사람의 이미지처럼 복잡한 것을 만들 때, 연필이나 수묵화(ink wash), 유화(oil paint)와 같은 더 유동적인 매체를 사용해야 합니다. 실제로 태피스트리나 모자이크는 먼저 그림을 그린 다음 그것을 복사하는 방식으로 만들어집니다. ("만화(cartoon)"라는 단어는 원래 이러한 목적으로 만들어진 그림을 묘사하는 데 사용되었습니다.)

이것이 의미하는 바는 프로그래밍 언어의 상대적 힘에 대한 정확한 비교를 결코 얻을 수 없을 것이라는 점입니다. 우리는 정밀한 비교는 할 수 있지만, 정확한 비교는 할 수 없을 것입니다. 특히, 언어를 비교하기 위한 명시적인 연구는 작은 문제를 사용하고 미리 정의된 문제를 사용할 수밖에 없기 때문에, 더 강력한 언어의 힘을 과소평가하는 경향이 있을 것입니다.

"과학적" 연구보다 덜 정밀하겠지만, 현장에서의 보고는 더 의미가 있을 가능성이 높습니다. 예를 들어, 에릭슨(Ericsson)의 울프 비거(Ulf Wiger)는 에를랑(Erlang)이 C++보다 4~10배 더 간결하고 소프트웨어 개발 속도도 그에 비례하여 빠르다고 결론 내린 연구를 수행했습니다.

> 에릭슨 내부 개발 프로젝트 간의 비교는 사용된 언어(에를랑, PLEX, C, C++, 또는 자바)와 관계없이 소프트웨어 개발의 모든 단계를 포함하여 시간당 유사한 코드 라인 생산성을 보여줍니다. 그렇다면 다른 언어들을 구별하는 것은 소스 코드 볼륨이 됩니다.

이 연구는 또한 브룩스의 책에서 암시적으로만 다루어졌던 점(그는 디버그된 코드 라인을 측정했으므로)을 명시적으로 다루고 있습니다. 즉, 더 강력한 언어로 작성된 프로그램은 버그가 더 적은 경향이 있다는 것입니다. 이는 네트워크 스위치와 같은 애플리케이션에서는 프로그래머 생산성보다 더 중요할 수 있는 그 자체로 목적이 됩니다.

## 맛보기 테스트 (The Taste Test)

궁극적으로는 직감에 따라야 한다고 생각합니다. 언어로 프로그래밍하는 것이 어떤 느낌인가요? 최고의 언어를 찾거나 설계하는 방법은 언어가 사고를 얼마나 잘 돕는지에 대해 극도로 예민해진 다음, 가장 좋다고 느껴지는 언어를 선택/설계하는 것이라고 생각합니다. 만약 어떤 언어 기능이 서투르거나 제한적이라면, 걱정 마세요. 당신은 그것을 알게 될 것입니다.

이러한 과민성은 대가를 치르게 될 것입니다. 서투른 언어로 프로그래밍하는 것을 참을 수 없게 될 것입니다. 저는 매크로(macros)가 없는 언어로 프로그래밍하는 것을 참을 수 없을 정도로 제한적이라고 생각합니다. 동적 타이핑(dynamic typing)에 익숙한 사람이 모든 변수의 타입을 선언해야 하고 다른 타입의 객체 목록을 만들 수 없는 언어로 다시 프로그래밍해야 하는 것을 참을 수 없을 정도로 제한적이라고 느끼는 것과 마찬가지입니다.

저 혼자만이 아닙니다. 저는 이런 일을 겪은 많은 리스프(Lisp) 해커들을 알고 있습니다. 사실, 프로그래밍 언어의 상대적 힘을 가장 정확하게 측정하는 척도는 해당 언어를 아는 사람들 중 그 언어를 사용할 수 있는 직업이라면 애플리케이션 도메인과 관계없이 어떤 일이든 기꺼이 수락할 사람들의 비율일지도 모릅니다.

## 제한성 (Restrictiveness)

대부분의 해커들은 언어가 제한적이라는 것이 무엇을 의미하는지 알고 있다고 생각합니다. 그런 느낌이 들 때 무슨 일이 일어나는 걸까요? 저는 가고자 하는 길이 막혀서 목적지까지 한참 돌아가야 할 때와 같은 느낌이라고 생각합니다. 말하고 싶은 것이 있는데 언어가 허용하지 않는 것입니다.

여기서 실제로 일어나고 있는 일은, 제 생각에 제한적인 언어는 충분히 간결하지 않은 언어라는 것입니다. 문제는 단순히 계획했던 대로 말할 수 없다는 것이 아닙니다. 언어가 당신을 강요하는 우회로(detour)가 더 길다는 것입니다.

이러한 사고 실험을 시도해보세요. 당신이 쓰고 싶은 프로그램이 있는데, 언어가 계획했던 방식대로 표현하지 못하게 하고, 대신 더 짧은 다른 방식으로 프로그램을 쓰도록 강요한다고 가정해봅시다. 적어도 저에게는 그것이 그다지 제한적으로 느껴지지 않을 것입니다. 그것은 마치 가고자 하는 길이 막혔는데, 교차로의 경찰관이 우회로 대신 지름길을 알려주는 것과 같을 것입니다. 훌륭하죠!

제 생각에 제한적이라는 느낌의 대부분(90%?)은 머릿속에 있는 프로그램보다 언어로 작성하는 프로그램을 더 길게 만들어야 한다는 강요에서 오는 것 같습니다. 제한성은 대부분 간결함의 부족입니다.

따라서 언어가 제한적으로 느껴질 때, 그것이 (대부분) 의미하는 바는 충분히 간결하지 않다는 것이고, 언어가 간결하지 않으면 제한적으로 느껴질 것입니다.

## 가독성 (Readability)

제가 서두에서 언급한 인용문에는 두 가지 다른 특성, 즉 정규성과 가독성이 언급되어 있습니다. 정규성이 무엇인지, 또는 정규적이고 읽기 쉬운 코드가 단지 읽기 쉬운 코드에 비해 어떤 이점이 있는지 잘 모르겠습니다. 하지만 가독성이 무엇을 의미하는지는 알고 있으며, 그것 또한 간결함과 관련이 있다고 생각합니다.

여기서 우리는 개별 코드 라인의 가독성과 전체 프로그램의 가독성을 구분하는 데 주의해야 합니다. 중요한 것은 후자입니다. 베이직(Basic) 한 줄이 리스프 한 줄보다 더 읽기 쉬울 가능성이 높다는 데 동의합니다. 하지만 베이직으로 작성된 프로그램은 리스프로 작성된 동일한 프로그램보다 더 많은 줄을 가질 것입니다 (특히 Greenspunland로 넘어갈 경우). 베이직 프로그램을 읽는 데 드는 총 노력은 분명히 더 클 것입니다.

총 노력 = 줄당 노력 × 줄 수

가독성이 힘만큼 간결함에 직접적으로 비례하는지는 확실하지 않지만, 간결함은 분명히 가독성에 영향을 미치는 요소(수학적 의미에서, 위 방정식을 참조)입니다.

따라서 언어의 목표가 간결함이 아니라 가독성이라고 말하는 것은 의미가 없을 수도 있습니다. 마치 목표가 가독성이 아니라 가독성이라고 말하는 것과 같을 수 있습니다.

줄당 가독성(readability-per-line)이 사용자가 언어를 처음 접할 때 의미하는 바는 소스 코드가 위협적이지 않게 보일 것이라는 점입니다. 따라서 줄당 가독성은 좋은 마케팅 결정일 수 있지만, 나쁜 설계 결정일 수도 있습니다. 이는 사람들이 할부로 지불하게 하는 매우 성공적인 기술과 유사합니다. 높은 초기 가격으로 사람들을 겁주는 대신, 낮은 월별 지불액을 알려주는 것입니다. 하지만 할부 계획은 구매자에게 순손실을 가져다줍니다. 줄당 가독성 역시 프로그래머에게 그러할 것입니다.

구매자는 그 낮은 지불액을 많이 지불하게 될 것이고, 프로그래머는 개별적으로 읽기 쉬운 줄들을 많이 읽게 될 것입니다.

이러한 트레이드오프는 프로그래밍 언어 이전부터 존재했습니다. 소설이나 신문 기사를 읽는 데 익숙하다면, 수학 논문을 처음 읽을 때 실망할 수 있습니다. 한 페이지를 읽는 데 30분이나 걸릴 수도 있습니다. 하지만 저는 표기법이 문제가 아니라고 확신합니다. 비록 그렇게 느껴질지라도 말입니다. 수학 논문이 읽기 어려운 것은 아이디어가 어렵기 때문입니다. 만약 동일한 아이디어를 산문으로 표현한다면 (수학자들이 간결한 표기법을 발전시키기 전에 그랬던 것처럼), 읽기 더 쉬워지지 않을 것입니다. 논문이 책만큼 커질 것이기 때문입니다.

## 어느 정도까지? (To What Extent?)

많은 사람들이 간결함이 곧 힘이라는 생각을 거부해왔습니다. 단순히 같거나 같지 않다고 주장하기보다, 다음과 같이 묻는 것이 더 유용할 것이라고 생각합니다. 간결함이 힘과 어느 정도까지 같은가?

분명히 간결함은 고수준 언어가 존재하는 큰 부분입니다. 만약 그것이 전부가 아니라면, 다른 용도는 무엇이며, 상대적으로 이러한 다른 기능들이 얼마나 중요한가?

이것을 단지 논쟁을 더 문명화하기 위해 제안하는 것이 아닙니다. 저는 정말로 답을 알고 싶습니다. 언어가 자기 자신에게 너무 간결해지는 경우는 언제이며, 그런 경우가 있기는 한가?

제가 시작했던 가설은 병리학적 예외를 제외하면 간결함이 힘과 동일하게 간주될 수 있다는 것이었습니다. 제가 의미했던 것은 어떤 언어를 설계하든지 간에 그것들은 동일할 것이지만, 누군가가 이 가설을 명시적으로 반증하기 위해 언어를 설계한다면 아마도 그렇게 할 수 있을 것이라는 점이었습니다. 사실, 그것조차도 확신하지 못합니다.

## 언어, 프로그램이 아니다 (Languages, not Programs)

우리는 개별 프로그램의 간결함이 아니라 언어의 간결함에 대해 이야기하고 있다는 점을 분명히 해야 합니다.

개별 프로그램이 너무 밀도 높게 작성될 수 있다는 것은 확실히 가능합니다. 저는 이에 대해 '온 리스프(On Lisp)'에서 썼습니다. 복잡한 매크로는 그 자체 길이의 몇 배를 절약해야 정당화될 수 있습니다. 만약 복잡한 매크로를 작성하는 것이 매번 사용할 때마다 10줄의 코드를 절약할 수 있고, 매크로 자체가 10줄의 코드라면, 한 번 이상 사용할 경우 순수하게 줄 수가 절약됩니다. 하지만 이는 여전히 나쁜 결정일 수 있는데, 매크로 정의는 일반 코드보다 읽기 어렵기 때문입니다. 가독성에서 순수한 개선을 얻으려면 매크로를 10번 또는 20번 사용해야 할 수도 있습니다.

모든 언어에는 이런 트레이드오프가 있다고 확신합니다 (언어가 강력해질수록 그 중요성이 커진다고 생각하지만요). 모든 프로그래머는 영리한 사람이 의심스러운 프로그래밍 기법을 사용하여 미미하게 짧게 만든 코드를 본 적이 있을 것입니다.

따라서 그것에 대해서는 논쟁의 여지가 없습니다. 적어도 저에게는 말입니다. 개별 프로그램은 확실히 자기 자신에게 너무 간결할 수 있습니다. 문제는 언어 자체가 그럴 수 있는가입니다. 언어가 프로그래머에게 전반적인 가독성을 희생시키면서 코드를 짧게 (요소 측면에서) 작성하도록 강요할 수 있는가?

언어가 너무 간결하다고 상상하기 어려운 한 가지 이유는, 만약 어떤 표현 방식이 지나치게 압축적이라면, 아마도 더 긴 방식도 있을 것이기 때문입니다. 예를 들어, 많은 매크로나 고차 함수(higher-order function)를 사용하는 리스프 프로그램이 너무 밀집되어 있다고 느낀다면, 원한다면 파스칼(Pascal)과 동형(isomorphic)인 코드를 작성할 수 있습니다. 팩토리얼(factorial)을 Arc에서 고차 함수 호출로 표현하고 싶지 않다면 (`(rec zero 1 * 1-)`), 재귀 정의를 직접 작성할 수도 있습니다.

```
(rfn fact (x) (if (zero x) 1 (* x (fact (1- x)))))
```

지금 당장은 어떤 예도 떠오르지 않지만, 언어가 너무 간결할 수 있는지에 대한 질문에 관심이 있습니다. 코드를 찌그러지고 이해할 수 없는 방식으로 작성하도록 강요하는 언어가 있을까요? 만약 그런 예시를 가지고 계시다면, 꼭 보고 싶습니다.

(참고: 제가 찾고 있는 것은 위에서 스케치한 "요소" 측정 지표에 따라 매우 밀집된 프로그램입니다. 구분자를 생략할 수 있고 모든 것이 한 문자 이름이기 때문에 단순히 짧은 프로그램이 아닙니다.)