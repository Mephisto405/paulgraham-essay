# 간결함은 힘이다 (Succinctness is Power)

2002년 5월

"대수 기호가 작은 공간에 압축하는 의미의 양은 우리가 그것을 도움으로 수행하는 추론을 용이하게 하는 또 다른 요소입니다."
- 찰스 배비지 (Iverson의 튜링상 강연 인용)

LL1 메일링 리스트에서 '리벤지 오브 더 너즈(Revenge of the Nerds)'[^1]가 제기한 문제에 대한 논의 중에 폴 프레스코드(Paul Prescod)가 제 마음에 남는 글을 썼습니다.
파이썬의 목표는 간결함이 아니라 규칙성과 가독성입니다.
표면적으로 볼 때, 이것은 프로그래밍 언어에 대해 주장하기에는 다소 치명적인 말처럼 보입니다. 제가 알기로는 간결함은 힘과 같습니다.
그렇다면 대입하면, 파이썬의 목표는 규칙성과 가독성이지 힘이 아니라는 결과가 나옵니다.
그리고 이것은 (만약 트레이드오프라면) 하고 싶지 않은 절충처럼 보입니다.
이는 파이썬의 목표가 프로그래밍 언어로서 효과적이지 않은 것이라고 말하는 것과 크게 다르지 않습니다.

## 간결함은 힘인가?

간결함은 힘인가? 이것은 언어 설계에 관심 있는 사람에게는 가장 중요한 질문일지도 모르며, 직접적으로 마주하는 것이 유용할 질문이라고 생각합니다.
아직 그 답이 단순한 '예'라고 확신하지는 못하지만, 시작하기 좋은 가설처럼 보입니다.

## 가설

제 가설은 간결함이 힘이거나, 병적인 사례를 제외하고는 그것들을 동일하게 취급할 수 있을 만큼 충분히 가깝다는 것입니다.
제 생각에 간결함은 프로그래밍 언어가 존재하는 이유입니다.
컴퓨터는 기계어(machine language)로 직접 무엇을 해야 할지 지시받는 것을 똑같이 기뻐할 것입니다.
저는 우리가 고급 언어(high-level language)를 개발하는 주된 이유는 레버리지(leverage)[^2]를 얻기 위해서라고 생각합니다. 즉, 고급 언어 10줄로 기계어 1000줄이 필요한 것을 말하고 (더 중요하게는 생각하고) 할 수 있도록 말입니다.
다시 말해, 고급 언어의 핵심은 소스 코드(source code)를 더 작게 만드는 것입니다.
만약 더 작은 소스 코드가 고급 언어의 목적이고, 어떤 것의 힘이 그 목적을 얼마나 잘 달성하는가라면, 프로그래밍 언어의 힘의 척도는 그 언어가 여러분의 프로그램을 얼마나 작게 만드는가입니다.
반대로, 여러분의 프로그램을 작게 만들지 못하는 언어는 잘 잘리지 않는 칼이나 읽을 수 없는 인쇄물처럼, 프로그래밍 언어가 해야 할 일을 제대로 하지 못하는 것입니다.

## 척도

하지만 어떤 의미에서 작다는 것일까요? 코드 크기의 가장 흔한 척도는 코드 라인(lines of code)입니다.
하지만 이 척도가 가장 흔한 이유는 측정하기 가장 쉽기 때문이라고 생각합니다.
아무도 이것이 프로그램 길이의 진정한 테스트라고 진정으로 믿는다고 생각하지 않습니다.
각 언어마다 한 줄에 얼마나 많은 것을 넣어야 하는지에 대한 다른 규약이 있습니다. C에서는 많은 줄이 구분 기호(delimiter) 외에는 아무것도 담고 있지 않습니다.
또 다른 쉬운 테스트는 프로그램의 문자 수(number of characters)이지만, 이것 역시 그다지 좋지 않습니다. 어떤 언어(예: Perl)는 단순히 다른 언어보다 더 짧은 식별자(identifier)를 사용합니다.
제 생각에 프로그램 크기의 더 나은 척도는 요소(element)의 수일 것입니다. 여기서 요소는 소스 코드를 나타내는 트리를 그린다면 별개의 노드(node)가 될 수 있는 모든 것입니다.
변수나 함수의 이름은 요소입니다.
정수나 부동 소수점 숫자(floating-point number)는 요소입니다.
리터럴 텍스트(literal text) 조각은 요소입니다.
패턴(pattern)의 요소, 또는 형식 지시자(format directive)는 요소입니다.
새로운 블록(block)은 요소입니다.
경계 사례도 있습니다 (-5는 두 요소인가 아니면 한 요소인가?). 하지만 대부분의 경우는 모든 언어에 동일하므로 비교에 크게 영향을 미치지 않는다고 생각합니다.
이 척도는 더 구체화될 필요가 있으며 특정 언어의 경우 해석이 필요할 수도 있지만, 프로그램이 가진 부분의 수, 즉 올바른 것을 측정하려 한다고 생각합니다.
이 연습에서 그릴 트리는 프로그램을 구상하기 위해 머릿속으로 만들어야 하는 것이며, 따라서 그 크기는 작성하거나 읽는 데 해야 하는 작업량에 비례한다고 생각합니다.

## 설계

이러한 종류의 척도는 다른 언어를 비교할 수 있게 해주지만, 적어도 저에게는 그것이 주요 가치는 아닙니다.
간결성 테스트의 주요 가치는 언어 설계에 대한 지침입니다.
언어 간의 가장 유용한 비교는 동일한 언어의 두 가지 잠재적 변형 간의 비교입니다.
프로그램을 더 짧게 만들기 위해 언어에서 무엇을 할 수 있을까요?
프로그램의 개념적 부하(conceptual load)[^3]가 복잡성에 비례하고, 특정 프로그래머가 고정된 개념적 부하를 감당할 수 있다면, 이는 프로그래머가 가장 많은 일을 할 수 있도록 무엇을 할 수 있는가라고 묻는 것과 같습니다.
그리고 그것은 좋은 언어를 어떻게 설계할 수 있는가라고 묻는 것과 동일하다고 생각합니다.
(덧붙여 말하자면, 언어를 설계하는 것보다 '모든 언어는 동등하다'는 오래된 상투적인 말이 거짓이라는 것을 더 명백하게 만드는 것은 없습니다.
새로운 언어를 설계할 때, 여러분은 끊임없이 두 가지 언어를 비교합니다. 즉, x를 했을 때의 언어와 하지 않았을 때의 언어를 비교하여 어느 것이 더 나은지 결정합니다.
이것이 정말 의미 없는 질문이라면, 동전 던지기를 하는 것과 마찬가지일 것입니다.)
간결함을 목표로 하는 것은 새로운 아이디어를 찾는 좋은 방법처럼 보입니다.
만약 여러분이 다양한 프로그램을 더 짧게 만드는 무언가를 할 수 있다면, 그것은 아마 우연이 아닐 것입니다. 아마 유용한 새로운 추상화(abstraction)를 발견한 것입니다.
반복되는 패턴에 대해 소스 코드를 검색하여 돕는 프로그램을 작성할 수도 있을 것입니다.
다른 언어들 중에서도 간결성으로 명성이 높은 언어들이 새로운 아이디어를 얻기 위해 살펴보아야 할 대상일 것입니다. Forth, Joy, Icon 등이 그렇습니다.

## 비교

제가 알기로 이 문제들에 대해 처음으로 글을 쓴 사람은 '미시컬 맨 먼스(The Mythical Man-Month)'[^4]의 프레드 브룩스(Fred Brooks)였습니다.
그는 프로그래머들이 언어에 관계없이 하루에 거의 같은 양의 코드를 생성하는 것 같다고 썼습니다.
20대 초반에 이것을 처음 읽었을 때, 제게는 큰 놀라움이었고 엄청난 함의를 가진 것처럼 보였습니다.
이는 (a) 소프트웨어를 더 빨리 작성하는 유일한 방법은 더 간결한 언어를 사용하는 것이었고, (b) 그렇게 하는 수고를 들인 사람은 그렇지 않은 경쟁자들을 따돌릴 수 있다는 것을 의미했습니다.
브룩스의 가설이 사실이라면, 그것은 해킹(hacking)의 핵심에 있는 것으로 보입니다.
그 이후로 수년 동안, 저는 공식 연구부터 개별 프로젝트에 대한 일화까지, 이 질문에 대해 얻을 수 있는 모든 증거에 면밀히 주의를 기울였습니다.
저는 그를 반박할 만한 어떤 것도 보지 못했습니다.
저는 아직 저에게 결정적으로 보이는 증거를 보지 못했고, 앞으로도 그럴 것으로 예상하지 않습니다.
Lutz Prechelt의 프로그래밍 언어 비교와 같은 연구는 제가 예상했던 종류의 결과를 생성하지만, 의미 있는 테스트를 하기에는 너무 짧은 문제를 사용하는 경향이 있습니다.
언어에 대한 더 나은 테스트는 작성하는 데 한 달이 걸리는 프로그램에서 일어나는 일입니다.
그리고 언어의 주된 목적은 (이미 생각한 것을 컴퓨터에 지시하는 것뿐만 아니라) 생각하기에 좋은 것이라고 믿는 저와 같이 생각한다면, 유일한 진정한 테스트는 그 언어로 무엇을 새롭게 쓸 수 있는가입니다.
따라서 미리 정의된 스펙(spec)을 충족해야 하는 모든 언어 비교는 약간 잘못된 것을 테스트하는 것입니다.
언어의 진정한 테스트는 다른 사람이 이미 공식화한 문제를 해결하기 위해 얼마나 잘 사용할 수 있는가가 아니라, 얼마나 잘 새로운 문제를 발견하고 해결할 수 있는가입니다.
이 두 가지는 상당히 다른 기준입니다.
예술에서 자수(embroidery)나 모자이크(mosaic)와 같은 매체는 미리 무엇을 만들고 싶은지 안다면 잘 작동하지만, 그렇지 않다면 절대적으로 형편없습니다.
만들면서 이미지를 발견하고 싶을 때 - 예를 들어 사람의 이미지처럼 복잡한 모든 것에 대해 해야 하는 것처럼 - 연필, 수묵화(ink wash), 또는 유화(oil paint)와 같은 더 유동적인 매체를 사용할 필요가 있습니다.
실제로 태피스트리(tapestry)와 모자이크를 만드는 방식은 먼저 그림을 그린 다음 그것을 복사하는 것입니다.
(카툰(cartoon)이라는 단어는 원래 이러한 목적을 위한 그림을 설명하는 데 사용되었습니다.)
이것이 의미하는 바는 우리는 프로그래밍 언어의 상대적 힘에 대한 정확한 비교를 결코 갖지 못할 가능성이 높다는 것입니다.
우리는 정확한 비교를 갖겠지만, 정확하지는 않을 것입니다.
특히, 언어를 비교하기 위한 명시적인 연구는 아마도 작은 문제를 사용하고, 필연적으로 미리 정의된 문제를 사용할 것이기 때문에, 더 강력한 언어들의 힘을 과소평가하는 경향이 있을 것입니다.
현장의 보고서는 '과학적' 연구보다 필연적으로 덜 정확하겠지만, 더 의미 있을 가능성이 높습니다.
예를 들어, Ericsson의 Ulf Wiger는 Erlang이 C++보다 4-10배 더 간결하며, 소프트웨어 개발 속도도 그에 비례하여 빠르다는 결론을 내린 연구를 수행했습니다:
Ericsson 내부 개발 프로젝트 간의 비교는 Erlang, PLEX, C, C++ 또는 Java 중 어떤 언어가 사용되었는지에 비교적 독립적으로, 소프트웨어 개발의 모든 단계를 포함하여 유사한 라인/시간당 생산성을 나타냅니다.
그렇다면 다양한 언어를 구별하는 것은 소스 코드의 양이 됩니다.
이 연구는 브룩스의 책에서 암묵적이었던 (그는 디버깅된 코드 라인을 측정했기 때문에) 한 가지 사항을 명시적으로 다룹니다. 더 강력한 언어로 작성된 프로그램은 버그(bug)가 적은 경향이 있다는 것입니다.
그것은 네트워크 스위치와 같은 애플리케이션에서는 프로그래머 생산성보다 더 중요할 수 있는 그 자체의 목적이 됩니다.

## 맛 테스트 (The Taste Test)

궁극적으로는 직감(gut)에 따라야 한다고 생각합니다.
그 언어로 프로그래밍하는 것이 어떤 느낌인가?
최고의 언어를 찾거나(또는 설계하는) 방법은 언어가 얼마나 잘 생각하게 해주는지에 대해 극도로 민감해진 다음, 가장 좋다고 느껴지는 언어를 선택/설계하는 것이라고 생각합니다.
만약 어떤 언어 기능이 어색하거나 제한적이라면, 걱정하지 마세요. 그것을 알게 될 것입니다.
그러한 극도의 민감성은 대가를 치를 것입니다.
서투른 언어(clumsy languages)로 프로그래밍하는 것을 견딜 수 없게 될 것입니다.
저는 매크로(macro)가 없는 언어로 프로그래밍하는 것이 참을 수 없을 정도로 제한적이라고 생각합니다. 마치 동적 타이핑(dynamic typing)에 익숙한 사람이 모든 변수의 타입을 선언해야 하고 다른 타입의 객체 목록을 만들 수 없는 언어로 다시 프로그래밍해야 하는 것이 참을 수 없을 정도로 제한적이라고 느끼는 것처럼 말입니다.
저만 그런 것은 아닙니다.
저는 이런 일을 겪은 많은 Lisp 해커(hacker)를 알고 있습니다.
사실, 프로그래밍 언어의 상대적 힘을 가장 정확하게 측정하는 방법은 해당 언어를 아는 사람들 중, 애플리케이션 도메인에 관계없이 그 언어를 사용할 수 있는 모든 일자리를 수락할 사람들의 비율일 것입니다.

## 제한성 (Restrictiveness)

대부분의 해커들은 언어가 제한적으로 느껴지는 것이 무엇을 의미하는지 알고 있다고 생각합니다.
그럴 때 무엇이 일어나고 있는 것일까요?
가고 싶은 길이 막혀 있어서 목적지에 도착하기 위해 긴 우회로(detour)를 타야 할 때 느끼는 감정과 같다고 생각합니다.
말하고 싶은 무언가가 있는데, 언어가 당신을 허락하지 않는 것입니다.
제가 생각하기에 여기서 실제로 일어나고 있는 일은 제한적인 언어는 충분히 간결하지 않은 언어라는 것입니다.
문제는 단순히 계획했던 것을 말할 수 없다는 것이 아닙니다.
언어가 당신을 가게 만드는 우회로가 더 길다는 것입니다.
이 사고 실험(thought experiment)을 해보십시오.
만약 당신이 쓰고 싶은 프로그램이 있고, 언어가 당신이 계획한 대로 그것을 표현하도록 허용하지 않고, 대신 더 짧은 다른 방식으로 프로그램을 작성하도록 강요한다면 어떻게 될까요?
적어도 제게는 그것이 그다지 제한적으로 느껴지지 않을 것입니다.
그것은 가고 싶었던 길이 막혔는데, 교차로의 경찰관이 우회로 대신 지름길(shortcut)을 안내하는 것과 같을 것입니다.
훌륭합니다!
제 생각에 제한적이라는 느낌의 대부분(90%?)은 머릿속에 있는 프로그램보다 언어로 작성하는 프로그램을 더 길게 만들도록 강요받는 것에서 비롯됩니다.
제한성은 대부분 간결성의 부족입니다.
따라서 언어가 제한적으로 느껴진다는 것은 (대부분) 그것이 충분히 간결하지 않다는 것을 의미하며, 언어가 간결하지 않으면 제한적으로 느껴질 것입니다.

## 가독성 (Readability)

제가 처음에 인용한 글은 규칙성(regularity)과 가독성(readability)이라는 두 가지 다른 품질을 언급합니다.
규칙성이 무엇인지, 또는 규칙적이고 읽기 쉬운 코드가 단순히 읽기 쉬운 코드에 비해 어떤 이점이 있는지 확실하지 않습니다.
하지만 가독성이 무엇을 의미하는지는 알고 있다고 생각하며, 그것은 간결성과도 관련이 있다고 생각합니다.
여기서 개별 코드 줄의 가독성과 전체 프로그램의 가독성을 구별해야 합니다.
중요한 것은 후자입니다.
Basic 한 줄이 Lisp 한 줄보다 더 읽기 쉬울 것이라는 데 동의합니다.
하지만 Basic으로 작성된 프로그램은 (특히 Greenspunland[^5]를 넘어서면) Lisp으로 작성된 동일한 프로그램보다 더 많은 줄을 갖게 될 것입니다.
Basic 프로그램 전체를 읽는 데 드는 총 노력은 분명히 더 클 것입니다.
총 노력 = 줄당 노력 x 줄의 수
힘이 간결성에 정비례한다고 확신하는 것만큼 가독성이 간결성에 정비례한다고 확신하지는 않지만, 간결성은 분명 가독성의 (수학적 의미에서; 위 방정식 참조) 요인입니다.
따라서 언어의 목표가 간결함이 아니라 가독성이라고 말하는 것은 의미가 없을 수도 있습니다. 그것은 마치 목표가 가독성이 아니라 가독성이라고 말하는 것과 같을 수 있습니다.
줄당 가독성(readability-per-line)이 처음 언어를 접하는 사용자에게 의미하는 바는 소스 코드가 위협적으로 보이지 않는다는 것입니다.
따라서 줄당 가독성은 좋지 않은 설계 결정일지라도 좋은 마케팅 결정이 될 수 있습니다.
이는 할부(installments)[^6]로 결제하게 하는 매우 성공적인 기술과 동일형(isomorphic)[^7]입니다. 높은 선불 가격으로 겁주는 대신, 낮은 월별 납부액을 알려주는 것이죠.
하지만 할부 계획은 구매자에게 순손실(net lose)이며, 단순한 줄당 가독성도 프로그래머에게 그럴 가능성이 높습니다.
구매자는 수많은 저렴한 납부금을 내게 될 것이며, 프로그래머는 개별적으로 읽기 쉬운 수많은 줄을 읽게 될 것입니다.
이러한 트레이드오프는 프로그래밍 언어보다 앞섭니다.
소설이나 신문 기사를 읽는 데 익숙하다면, 수학 논문을 처음 읽는 경험은 실망스러울 수 있습니다.
한 페이지를 읽는 데 30분이 걸릴 수도 있습니다.
하지만 표기법(notation)이 문제가 아니라고 거의 확신합니다. 비록 그것이 문제처럼 느껴질지라도 말입니다.
수학 논문이 읽기 어려운 이유는 아이디어 자체가 어렵기 때문입니다.
만약 당신이 같은 아이디어를 산문(prose)[^8]으로 표현했다면 (수학자들이 간결한 표기법을 발전시키기 전에 해야 했던 것처럼), 그 아이디어는 더 쉬워지지 않을 것입니다. 왜냐하면 논문이 책 한 권의 크기로 늘어날 것이기 때문입니다.

## 어느 정도까지? (To What Extent?)

많은 사람들이 간결함 = 힘이라는 생각에 반대해왔습니다.
그것들이 같거나 같지 않다고 단순히 주장하기보다는, 간결함은 어느 정도까지 힘인가? 라고 묻는 것이 더 유용하다고 생각합니다.
분명히 간결함은 고급 언어가 존재하는 이유의 큰 부분을 차지하기 때문입니다.
만약 그것이 전부는 아니라면, 그들은 무엇을 위해 존재하며, 상대적으로 이러한 다른 기능들은 얼마나 중요한가요?
저는 단지 논쟁을 더 예의 바르게 만들기 위해 이것을 제안하는 것이 아닙니다. 저는 정말 답을 알고 싶습니다.
언제가, 또는 언제 언어가 자신에게 너무 간결해질까요?
제가 시작했던 가설은 병적인 사례를 제외하고는 간결성을 힘과 동일시할 수 있다고 생각했다는 것입니다.
제가 의미했던 바는 누구든 설계할 언어에서는 그것들이 동일할 것이지만, 누군가가 이 가설을 반증하기 위해 명시적으로 언어를 설계하려고 한다면, 아마도 그렇게 할 수 있을 것이라는 점입니다.
사실 저는 그것조차 확신하지 못합니다.

## 언어, 프로그램이 아니라 (Languages, not Programs)

우리는 개별 프로그램의 간결성이 아니라 언어 자체의 간결성에 대해 이야기하고 있다는 점을 명확히 해야 합니다.
개별 프로그램이 너무 밀도 높게 작성될 수 있는 것은 확실히 가능합니다.
저는 '온 리스프(On Lisp)'[^9]에서 이 점을 다루었습니다.
복잡한 매크로는 정당화되기 위해 자신의 길이의 여러 배를 절약해야 할 수도 있습니다.
만약 까다로운(hairy)[^10] 매크로를 작성하는 것이 사용할 때마다 10줄의 코드를 절약해 준다면, 그리고 그 매크로 자체가 10줄의 코드라면, 그것을 한 번 이상 사용하면 줄 수에서 순이익을 얻게 됩니다.
하지만 매크로 정의는 일반 코드보다 읽기 어렵기 때문에, 그것은 여전히 나쁜 선택일 수 있습니다.
가독성에서 순이익을 얻으려면 매크로를 10번이나 20번 사용해야 할 수도 있습니다.
모든 언어에는 이러한 트레이드오프가 있다고 확신하지만 (언어가 더 강력해질수록 그 위험이 커진다고 생각합니다).
모든 프로그래머는 어떤 똑똑한 사람이 의심스러운 프로그래밍 트릭(dubious programming tricks)[^11]을 사용하여 코드를 약간 더 짧게 만든 것을 본 적이 있을 것입니다.
그래서 그것에 대해서는 논쟁의 여지가 없습니다. 적어도 제게는 말입니다.
개별 프로그램이 지나치게 간결하여 좋지 않을 수 있다는 것은 확실합니다.
질문은, 언어가 그럴 수 있는가? 입니다.
언어가 전체적인 가독성을 희생시키면서 (요소 면에서) 짧은 코드를 작성하도록 프로그래머를 강요할 수 있을까요?
언어가 지나치게 간결하다고 상상하기 어려운 한 가지 이유는, 무언가를 표현하는 지나치게 압축된 방법이 있다면, 아마도 더 긴 방법도 존재하기 때문입니다.
예를 들어, Lisp 프로그램이 많은 매크로(macros)나 고차 함수(higher-order functions)[^12]를 사용하여 너무 밀집되어 있다고 느낀다면, 선호한다면 Pascal과 동일형(isomorphic)[^7]인 코드를 작성할 수 있습니다.
Arc에서 팩토리얼(factorial)을 고차 함수 호출로 표현하고 싶지 않다면 (rec zero 1 * 1-)
재귀적 정의(recursive definition)를 작성할 수도 있습니다.
(rfn fact (x) (if (zero x) 1 (* x (fact (1- x)))))
즉석에서 예를 들 수는 없지만, 언어가 지나치게 간결할 수 있는지 여부에 대한 질문에 관심이 있습니다.
코드를 난해한(crabbed)[^13] 방식으로 작성하도록 강요하는 언어가 있습니까?
누구든 예시를 가지고 있다면, 저는 그것을 보는 데 매우 관심이 있을 것입니다.
(알림: 제가 찾고 있는 것은 위에 스케치한 '요소' 척도에 따라 매우 밀도 높은 프로그램이지, 구분 기호가 생략될 수 있고 모든 것이 한 글자 이름이어서 단순히 짧은 프로그램이 아닙니다.)

[^1]: Revenge of the Nerds
[^2]: leverage
[^3]: conceptual load
[^4]: The Mythical Man-Month
[^5]: Greenspunland
[^6]: installments
[^7]: isomorphic
[^8]: prose
[^9]: On Lisp
[^10]: hairy
[^11]: dubious programming tricks
[^12]: higher-order functions
[^13]: crabbed