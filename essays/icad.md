# 너드들의 역습 (Revenge of the Nerds)

스타트업을 시작하고 싶으신가요? Y Combinator에서 투자를 받으세요.

2002년 5월

"우리는 C++ 프로그래머들을 노렸습니다. 우리는 그들 중 많은 수를 리스프의 절반 지점까지 끌어오는 데 성공했습니다."
- 가이 스틸, 자바 명세 공동 저자

소프트웨어 업계에는 융통성 없는 상사들과, 이에 못지않게 강력한 다른 세력인 뾰족머리 학자들이 벌이는 끊임없는 투쟁이 있습니다. 누구나 융통성 없는 상사가 누구인지 알 것입니다, 그렇죠? 저는 기술 세계에 있는 대부분의 사람들이 이 만화 캐릭터를 인식할 뿐만 아니라, 그가 모델링된 실제 회사의 인물을 알고 있다고 생각합니다.

융통성 없는 상사는 개별적으로는 흔하지만 함께 보기 어려운 두 가지 특성을 기적적으로 결합합니다.
(a) 그는 기술에 대해선 아무것도 모르지만,
(b) 그것에 대해선 매우 강한 의견을 가지고 있습니다.

예를 들어, 소프트웨어 조각을 작성해야 한다고 가정해 봅시다. 융통성 없는 상사는 이 소프트웨어가 어떻게 작동해야 하는지에 대해 전혀 모르고, 프로그래밍 언어를 다른 것과 구분하지 못하면서도, 당신이 어떤 언어로 작성해야 하는지 알고 있습니다.

정확히 그렇습니다. 그는 당신이 Java로 작성해야 한다고 생각합니다.

그는 왜 그렇게 생각할까요? 융통성 없는 상사의 머릿속을 들여다봅시다. 그가 생각하는 것은 대략 이렇습니다. 'Java는 표준이다. 나는 그것이 틀림없다고 안다. 왜냐하면 나는 언론에서 그것에 대해 계속 읽었기 때문이다. 표준이기 때문에, 나는 그것을 사용하는 데 문제가 없을 것이다. 그리고 그것은 또한 항상 수많은 Java 프로그래머가 있을 것이라는 뜻이기도 하다. 따라서 지금 나를 위해 일하는 프로그래머들이 그만둔다면, 나를 위해 일하는 프로그래머들은 불가사의하게도 항상 그렇듯이, 나는 그들을 쉽게 교체할 수 있을 것이다.'

음, 이것은 그다지 불합리하게 들리지 않습니다. 하지만 그것은 모두 하나의 암묵적인 가정에 근거하고 있으며, 그 가정은 사실이 아닌 것으로 밝혀집니다. 융통성 없는 상사는 모든 프로그래밍 언어가 거의 동등하다고 믿습니다.

만약 그것이 사실이라면, 그는 정확히 맞을 것입니다. 만약 언어들이 모두 동등하다면, 물론, 다른 사람들이 사용하는 언어를 사용하십시오.

하지만 모든 언어가 동등한 것은 아니며, 저는 그 차이점들조차도 논하지 않고 이것을 당신에게 증명할 수 있다고 생각합니다.

만약 당신이 1992년에 융통성 없는 상사에게 어떤 언어로 소프트웨어를 작성해야 하는지 물었다면, 그는 오늘날 그가 대답하는 것과 똑같은 망설임 없이 대답했을 것입니다. '소프트웨어는 C++로 작성되어야 한다.' 하지만 만약 언어들이 모두 동등하다면, 왜 융통성 없는 상사의 의견은 ever change 해야 할까요? 사실, Java 개발자들은 새로운 언어를 만드는 데 애초에 왜 수고를 해야 했을까요?

추측컨대, 새로운 언어를 만든다면, 그것이 사람들이 이미 가지고 있던 것보다 어떤 면에서 더 낫다고 생각하기 때문일 것입니다. 그리고 사실, 고슬링은 최초의 Java 백서에서 Java가 C++의 일부 문제를 해결하기 위해 설계되었다는 것을 명확히 합니다.

그러니 답은 나왔습니다. 언어들은 동등하지 않습니다. 만약 당신이 융통성 없는 상사의 뇌를 통해 Java로 가는 길을 따라가고, 다시 Java의 역사를 통해 그 기원으로 거슬러 올라간다면, 당신은 시작했던 가정과 모순되는 아이디어를 손에 쥐게 될 것입니다.

그렇다면 누가 맞을까요? 제임스 고슬링일까요, 아니면 융통성 없는 상사일까요?

놀랍지도 않게, 고슬링이 맞습니다. 어떤 언어들은 특정 문제에 대해 다른 언어들보다 더 낫습니다. 그리고 아시다시피, 그것은 몇 가지 흥미로운 질문을 제기합니다. Java는 C++보다 특정 문제에 대해 더 낫도록 설계되었습니다. 어떤 문제들일까요? 언제 Java가 더 낫고 언제 C++가 더 나을까요? 다른 언어들이 이 둘보다 더 나은 상황들이 있을까요?

이 질문을 고려하기 시작하면, 정말 골치 아픈 문제가 됩니다. 만약 융통성 없는 상사가 문제의 전체 복잡성을 고려해야 한다면, 그의 뇌는 폭발할 것입니다. 그가 모든 언어를 동등하다고 고려하는 한, 그가 해야 할 일은 가장 모멘텀이 있는 것처럼 보이는 것을 선택하는 것입니다. 그리고 그것은 기술보다는 유행의 문제이기 때문에, 심지어 그 자신도 아마 올바른 답을 얻을 수 있을 것입니다.

하지만 만약 언어들이 다르다면, 그는 갑자기 두 개의 동시 방정식을 풀어야 합니다. 그가 전혀 모르는 두 가지 사이의 최적 균형을 찾으려고 노력하면서 말이죠: 즉, 스무 개 정도의 주요 언어들이 그가 해결해야 할 문제에 대해 상대적으로 얼마나 적합한지, 그리고 각 언어에 대해 프로그래머와 라이브러리를 찾을 확률은 얼마인지.

만약 그것이 문의 다른 편에 있는 것이라면, 융통성 없는 상사가 그것을 열고 싶어하지 않는 것은 놀라운 일이 아닙니다.

모든 프로그래밍 언어가 동등하다고 믿는 것의 단점은 그것이 사실이 아니라는 것입니다. 하지만 장점은 그것이 당신의 삶을 훨씬 더 단순하게 만든다는 것입니다.

그리고 저는 그것이 그 아이디어가 그렇게 널리 퍼진 주된 이유라고 생각합니다. 그것은 편안한 생각입니다.

Java는 꽤 괜찮아야 한다는 것을 우리는 압니다. 왜냐하면 그것은 멋지고 새로운 프로그래밍 언어이기 때문입니다. 아니면 그런가요? 만약 당신이 프로그래밍 언어의 세계를 멀리서 바라본다면, Java가 최신이라고 보일 것입니다. (충분히 멀리서 보면, 당신이 볼 수 있는 것은 Sun이 지불한 크고 번쩍이는 광고판뿐입니다.)

하지만 만약 당신이 이 세계를 가까이서 본다면, 멋짐의 정도가 있다는 것을 알게 될 것입니다. 해커 하위문화 속에는 Perl이라는 또 다른 언어가 있는데, 이는 Java보다 훨씬 멋지다고 여겨집니다. 예를 들어, Slashdot은 Perl로 생성됩니다. 저는 당신이 그런 사람들을 Java Server Pages를 사용하는 것을 발견하지 않을 것이라고 생각합니다. 하지만 Perl을 내려다보는 경향이 있는 Python이라는, 더 새롭고 또 다른 언어가 있고, 더 많은 언어들이 준비 중에 있습니다.

만약 당신이 Java, Perl, Python 순서로 이 언어들을 본다면, 흥미로운 패턴을 발견하게 될 것입니다. 적어도, 당신이 Lisp 해커라면 이 패턴을 발견할 것입니다. 각각은 점진적으로 Lisp에 더 가까워집니다. Python은 많은 Lisp 해커들이 실수라고 생각하는 기능들까지 복사합니다.

간단한 Lisp 프로그램을 Python으로 한 줄씩 번역할 수 있습니다.

2002년이고, 프로그래밍 언어들은 거의 1958년을 따라잡았습니다.

## 수학 따라잡기

제가 의미하는 바는 Lisp가 1958년 존 매카시에게 처음 발견되었고, 인기 있는 프로그래밍 언어들이 이제 막 그가 그때 개발한 아이디어들을 따라잡고 있다는 것입니다.

그것이 어떻게 사실일 수 있을까요? 컴퓨터 기술은 매우 빠르게 변하는 것이 아닙니까? 제 말은, 1958년에는 컴퓨터가 냉장고 크기의 거대한 기계였고, 시계줄의 처리 능력밖에 없었다는 것입니다. 그렇게 오래된 기술이 최신 개발보다 관련성이 있거나, 심지어 우월할 수 있을까요?

제가 어떻게 그런지 말씀드리겠습니다. Lisp는 사실 프로그래밍 언어로 설계된 것이 아닙니다. 적어도 우리가 오늘날 의미하는 그런 뜻으로는 아닙니다. 프로그래밍 언어로 우리가 의미하는 것은 컴퓨터에게 무엇을 해야 할지 말하는 데 사용하는 것입니다. 매카시는 결국 이 의미에서 프로그래밍 언어를 개발할 의도였지만, 우리가 실제로 얻게 된 Lisp는 그가 이론적 연습으로 했던 것과는 분리된 것에 기반했습니다. 튜링 머신에 대한 보다 편리한 대안을 정의하려는 노력 말입니다.

매카시가 나중에 말했듯이,
"Lisp가 튜링 머신보다 더 깔끔하다는 것을 보여주는 또 다른 방법은 범용 Lisp 함수를 작성하고 그것이 범용 튜링 머신 설명보다 더 간결하고 이해하기 쉽다는 것을 보여주는 것이었습니다."

이것이 바로 `eval` 함수였습니다... Lisp 표현식의 값을 계산하는... `eval`을 작성하려면 Lisp 함수를 Lisp 데이터로 나타내는 표기법을 발명해야 했습니다. 그리고 이 논문의 목적을 위해 고안된 그러한 표기법은 Lisp 프로그램을 실제로 표현하는 데 사용될 것이라는 생각 없이 만들어졌습니다.

그 다음에 일어난 일은, 1958년 말 어느 시점에 매카시의 대학원생 중 한 명인 스티브 러셀이 이 `eval`의 정의를 보고, 그것을 기계어로 번역하면 결과가 Lisp 인터프리터가 될 것이라는 것을 깨달았다는 것입니다.

그것은 당시 큰 놀라움이었습니다.

여기 매카시가 나중에 인터뷰에서 말한 내용이 있습니다.
"스티브 러셀은, '왜 내가 이 `eval`을 프로그래밍하지 않느냐'고 말했고, 나는 그에게 '호, 호, 당신은 이론과 실제를 혼동하고 있어. 이 `eval`은 계산용이 아니라 읽기용이야'라고 말했지. 하지만 그는 계속해서 그것을 해냈어. 즉, 그는 내 논문에 있는 `eval`을 [IBM] 704 기계 코드로 컴파일하고, 버그를 수정하고, 그것을 Lisp 인터프리터라고 광고했지. 그것은 확실히 그랬어. 그래서 그 시점에서 Lisp는 본질적으로 오늘날의 형태를 갖추게 되었지...."

갑자기, 아마 몇 주 만에, 매카시는 자신의 이론적 연습이 실제 프로그래밍 언어—그리고 그가 의도했던 것보다 더 강력한 언어로 변모하는 것을 발견했습니다.

따라서 이 1950년대 언어가 구식이 아닌 짧은 설명은 그것이 기술이 아니라 수학이었고, 수학은 낡지 않는다는 것입니다. Lisp를 비교해야 할 올바른 대상은 1950년대 하드웨어가 아니라, 예를 들어 1960년에 발견되어 여전히 가장 빠른 범용 정렬인 Quicksort 알고리즘입니다.

1950년대부터 살아남은 또 다른 언어인 Fortran은 언어 설계에 대한 반대 접근 방식을 나타냅니다. Lisp는 예상치 못하게 프로그래밍 언어가 된 이론의 한 조각이었습니다. Fortran은 의도적으로 프로그래밍 언어로 개발되었지만, 지금 우리가 볼 때는 매우 저수준의 언어입니다.

1956년에 개발된 Fortran I 언어는 현재의 Fortran과는 매우 다른 동물이었습니다. Fortran I는 거의 수학을 사용한 어셈블리 언어였습니다. 어떤 면에서는 더 최근의 어셈블리 언어보다 덜 강력했습니다. 예를 들어 서브루틴은 없었고, 오직 분기문만 있었습니다.

현재의 Fortran은 아마도 Lisp보다 Fortran I에 더 가깝습니다.

Lisp와 Fortran은 수학에 뿌리를 둔 것과 기계 아키텍처에 뿌리를 둔 것, 두 개의 별개 진화 트리의 줄기였습니다. 이 두 트리는 그 이후로 계속 수렴해 왔습니다.

Lisp는 강력하게 시작했고, 이후 20년 동안 빨라졌습니다. 소위 주류 언어들은 빠르게 시작했고, 이후 40년 동안 점진적으로 더 강력해져서, 이제 그들 중 가장 진보된 것들은 Lisp에 상당히 가깝습니다.

가깝지만, 여전히 몇 가지가 빠져 있습니다....

## Lisp가 무엇을 다르게 만들었는가

처음 개발될 때, Lisp는 아홉 가지 새로운 아이디어를 구현했습니다. 이 중 일부는 이제 당연하게 여겨지고, 일부는 더 진보된 언어에서만 볼 수 있으며, 두 가지는 여전히 Lisp 고유의 것입니다. 주류 언어들에 의해 채택된 순서대로 아홉 가지 아이디어는 다음과 같습니다.

1.  **조건문**: 조건문은 if-then-else 구조입니다. 우리는 이것을 이제 당연하게 여기지만, Fortran I에는 그것이 없었습니다. 그것은 오직 기본 기계 명령에 밀접하게 기반한 조건부 goto만 가지고 있었습니다.
2.  **함수 타입**: Lisp에서 함수는 정수나 문자열과 같은 데이터 타입입니다. 그것들은 리터럴 표현을 가지고 있고, 변수에 저장될 수 있으며, 인자로 전달될 수 있습니다.
3.  **재귀**: Lisp는 그것을 지원하는 최초의 프로그래밍 언어였습니다.
4.  **동적 타이핑**: Lisp에서 모든 변수는 사실상 포인터입니다. 값들이 타입을 가지며, 변수들이 타입을 가지는 것이 아닙니다. 변수를 할당하거나 바인딩하는 것은 그들이 가리키는 것을 복사하는 것이 아니라 포인터를 복사하는 것을 의미합니다.
5.  **가비지 컬렉션**:
6.  **표현식으로 구성된 프로그램**: Lisp 프로그램은 각 표현식이 값을 반환하는 표현식의 트리입니다. 이것은 표현식과 문장을 구별하는 Fortran 및 대부분의 후속 언어와 대조됩니다. Fortran I에는 이 구별이 자연스러웠습니다. 왜냐하면 문장을 중첩할 수 없었기 때문입니다. 그래서 수학이 작동하려면 표현식이 필요했지만, 다른 어떤 것도 값을 반환하게 만들 이유는 없었습니다. 왜냐하면 그것을 기다릴 것이 없었기 때문입니다. 이 제한은 블록 구조 언어의 등장과 함께 사라졌지만, 그때는 이미 너무 늦었습니다. 표현식과 문장의 구별은 고착되었습니다. 그것은 Fortran에서 Algol로 퍼져나갔고, 그 후 두 언어의 후손들에게도 퍼졌습니다.
7.  **심볼 타입**: 심볼은 사실상 해시 테이블에 저장된 문자열에 대한 포인터입니다. 따라서 각 문자를 비교하는 대신 포인터를 비교하여 동일성을 테스트할 수 있습니다.
8.  **심볼과 상수의 트리로 된 코드 표기법**:
9.  **항상 존재하는 전체 언어**: 읽기 시간, 컴파일 시간, 런타임 사이에 실제적인 구별이 없습니다. 읽기 시간에 코드를 컴파일하거나 실행할 수 있고, 컴파일 시간에 코드를 읽거나 실행할 수 있으며, 런타임에 코드를 읽거나 컴파일할 수 있습니다. 읽기 시간에 코드를 실행하면 사용자는 Lisp의 구문을 재프로그래밍할 수 있습니다; 컴파일 시간에 코드를 실행하는 것은 매크로의 기반이며; 런타임에 컴파일하는 것은 Emacs와 같은 프로그램에서 Lisp를 확장 언어로 사용하는 기반이고; 런타임에 읽는 것은 프로그램이 S-표현식으로 통신할 수 있게 합니다. S-표현식은 최근 XML로 재발명된 아이디어입니다.

Lisp가 처음 등장했을 때, 이 아이디어들은 1950년대 후반의 하드웨어 가용성에 의해 크게 좌우되었던 일반적인 프로그래밍 관행과는 거리가 멀었습니다.

시간이 지남에 따라, 인기 있는 언어들의 연속으로 구현된 기본 언어는 점진적으로 Lisp를 향해 진화했습니다. 아이디어 1-5는 이제 널리 퍼졌습니다. 6번은 나타나기 시작했습니다. Python은 7번의 한 형태를 가지고 있지만, 그것에 대한 구문은 없는 것 같습니다.

8번과 9번에 관해서는, 이것이 아마도 가장 흥미로운 부분일 것입니다. 아이디어 8과 9는 스티브 러셀이 매카시가 전혀 의도하지 않았던 것을 구현했기 때문에 우연히 Lisp의 일부가 되었습니다. 그런데도 이 아이디어들은 Lisp의 이상한 모습과 가장 독특한 특징들에 책임이 있다는 것이 밝혀졌습니다. Lisp가 이상하게 보이는 것은 이상한 구문 때문이라기보다는 구문이 없기 때문입니다; 다른 언어들이 파싱될 때 백그라운드에서 구축되는 파스 트리를 직접 사용하여 프로그램을 표현하며, 이 트리들은 리스트로 만들어지는데, 이는 Lisp 데이터 구조입니다.

언어를 자체 데이터 구조로 표현하는 것은 매우 강력한 기능임이 밝혀졌습니다. 아이디어 8과 9는 함께 당신이 프로그램을 작성하는 프로그램을 작성할 수 있다는 것을 의미합니다. 그것은 이상한 아이디어처럼 들릴 수 있지만, Lisp에서는 일상적인 일입니다. 가장 일반적인 방법은 매크로라고 불리는 것입니다.

"매크로"라는 용어는 Lisp에서 다른 언어에서 의미하는 것과 다릅니다. Lisp 매크로는 축약에서 새로운 언어의 컴파일러까지 무엇이든 될 수 있습니다.

Lisp를 제대로 이해하거나 프로그래밍의 지평을 넓히고 싶다면, 매크로에 대해 더 많이 배우십시오.

매크로(Lisp에서의 의미)는 제가 알기로는 여전히 Lisp 고유의 것입니다.

이것은 부분적으로 매크로를 가지려면 아마도 당신의 언어를 Lisp만큼 이상하게 보이게 만들어야 하기 때문일 것입니다. 또한, 만약 당신이 그 최종적인 힘의 증가를 더한다면, 당신은 더 이상 새로운 언어를 발명했다고 주장할 수 없고, 단지 Lisp의 새로운 방언만이라고 주장할 수 있게 될지도 모릅니다.

저는 이것을 주로 농담으로 언급하지만, 그것은 상당히 사실입니다. 만약 당신이 `car`, `cdr`, `cons`, `quote`, `cond`, `atom`, `eq`를 정의하고 리스트로 표현되는 함수 표기법을 가진 언어를 정의한다면, 그것으로부터 Lisp의 나머지 부분을 만들 수 있습니다. 사실 이것이 Lisp의 정의적인 특징입니다: 매카시가 Lisp에 지금의 형태를 부여한 것은 이것을 가능하게 하기 위해서였습니다.

## 언어는 어디에서 중요한가

그렇다면 Lisp가 주류 언어들이 점근적으로 접근하는 일종의 한계를 나타낸다면—그것이 실제로 소프트웨어를 작성하기 위해 그것을 사용해야 한다는 것을 의미할까요? 덜 강력한 언어를 사용하는 것으로 얼마나 많이 잃게 될까요? 때로는 혁신의 가장자리 바로 그곳에 있지 않는 것이 더 현명하지 않을까요?

그리고 인기가 어느 정도는 그 자체로 정당화되는 것이 아닙니까? 예를 들어, 융통성 없는 상사가 쉽게 프로그래머를 고용할 수 있는 언어를 사용하고 싶어하는 것이 옳지 않습니까?

물론, 프로그래밍 언어 선택이 별로 중요하지 않은 프로젝트들도 있습니다. 일반적으로, 애플리케이션이 더 까다로울수록 강력한 언어를 사용함으로써 더 많은 이점을 얻습니다. 하지만 수많은 프로젝트는 전혀 까다롭지 않습니다.

대부분의 프로그래밍은 아마도 작은 프로그램을 작성하는 것으로 구성될 것입니다. 그리고 작은 프로그램을 위해서는 당신이 이미 익숙하고 필요한 작업에 대한 좋은 라이브러리가 있는 어떤 언어라도 사용할 수 있습니다. 만약 당신이 단지 한 Windows 앱에서 다른 Windows 앱으로 데이터를 공급해야 한다면, 물론 Visual Basic을 사용하십시오.

Lisp로도 작은 프로그램을 작성할 수 있습니다 (저는 그것을 데스크톱 계산기로 사용합니다). 하지만 Lisp와 같은 언어의 가장 큰 이점은 스펙트럼의 다른 쪽 끝, 즉 치열한 경쟁 속에서 어려운 문제를 해결하기 위해 정교한 프로그램을 작성해야 하는 곳에 있습니다.

좋은 예는 ITA Software가 Orbitz에 라이선스하는 항공 요금 검색 프로그램입니다. 이 친구들은 이미 두 개의 크고 확고한 경쟁업체인 Travelocity와 Expedia가 지배하던 시장에 진입했고, 기술적으로 그들을 굴욕시킨 것으로 보입니다.

ITA 애플리케이션의 핵심은 200,000 라인의 Common Lisp 프로그램으로, 경쟁업체들이 사용하는 것보다 몇 자릿수 더 많은 가능성을 검색합니다. 경쟁업체들은 분명히 메인프레임 시대의 프로그래밍 기법을 여전히 사용하고 있습니다. (하지만 ITA도 어떤 의미에서는 메인프레임 시대의 프로그래밍 언어를 사용하고 있습니다.)

저는 ITA의 코드 중 어느 것도 본 적이 없지만, 그들의 최상위 해커 중 한 명에 따르면 그들은 많은 매크로를 사용하며, 저는 그 말을 듣고 놀라지 않았습니다.

## 중심으로 작용하는 힘

저는 드물게 사용되는 기술을 사용하는 데 아무런 비용이 들지 않는다고 말하는 것이 아닙니다. 융통성 없는 상사가 이것을 걱정하는 것이 완전히 틀린 것은 아닙니다. 하지만 그는 위험을 이해하지 못하기 때문에 그것들을 과장하는 경향이 있습니다.

제가 덜 일반적인 언어를 사용하는 것에서 발생할 수 있는 세 가지 문제를 생각해 볼 수 있습니다. 당신의 프로그램이 다른 언어로 작성된 프로그램과 잘 작동하지 않을 수 있습니다. 당신은 사용할 수 있는 라이브러리가 더 적을 수 있습니다. 그리고 프로그래머를 고용하는 데 어려움을 겪을 수 있습니다.

이것들 각각이 얼마나 큰 문제일까요? 첫 번째의 중요성은 당신이 전체 시스템을 제어하는지에 따라 달라집니다. 만약 당신이 버그가 많고 닫힌 운영 체제 (어떤 이름도 언급하지 않겠습니다) 위에서 원격 사용자의 머신에서 실행되어야 하는 소프트웨어를 작성하고 있다면, 당신의 애플리케이션을 OS와 같은 언어로 작성하는 데 이점이 있을 수 있습니다.

하지만 만약 당신이 전체 시스템을 제어하고 모든 부분의 소스 코드를 가지고 있다면, ITA가 분명히 그렇듯이, 당신은 원하는 언어를 사용할 수 있습니다. 호환성 문제가 발생한다면, 당신 스스로 해결할 수 있습니다.

서버 기반 애플리케이션에서는 가장 진보된 기술을 사용하는 것으로 빠져나올 수 있으며, 저는 이것이 조나단 에릭슨이 "프로그래밍 언어 르네상스"라고 부르는 것의 주요 원인이라고 생각합니다. 이것이 Perl과 Python 같은 새로운 언어에 대해 들어보는 이유입니다. 우리는 사람들이 Windows 앱을 작성하기 위해 이 언어들을 사용하기 때문에 그것들에 대해 듣는 것이 아닙니다. 사람들이 서버에서 그것들을 사용하기 때문입니다. 그리고 소프트웨어가 데스크톱에서 서버로 이동함에 따라 (심지어 Microsoft조차도 체념한 미래), 중간 수준 기술을 사용해야 하는 압력은 점점 더 줄어들 것입니다.

라이브러리에 관해서는, 그것들의 중요성 또한 애플리케이션에 따라 다릅니다. 덜 까다로운 문제의 경우, 라이브러리의 가용성이 언어의 내재적 힘을 능가할 수 있습니다. 손익분기점은 어디일까요? 정확히 말하기 어렵지만, 어디든 간에, 그것은 당신이 애플리케이션이라고 부를 만한 것과는 거리가 멉니다. 만약 어떤 회사가 스스로를 소프트웨어 비즈니스에 종사한다고 생각하고, 그들의 제품 중 하나가 될 애플리케이션을 작성하고 있다면, 그것은 아마도 여러 해커를 포함할 것이고 작성하는 데 최소 6개월이 걸릴 것입니다. 그 정도 크기의 프로젝트에서는 강력한 언어가 기존 라이브러리의 편리함을 능가하기 시작할 것입니다.

융통성 없는 상사의 세 번째 걱정, 즉 프로그래머를 고용하는 어려움은 제가 볼 때 허풍입니다. 결국, 당신은 몇 명의 해커를 고용해야 할까요? 분명히 이제 우리는 모두 소프트웨어가 10명 미만의 팀에 의해 가장 잘 개발된다는 것을 알고 있습니다. 그리고 당신은 들어본 적 있는 어떤 언어에 대해서도 그 규모의 해커를 고용하는 데 어려움을 겪지 않아야 합니다. 만약 당신이 10명의 Lisp 해커를 찾지 못한다면, 당신의 회사는 아마 소프트웨어 개발에 있어서 잘못된 도시에 기반하고 있을 것입니다.

사실, 더 강력한 언어를 선택하는 것은 당신이 필요로 하는 팀의 규모를 줄일 가능성이 높습니다. 왜냐하면 (a) 더 강력한 언어를 사용하면 해커가 덜 필요할 것이고, (b) 더 진보된 언어로 일하는 해커는 더 똑똑할 가능성이 높기 때문입니다.

저는 당신이 "표준" 기술로 인식되는 것을 사용하라는 압력을 많이 받지 않을 것이라고 말하는 것이 아닙니다. Viaweb (현재 Yahoo Store)에서 우리는 Lisp를 사용함으로써 VC와 잠재적 인수자들 사이에서 눈썹을 치켜올리게 했습니다. 하지만 우리는 또한 "산업 강도" 서버인 Sun 대신 일반 Intel 박스를 서버로 사용함으로써, FreeBSD라는 당시에는 잘 알려지지 않은 오픈 소스 Unix 변형 대신 Windows NT와 같은 상용 OS를 사용함으로써, 이제는 아무도 기억하지 못하는 전자 상거래 표준인 SET을 무시함으로써 등등으로 눈썹을 치켜올리게 했습니다.

수트(suit, 즉 경영진/컨설턴트)가 당신을 위해 기술적 결정을 내리게 하지 마십시오.

그것이 일부 잠재적 인수자들을 불안하게 했습니까? 일부는 약간 그랬지만, 만약 우리가 Lisp를 사용하지 않았다면, 그들이 우리를 사고 싶게 만든 소프트웨어를 작성하지 못했을 것입니다. 그들에게는 이상하게 보였던 것이 사실은 원인과 결과였습니다.

스타트업을 시작한다면, VC나 잠재적 인수자를 만족시키기 위해 제품을 설계하지 마십시오. 사용자를 만족시키기 위해 제품을 설계하십시오. 사용자를 얻으면, 다른 모든 것이 따라올 것입니다. 그리고 사용자를 얻지 못하면, 아무도 당신의 기술 선택이 얼마나 편안하게 정통적이었는지 신경 쓰지 않을 것입니다.

## 평균적인 것의 대가

덜 강력한 언어를 사용함으로써 얼마나 많이 잃게 될까요? 사실 거기에 관한 데이터가 있습니다.

힘의 가장 편리한 척도는 아마도 코드 크기일 것입니다.

고수준 언어의 요점은 더 큰 추상화를 제공하는 것입니다—마치 더 큰 벽돌과 같아서, 주어진 크기의 벽을 쌓는 데 더 적게 필요합니다.

따라서 언어가 더 강력할수록 프로그램은 더 짧아집니다 (문자 수뿐만 아니라 고유한 요소 수에서도).

더 강력한 언어가 어떻게 더 짧은 프로그램을 작성할 수 있게 할까요? 언어가 허용한다면 사용할 수 있는 한 가지 기법은 상향식 프로그래밍(bottom-up programming)이라고 불리는 것입니다. 단순히 기본 언어로 애플리케이션을 작성하는 대신, 당신은 기본 언어 위에 당신과 같은 프로그램을 작성하기 위한 언어를 구축하고, 그 위에 당신의 프로그램을 작성합니다. 결합된 코드는 전체 프로그램을 기본 언어로 작성했을 때보다 훨씬 짧을 수 있습니다—사실, 이것이 대부분의 압축 알고리즘이 작동하는 방식입니다.

상향식 프로그램은 수정하기도 더 쉬워야 합니다. 왜냐하면 많은 경우 언어 계층이 전혀 변경되지 않아도 되기 때문입니다.

코드 크기는 중요합니다. 왜냐하면 프로그램을 작성하는 데 걸리는 시간은 주로 그 길이에 따라 달라지기 때문입니다.

만약 다른 언어로 세 배 더 길다면, 작성하는 데 세 배의 시간이 걸릴 것입니다—그리고 더 많은 사람을 고용한다고 해서 이 문제를 피할 수는 없습니다. 왜냐하면 특정 크기를 넘어서면 신규 채용은 실제로는 순 손실이 되기 때문입니다.

프레드 브룩스는 그의 유명한 저서 '만인지상(The Mythical Man-Month)'에서 이 현상을 설명했으며, 제가 본 모든 것은 그가 말한 것을 확인하는 경향이 있습니다.

그렇다면 Lisp로 프로그램을 작성하면 얼마나 더 짧아질까요? 제가 들은 Lisp 대 C의 비율에 대한 대부분의 수치는 약 7-10배입니다.

하지만 ITA에 관한 최근 'New Architect' 잡지의 기사에서는 "Lisp 한 줄이 C 20줄을 대체할 수 있다"고 말했으며, 이 기사는 ITA 사장의 인용문으로 가득 차 있었으므로 저는 그들이 이 수치를 ITA에서 가져왔다고 가정합니다. 만약 그렇다면 우리는 그것에 약간의 신뢰를 둘 수 있습니다. ITA의 소프트웨어는 Lisp뿐만 아니라 C와 C++도 많이 포함하고 있으므로, 그들은 경험에 비추어 말하고 있습니다.

제 추측으로는 이러한 배수들이 일정하지도 않을 것입니다. 저는 그것들이 어려운 문제에 직면할 때 그리고 더 똑똑한 프로그래머를 가질 때 증가한다고 생각합니다. 정말 좋은 해커는 더 나은 도구에서 더 많은 것을 짜낼 수 있습니다.

어쨌든, 하나의 데이터 포인트로, 만약 당신이 ITA와 경쟁하기로 선택하고 당신의 소프트웨어를 C로 작성하기로 선택한다면, 그들은 당신보다 20배 더 빠르게 소프트웨어를 개발할 수 있을 것입니다.

만약 당신이 새로운 기능에 1년을 투자했다면, 그들은 3주도 채 되지 않아 그것을 복제할 수 있을 것입니다. 반면에 만약 그들이 새로운 것을 개발하는 데 단 3개월을 투자했다면, 당신이 그것을 얻는 데 5년이 걸릴 것입니다.

그리고 아시다시피? 그것은 최상의 시나리오입니다.

코드 크기 비율에 대해 이야기할 때, 당신은 약한 언어로 실제로 프로그램을 작성할 수 있다고 암묵적으로 가정하고 있습니다.

하지만 사실 프로그래머가 할 수 있는 일에는 한계가 있습니다. 만약 너무 낮은 수준의 언어로 어려운 문제를 해결하려고 한다면, 당신은 머릿속에 한 번에 너무 많은 것을 담아야 하는 지점에 도달합니다.

그래서 ITA의 가상 경쟁자가 Lisp로 3개월 만에 작성할 수 있는 것을 복제하는 데 5년이 걸릴 것이라고 말할 때, 저는 아무 일도 일어나지 않는다는 가정 하에 5년이라는 의미입니다. 사실, 대부분의 회사에서 일이 진행되는 방식으로는, 5년이 걸릴 개발 프로젝트는 아마도 완성되지 못할 것입니다.

저는 이것이 극단적인 경우임을 인정합니다. ITA의 해커들은 예외적으로 똑똑해 보이고, C는 상당히 낮은 수준의 언어입니다.

하지만 경쟁 시장에서는, 2~3배의 차이만으로도 당신이 항상 뒤처질 수밖에 없다는 것을 보장하기에 충분할 것입니다.

## 레시피

이것은 융통성 없는 상사가 전혀 생각하고 싶어하지 않는 종류의 가능성입니다. 그리고 그래서 대부분의 상사는 그렇게 하지 않습니다.

아시다시피, 결국 융통성 없는 상사는 자신의 회사가 망신을 당해도 괜찮습니다. 단지 그것이 자신의 잘못임이 입증되지 않는 한.

그에게 가장 안전한 계획은 무리의 중심에 가깝게 머무르는 것입니다.

대규모 조직 내에서 이 접근 방식을 설명하는 데 사용되는 문구는 "업계 최고 관행"입니다.

그 목적은 융통성 없는 상사를 책임에서 보호하는 것입니다. 만약 그가 "업계 최고 관행"을 선택하고 회사가 패배한다면, 그는 비난받을 수 없습니다. 그는 선택하지 않았고, 업계가 선택했습니다.

저는 이 용어가 원래 회계 방법 등을 설명하는 데 사용되었다고 믿습니다. 그것은 대략, 이상한 짓 하지 마세요, 라는 의미입니다. 그리고 회계에서는 그것이 아마도 좋은 생각일 것입니다. "최첨단"과 "회계"라는 단어는 함께 좋은 소리로 들리지 않습니다.

하지만 이 기준을 기술 결정에 가져오기 시작하면 잘못된 답을 얻기 시작합니다.

기술은 종종 최첨단이어야 합니다. 에란 가트가 지적했듯이, 프로그래밍 언어에서 "업계 최고 관행"이 실제로 당신에게 제공하는 것은 최고가 아니라, 단지 평균입니다. 결정이 공격적인 경쟁자들의 속도의 일부로 소프트웨어를 개발하게 만든다면, "최고 관행"은 오해의 소지가 있는 말입니다.

그래서 저는 매우 귀중하다고 생각하는 두 가지 정보를 가지고 있습니다. 사실, 저는 제 자신의 경험을 통해 그것을 압니다.

첫째, 언어는 힘에서 다양합니다. 둘째, 대부분의 관리자는 의도적으로 이것을 무시합니다. 이 두 가지 사실은 문자 그대로 돈을 버는 레시피입니다. ITA는 이 레시피를 실행하는 예입니다.

소프트웨어 사업에서 이기려면, 찾을 수 있는 가장 어려운 문제를 맡아, 얻을 수 있는 가장 강력한 언어를 사용하고, 경쟁자들의 융통성 없는 상사들이 평균으로 돌아가기를 기다리십시오.

## 부록: 힘

제가 프로그래밍 언어의 상대적 힘에 대해 의미하는 바를 설명하기 위해, 다음 문제를 고려해 봅시다.

우리는 누적기(accumulator)를 생성하는 함수를 작성하고 싶습니다—숫자 n을 받고, 다른 숫자 i를 받고 n에 i를 더한 값을 반환하는 함수를 반환하는 함수입니다. (더해진다는 것은 plus가 아니라는 것입니다. 누적기는 누적해야 합니다.)

커먼 리스프에서는 이렇게 될 것입니다
```lisp
(defun foo (n)
  (lambda (i) (incf n i)))
```

그리고 Perl 5에서는,
```perl
sub foo {  
  my ($n) = @_;
  sub {$n += shift}
}
```
이는 Lisp 버전보다 더 많은 요소를 가지고 있습니다. 왜냐하면 Perl에서는 매개변수를 수동으로 추출해야 하기 때문입니다.

Smalltalk에서는 코드가 Lisp보다 약간 더 깁니다.
```smalltalk
foo: n                              
  |s|                      
  s := n.                          
  ^[:i| s := s+i. ]
```
왜냐하면 일반적으로 렉시컬 변수가 작동하지만, 매개변수에 대한 할당을 할 수 없으므로 새 변수 s를 만들어야 하기 때문입니다.

Javascript에서는 예제가 다시 약간 더 깁니다. 왜냐하면 Javascript는 문장과 표현식의 구별을 유지하기 때문에, 값을 반환하려면 명시적인 return 문이 필요합니다.
```javascript
function foo(n) { 
  return function (i) { 
           return n += i } }
```
(공정하게 말하자면, Perl도 이 구별을 유지하지만, return을 생략하도록 허용함으로써 전형적인 Perl 방식으로 처리합니다.)

Lisp/Perl/Smalltalk/Javascript 코드를 Python으로 번역하려고 하면 몇 가지 제한에 부딪힙니다. Python은 렉시컬 변수를 완전히 지원하지 않기 때문에, n의 값을 저장할 데이터 구조를 만들어야 합니다. 그리고 Python은 함수 데이터 타입을 가지고 있지만, 그것에 대한 리터럴 표현은 없습니다 (본문이 단일 표현식만 포함하는 경우가 아니면). 따라서 반환할 명명된 함수를 만들어야 합니다. 결과는 다음과 같습니다.
```python
def foo(n):
  s = [n]
  def bar(i):
    s[0] += i
    return s[0] 
  return bar
```

Python 사용자들은 왜 그냥 다음과 같이 작성할 수 없는지 정당하게 물을 수 있습니다.
```python
def foo(n):
  return lambda i: return n += i
```
또는 심지어
```python
def foo(n):
  lambda i: n += i
```
그리고 제 추측은 언젠가 그들이 그렇게 할 것이라는 것입니다.
(하지만 Python이 Lisp로 완전히 진화하기를 기다리고 싶지 않다면, 언제든지...)

OO 언어에서는, 제한된 범위 내에서, 클래스를 정의하고 하나의 메서드와 각 변수를 대체할 필드를 가지고 있는 것으로 클로저(enclosing scope에 정의된 변수를 참조하는 함수)를 시뮬레이션할 수 있습니다. 이것은 프로그래머가 렉시컬 스코프에 대한 완전한 지원이 있는 언어에서 컴파일러가 수행할 코드 분석을 수행하게 만듭니다. 그리고 두 개 이상의 함수가 동일한 변수를 참조하는 경우 작동하지 않지만, 간단한 경우에는 충분합니다.

Python 전문가들은 이것이 Python에서 이 문제를 해결하는 선호되는 방법이라고 동의하는 것 같습니다. 다음 중 하나를 작성합니다.
```python
def foo(n):
  class acc:
    def __init__(self, s):
        self.s = s
    def inc(self, i):
        self.s += i
        return self.s
  return acc(n).inc
```
또는
```python
class foo:
  def __init__(self, n):
      self.n = n
  def __call__(self, i):
      self.n += i
      return self.n
```
저는 Python 지지자들이 제가 언어를 잘못 표현했다고 말하지 않도록 이것들을 포함했지만, 둘 다 제 생각에는 첫 번째 버전보다 더 복잡합니다. 당신은 동일한 일을 하고 있고, 누적기를 저장할 별도의 공간을 설정하고 있습니다. 그것은 단지 객체의 필드일 뿐, 리스트의 머리가 아니라. 그리고 이러한 특별한 예약된 필드 이름, 특히 `__call__`의 사용은 약간 해킹처럼 보입니다.

Perl과 Python의 경쟁에서, Python 해커들의 주장은 Python이 Perl에 대한 더 우아한 대안이라는 것이지만, 이 사례는 힘이 궁극적인 우아함이라는 것을 보여줍니다. Perl 프로그램은 구문이 약간 더 보기 흉해도 더 단순합니다 (요소가 더 적습니다).

이 강연에서 언급된 다른 언어들—Fortran, C, C++, Java, Visual Basic—에서는 이 문제를 실제로 해결할 수 있는지 명확하지 않습니다.

Ken Anderson은 Java에서 얻을 수 있는 가장 가까운 것이 다음과 같은 코드라고 말합니다.
```java
public interface Inttoint {
  public int call(int i);
}
public static Inttoint foo(final int n) {
  return new Inttoint() {
    int s = n;
    public int call(int i) {
    s = s + i;
    return s;
    }};
}
```
이것은 정수에 대해서만 작동하기 때문에 사양에 미치지 못합니다. Java 해커들과의 많은 이메일 교환 후, 저는 이전 예와 같이 작동하는 올바르게 다형적인 버전을 작성하는 것이 중간 정도는 매우 까다롭거나 불가능하다고 말할 수 있습니다. 누군가 그것을 작성하고 싶어 한다면 저는 그것을 보는 데 매우 관심이 있겠지만, 개인적으로는 시간 초과했습니다.

이러한 언어들이 모두 튜링 동등하다는 사실 때문에, 엄밀히 말하면 어떤 언어에서도 모든 프로그램을 작성할 수 있다는 것은 문자 그대로 사실이 아닙니다. 그렇다면 어떻게 그것을 할 수 있을까요? 극한의 경우, 덜 강력한 언어로 Lisp 인터프리터를 작성하는 것입니다.

이것은 농담처럼 들리지만, 대규모 프로그래밍 프로젝트에서 다양한 정도로 자주 발생하기 때문에 이 현상에는 이름이 붙어 있습니다. 그린스펀의 열 번째 규칙입니다:
"충분히 복잡한 C 또는 Fortran 프로그램은 임시방편으로 비공식적으로 명시되고 버그가 많으며 느린 반쪽짜리 커먼 리스프 구현을 포함합니다."

어려운 문제를 해결하려고 할 때, 질문은 충분히 강력한 언어를 사용할 것인가가 아니라, (a) 강력한 언어를 사용할 것인가, (b) 그것의 사실상의 인터프리터를 작성할 것인가, 또는 (c) 당신 자신이 그것의 인간 컴파일러가 될 것인가 하는 것입니다.

우리는 이미 Python 예제에서 이것이 시작되는 것을 볼 수 있습니다. 여기서 우리는 사실상 렉시컬 변수를 구현하기 위해 컴파일러가 생성할 코드를 시뮬레이션하고 있습니다.

이 관행은 단순히 흔한 것이 아니라 제도화되었습니다. 예를 들어, OO 세계에서는 "패턴"에 대해 많은 이야기를 듣습니다.

저는 이러한 패턴들이 때로는 (c) 즉, 인간 컴파일러의 증거가 아닌가 의문이 듭니다. 제 프로그램에서 패턴을 볼 때, 저는 그것을 문제의 징후로 간주합니다. 프로그램의 모양은 그것이 해결해야 할 문제만을 반영해야 합니다. 코드의 다른 어떤 규칙성도, 적어도 제게는, 제가 작성해야 할 매크로의 확장을 수동으로 생성하고 있다는 신호입니다.

## 주석

IBM 704 CPU는 냉장고 크기였지만 훨씬 더 무거웠습니다. CPU는 3150파운드였고, 4KB RAM은 또 다른 4000파운드 무게의 별도 상자에 있었습니다. 가정용 냉장고 중 가장 큰 것 중 하나인 Sub-Zero 690은 656파운드입니다.

스티브 러셀은 또한 1962년에 최초의 (디지털) 컴퓨터 게임인 Spacewar를 작성했습니다.

만약 당신이 융통성 없는 상사를 속여 Lisp로 소프트웨어를 작성하게 만들고 싶다면, 그것이 XML이라고 말해보십시오.

다른 Lisp 방언에서의 누적기 생성기는 다음과 같습니다.
```lisp
Scheme: (define (foo n) 
          (lambda (i) (set! n (+ n i)) n))
Goo:    (df foo (n) (op incf n _)))
Arc:    (def foo (n) [++ n _])
```

Erann Gat의 JPL에서의 "업계 최고 관행"에 대한 슬픈 이야기는 제가 이것을 일반적으로 오용되는 문구로 다루도록 영감을 주었습니다.

Peter Norvig은 'Design Patterns'의 23개 패턴 중 16개가 Lisp에서 "보이지 않거나 더 단순하다"는 것을 발견했습니다.

다양한 언어에 대한 제 질문에 답변하거나 이 글의 초안을 읽어준 많은 분들께 감사드립니다. 여기에는 Ken Anderson, Trevor Blackwell, Erann Gat, Dan Giffin, Sarah Harlin, Jeremy Hylton, Robert Morris, Peter Norvig, Guy Steele, Anton van Straaten이 포함됩니다. 그들은 제가 표현한 어떤 의견에 대해서도 비난받지 않습니다.

**관련 정보**:
많은 사람들이 이 글에 응답했으므로, 그들이 제기한 문제를 다루기 위한 추가 페이지를 마련했습니다: Re: Revenge of the Nerds. 또한 LL1 메일링 리스트에서 광범위하고 종종 유용한 논의를 촉발했습니다. 특히 Anton van Straaten의 의미론적 압축에 관한 메일을 참조하십시오. LL1에 관한 메일 중 일부는 제가 언어력이라는 주제를 더 깊이 탐구하도록 이끌었습니다. Succinctness is Power.
누적기 생성기 벤치마크에 대한 보다 광범위한 표준 구현 세트가 자체 페이지에 수집되어 있습니다.

일본어 번역, 스페인어 번역, 중국어 번역