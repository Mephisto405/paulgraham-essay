# 너드들의 복수 (Revenge of the Nerds)

Y Combinator에서 자금 지원을 받아 스타트업을 시작하고 싶으신가요?

2002년 5월

"우리는 C++ 프로그래머들을 쫓고 있었습니다. 그들을 리스프(Lisp)의 절반쯤까지 끌고 오는 데 성공했죠."
- 가이 스틸(Guy Steele), 자바(Java) 사양 공동 저자

소프트웨어 업계에는 뾰족한 머리 학자들(pointy-headed academics)과, 또 다른 만만치 않은 세력인 뾰족한 머리 상사들(pointy-haired bosses) 사이에서 끊임없는 투쟁이 벌어지고 있습니다. 뾰족한 머리 상사가 누구인지는 모두 아시겠죠? 기술 업계에 있는 대부분의 사람들은 이 만화 캐릭터를 알아볼 뿐만 아니라, 자신의 회사에 그 캐릭터의 모델이 된 실제 인물이 누구인지도 알고 있을 겁니다.

뾰족한 머리 상사는 흔하지만 좀처럼 함께 나타나지 않는 두 가지 자질을 기적적으로 결합합니다.
(a) 그는 기술에 대해 전혀 알지 못하고,
(b) 기술에 대해 매우 강한 의견을 가지고 있습니다.

예를 들어, 어떤 소프트웨어를 작성해야 한다고 가정해 봅시다. 뾰족한 머리 상사는 이 소프트웨어가 어떻게 작동해야 하는지 전혀 모르고, 프로그래밍 언어를 구별하지도 못하지만, 어떤 언어로 작성해야 할지는 알고 있습니다.

정확합니다. 그는 자바로 작성해야 한다고 생각합니다.

왜 그렇게 생각할까요? 뾰족한 머리 상사의 머릿속을 들여다봅시다. 그가 생각하는 것은 대략 이렇습니다. '자바는 표준이다. 언론에서 항상 자바에 대한 기사를 읽으니 분명 표준일 것이다. 표준이니까 자바를 사용한다고 해서 문제가 생길 일은 없을 것이다. 그리고 그 말은 항상 자바 프로그래머가 많을 것이라는 뜻이니, 지금 나를 위해 일하는 프로그래머들이 늘 그랬듯이 미스터리하게 그만두더라도 쉽게 대체할 수 있을 것이다.'

음, 그렇게 불합리하게 들리지 않습니다. 하지만 이 모든 것은 한 가지 암묵적인 가정에 기반하고 있으며, 그 가정은 틀린 것으로 판명됩니다. 뾰족한 머리 상사는 모든 프로그래밍 언어가 거의 동등하다고 믿습니다.

만약 그게 사실이라면, 그는 정확히 맞는 말을 하고 있는 겁니다. 만약 언어들이 모두 동등하다면, 당연히 다른 사람들이 모두 사용하는 언어를 사용하는 것이 좋겠죠.

하지만 모든 언어가 동등하지는 않으며, 저는 그 차이점에 대해 자세히 설명하지 않고도 이를 증명할 수 있다고 생각합니다. 만약 1992년에 뾰족한 머리 상사에게 소프트웨어를 어떤 언어로 작성해야 하느냐고 물었다면, 그는 오늘날과 마찬가지로 망설임 없이 답변했을 것입니다. 소프트웨어는 C++로 작성해야 한다고요. 하지만 만약 언어들이 모두 동등하다면, 뾰족한 머리 상사의 의견은 왜 바뀌어야 할까요? 사실, 자바 개발자들은 왜 굳이 새로운 언어를 만들려고 애썼을까요?

아마도 새로운 언어를 만들었다면, 기존 언어보다 어떤 면에서 더 낫다고 생각했기 때문일 겁니다. 실제로 제임스 고슬링(James Gosling)은 첫 자바 백서에서 자바가 C++의 일부 문제점을 해결하기 위해 설계되었다는 점을 분명히 합니다.

자, 이제 알겠죠? 언어들은 모두 동등하지 않습니다. 뾰족한 머리 상사의 머릿속을 거쳐 자바에 이르고, 다시 자바의 역사를 거슬러 그 기원까지 추적해 보면, 처음 출발했던 가설과 모순되는 결론에 이르게 됩니다.

그렇다면 누가 옳을까요? 제임스 고슬링일까요, 아니면 뾰족한 머리 상사일까요? 놀랄 것도 없이 고슬링이 옳습니다. 어떤 언어는 특정 문제에 대해 다른 언어보다 더 낫습니다. 그리고 이는 몇 가지 흥미로운 질문을 제기합니다. 자바는 특정 문제에 대해 C++보다 더 나은 것으로 설계되었습니다. 어떤 문제일까요? 자바가 더 나은 때는 언제이고, C++가 더 나은 때는 언제일까요? 이들 중 어느 것보다 다른 언어가 더 나은 상황도 있을까요?

이 질문을 고려하기 시작하는 순간, 여러분은 골치 아픈 문제를 건드린 셈입니다. 뾰족한 머리 상사가 이 문제의 복잡성을 완전히 파악해야 한다면, 그의 뇌는 폭발하고 말 겁니다. 그가 모든 언어를 동등하게 여기는 한, 그가 해야 할 일은 가장 유행하는 것처럼 보이는 언어를 선택하는 것뿐이며, 그것은 기술보다는 유행의 문제이므로 그도 아마 정답을 맞힐 수 있을 겁니다.

하지만 언어가 다르다면, 그는 갑자기 자신이 전혀 모르는 두 가지, 즉 해결해야 할 문제에 대한 약 20가지 주요 언어의 상대적 적합성과 각 언어에 대한 프로그래머, 라이브러리 등을 찾을 가능성 사이에서 최적의 균형을 찾아야 하는 두 가지 동시 방정식을 풀어야 합니다.

만약 그 문 반대편에 그런 복잡한 문제가 있다면, 뾰족한 머리 상사가 그 문을 열고 싶어 하지 않는 것은 놀라운 일이 아닙니다. 모든 프로그래밍 언어가 동등하다고 믿는 것의 단점은 그것이 사실이 아니라는 것입니다. 하지만 장점은 삶을 훨씬 더 단순하게 만든다는 것입니다.

그리고 저는 그것이 이 생각이 널리 퍼진 주된 이유라고 생각합니다. 그것은 편안한 생각입니다.

우리는 자바가 꽤 훌륭할 것이라고 생각합니다. 왜냐하면 자바가 멋지고 새로운 프로그래밍 언어이기 때문이죠. 정말 그럴까요? 프로그래밍 언어의 세계를 멀리서 보면, 자바가 최신 유행인 것처럼 보입니다. (충분히 멀리서 보면, 선 마이크로시스템즈(Sun Microsystems)가 광고하는 거대한 번쩍이는 간판만 보입니다.)

하지만 이 세계를 가까이서 보면, '멋있음'에도 정도가 있다는 것을 알 수 있습니다. 해커 서브컬처(hacker subculture) 내에는 자바보다 훨씬 더 멋있다고 여겨지는 펄(Perl)이라는 또 다른 언어가 있습니다. 예를 들어, 슬래시닷(Slashdot)은 펄로 생성됩니다. 저는 그 사람들이 자바 서버 페이지(Java Server Pages)를 사용한다고 생각하지 않습니다. 하지만 펄 사용자들을 깔보는 경향이 있는 파이썬(Python)이라는 또 다른, 더 새로운 언어가 있으며, 더 많은 언어가 대기 중입니다.

이러한 언어들, 즉 자바, 펄, 파이썬을 순서대로 살펴보면 흥미로운 패턴을 발견할 수 있습니다. 적어도, 리스프 해커라면 이 패턴을 알아차릴 겁니다. 각각의 언어는 점진적으로 리스프와 더 비슷해지고 있습니다. 파이썬은 많은 리스프 해커들이 실수라고 여기는 기능까지도 복사합니다.

간단한 리스프 프로그램을 파이썬으로 한 줄 한 줄 번역할 수 있을 정도입니다. 2002년, 프로그래밍 언어는 거의 1958년에 도달했습니다.

## 수학을 따라잡다 (Catching Up with Math)

제가 의미하는 바는 리스프가 1958년에 존 매카시(John McCarthy)에 의해 처음 발견되었고, 대중적인 프로그래밍 언어들은 이제야 그가 그때 개발한 아이디어들을 따라잡고 있다는 것입니다.

자, 어떻게 그럴 수 있을까요? 컴퓨터 기술은 매우 빠르게 변하는 것이 아닌가요? 1958년의 컴퓨터는 손목시계만한 처리 능력을 가진 냉장고 크기의 거대 괴물들이었습니다. 그렇게 오래된 기술이 어떻게 최신 개발보다도 뛰어날 수 있을까요?

제가 알려드리겠습니다. 리스프는 사실 프로그래밍 언어로 설계된 것이 아니었기 때문입니다. 적어도 우리가 오늘날 의미하는 방식으로는 말이죠. 우리가 프로그래밍 언어라고 말하는 것은 컴퓨터에게 무엇을 해야 할지 지시하는 데 사용하는 것입니다. 매카시는 결국 이런 의미의 프로그래밍 언어를 개발할 의도가 있었지만, 우리가 실제로 얻게 된 리스프는 그가 이론적 연습으로서 수행한 별개의 것에 기반했습니다. 즉, 튜링 머신(Turing Machine)에 대한 더 편리한 대안을 정의하려는 노력이었습니다.

매카시가 나중에 말했듯이,

> 리스프가 튜링 머신보다 더 깔끔하다는 것을 보여주는 또 다른 방법은 범용 리스프 함수를 작성하고, 그것이 범용 튜링 머신에 대한 설명보다 더 간결하고 이해하기 쉽다는 것을 보여주는 것이었습니다. 이것이 바로 리스프 표현식의 값을 계산하는 리스프 함수 `eval`이었습니다... `eval`을 작성하려면 리스프 함수를 리스프 데이터로 표현하는 표기법을 발명해야 했는데, 이러한 표기법은 실제로 리스프 프로그램을 표현하는 데 사용될 것이라고는 전혀 생각하지 않고 논문 목적으로 고안되었습니다.

그다음 1958년 말쯤, 매카시의 대학원생 중 한 명인 스티브 러셀(Steve Russell)은 이 `eval`의 정의를 보고 그것을 기계어로 번역하면 리스프 인터프리터(interpreter)가 될 것이라는 사실을 깨달았습니다.

이것은 당시로서는 큰 놀라움이었습니다. 매카시는 나중에 인터뷰에서 이렇게 말했습니다.

> 스티브 러셀이 "이 `eval`을 프로그래밍해 보는 게 어때요?"라고 말했을 때, 저는 그에게 "하하, 이론과 실제를 혼동하고 있군. 이 `eval`은 읽기 위한 것이지, 계산하기 위한 것이 아니야"라고 말했습니다. 하지만 그는 계속 진행했습니다. 즉, 그는 제 논문에 있는 `eval`을 [IBM] 704 기계 코드로 컴파일하고 버그를 수정한 다음, 이를 리스프 인터프리터로 광고했는데, 실제로 그랬습니다. 그래서 그 시점에서 리스프는 본질적으로 오늘날의 형태를 갖추게 되었습니다...

갑자기, 불과 몇 주 만에 매카시는 자신의 이론적 연습이 실제 프로그래밍 언어로, 그것도 그가 의도했던 것보다 훨씬 더 강력한 언어로 변모하는 것을 발견했습니다.

그래서 1950년대의 이 언어가 구식이 아닌 짧은 설명은 그것이 기술이 아니라 수학이었기 때문이며, 수학은 구식이 되지 않는다는 것입니다. 리스프를 1950년대의 하드웨어와 비교하는 것이 아니라, 예를 들어 1960년에 발견되어 여전히 가장 빠른 범용 정렬 알고리즘인 퀵 정렬(Quicksort)과 비교하는 것이 올바릅니다.

1950년대부터 살아남은 또 다른 언어가 있는데, 바로 포트란(Fortran)입니다. 포트란은 언어 설계에 대한 정반대의 접근 방식을 보여줍니다. 리스프는 예상치 못하게 프로그래밍 언어로 변모한 이론의 한 조각이었습니다. 포트란은 의도적으로 프로그래밍 언어로 개발되었지만, 지금 우리가 생각하기에는 매우 저수준(low-level)의 언어였습니다.

1956년에 개발된 포트란 I(Fortran I)은 오늘날의 포트란과는 매우 다른 종류였습니다. 포트란 I은 수학이 포함된 어셈블리 언어(assembly language)와 거의 같았습니다. 어떤 면에서는 더 최신 어셈블리 언어보다 덜 강력했습니다. 예를 들어 서브루틴(subroutine)은 없고, 오직 분기(branch)만 있었습니다.

오늘날의 포트란은 이제 포트란 I보다는 리스프에 더 가깝다고 할 수 있습니다.

리스프와 포트란은 두 개의 별개의 진화 트리의 줄기였습니다. 하나는 수학에 뿌리를 두었고, 다른 하나는 기계 아키텍처(machine architecture)에 뿌리를 두었습니다. 이 두 트리는 그 이후로 계속 수렴해 왔습니다.

리스프는 처음부터 강력했지만, 다음 20년 동안 빨라졌습니다. 이른바 주류 언어들은 처음에는 빨랐지만, 다음 40년 동안 점진적으로 더 강력해졌고, 이제 가장 발전된 언어들은 리스프에 상당히 가깝습니다.

가깝지만, 여전히 몇 가지가 빠져 있습니다....

## 리스프를 다르게 만든 것 (What Made Lisp Different)

리스프가 처음 개발되었을 때, 아홉 가지 새로운 아이디어를 구현했습니다. 이 중 일부는 이제 당연하게 여겨지지만, 다른 일부는 더 고급 언어에서만 볼 수 있으며, 두 가지는 여전히 리스프에만 있습니다. 아홉 가지 아이디어를 주류에 채택된 순서대로 나열하면 다음과 같습니다.

1.  **조건문(Conditionals)**. 조건문은 `if-then-else` 구조를 말합니다. 지금은 당연하게 여기지만, 포트란 I에는 없었습니다. 포트란 I은 기본 기계 명령어에 밀접하게 기반한 조건부 `goto`만 가지고 있었습니다.
2.  **함수 타입(A function type)**. 리스프에서 함수는 정수나 문자열처럼 데이터 타입입니다. 리터럴(literal) 표현을 가지며, 변수에 저장될 수 있고, 인수로 전달될 수 있습니다.
3.  **재귀(Recursion)**. 리스프는 이를 지원한 최초의 프로그래밍 언어였습니다.
4.  **동적 타이핑(Dynamic typing)**. 리스프에서는 모든 변수가 사실상 포인터입니다. 값이 타입을 가지며, 변수가 타입을 가지는 것이 아닙니다. 변수에 할당하거나 바인딩하는 것은 가리키는 대상이 아니라 포인터를 복사하는 것을 의미합니다.
5.  **가비지 컬렉션(Garbage-collection)**.
6.  **표현식으로 구성된 프로그램(Programs composed of expressions)**. 리스프 프로그램은 표현식들의 트리이며, 각 표현식은 값을 반환합니다. 이는 표현식과 문장(statement)을 구별하는 포트란 및 대부분의 후속 언어와 대조됩니다. 포트란 I에서는 문장을 중첩할 수 없었기 때문에 이러한 구별을 두는 것이 자연스러웠습니다. 따라서 수학을 작동시키기 위해서는 표현식이 필요했지만, 다른 어떤 것도 값을 반환하게 할 이유가 없었습니다. 왜냐하면 그 값을 기다리는 것이 있을 수 없었기 때문입니다. 이러한 제한은 블록 구조 언어(block-structured languages)의 등장과 함께 사라졌지만, 그때는 이미 너무 늦었습니다. 표현식과 문장 간의 구별은 굳어졌고, 포트란에서 알골(Algol)로, 그리고 그들의 후손들에게까지 퍼졌습니다.
7.  **심볼 타입(A symbol type)**. 심볼은 해시 테이블(hash table)에 저장된 문자열에 대한 사실상의 포인터입니다. 따라서 각 문자를 비교하는 대신 포인터를 비교하여 동등성을 테스트할 수 있습니다.
8.  **심볼과 상수의 트리로 코드를 표현하는 표기법(A notation for code using trees of symbols and constants)**.
9.  **언어 전체가 항상 존재함(The whole language there all the time)**. 읽기 시간(read-time), 컴파일 시간(compile-time), 런타임(runtime) 간에 실제 구별이 없습니다. 읽는 동안 코드를 컴파일하거나 실행할 수 있고, 컴파일하는 동안 코드를 읽거나 실행할 수 있으며, 런타임에 코드를 읽거나 컴파일할 수 있습니다. 읽기 시간에 코드를 실행하면 사용자가 리스프의 문법을 재프로그래밍할 수 있습니다. 컴파일 시간에 코드를 실행하는 것은 매크로(macros)의 기반입니다. 런타임에 컴파일하는 것은 이맥스(Emacs)와 같은 프로그램에서 리스프가 확장 언어(extension language)로 사용되는 기반입니다. 그리고 런타임에 읽는 것은 프로그램들이 S-표현식(s-expressions), 즉 최근 XML로 재발명된 아이디어를 사용하여 통신할 수 있게 합니다.

리스프가 처음 등장했을 때, 이러한 아이디어들은 1950년대 후반에 사용 가능한 하드웨어에 의해 크게 좌우되었던 일반적인 프로그래밍 관행과는 거리가 멀었습니다. 시간이 지남에 따라, 연속적인 인기 언어들에 구현된 기본 언어는 점진적으로 리스프를 향해 진화해 왔습니다. 1번부터 5번까지의 아이디어는 이제 널리 퍼져 있습니다. 6번은 주류에 나타나기 시작했습니다. 파이썬은 7번의 한 형태를 가지고 있지만, 이에 대한 문법은 없는 것 같습니다.

8번 아이디어에 관해서는, 이것이 가장 흥미로운 것일 수 있습니다. 8번과 9번 아이디어는 스티브 러셀이 매카시가 구현할 의도가 전혀 없었던 것을 구현했기 때문에 우연히 리스프의 일부가 되었습니다. 그런데 이 아이디어들이 리스프의 이상한 외형과 가장 독특한 특징들을 담당하는 것으로 밝혀졌습니다. 리스프가 이상하게 보이는 것은 이상한 문법 때문이라기보다는 문법이 없기 때문입니다. 다른 언어들이 파싱될 때 이면에서 구축되는 구문 분석 트리(parse trees)에 프로그램을 직접 표현하며, 이 트리들은 리스프 데이터 구조인 리스트(lists)로 만들어집니다.

언어를 자체 데이터 구조로 표현하는 것은 매우 강력한 기능으로 판명됩니다. 8번과 9번 아이디어는 함께 여러분이 프로그램을 작성하는 프로그램을 작성할 수 있다는 것을 의미합니다. 그것은 기이한 생각처럼 들릴 수 있지만, 리스프에서는 일상적인 일입니다. 가장 흔한 방법은 매크로라고 불리는 것을 사용하는 것입니다.

"매크로"라는 용어는 리스프에서 다른 언어에서의 의미와 다릅니다. 리스프 매크로는 약어부터 새로운 언어의 컴파일러까지 무엇이든 될 수 있습니다. 리스프를 정말 이해하고 싶거나, 단순히 프로그래밍의 지평을 넓히고 싶다면, 매크로에 대해 더 많이 배우세요.

매크로(리스프의 의미에서)는 제가 아는 한 여전히 리스프에만 있습니다. 이는 부분적으로 매크로를 가지려면 언어를 리스프만큼 이상하게 만들어야 할 수도 있기 때문입니다. 또한, 만약 마지막 한 단계의 힘을 더한다면, 더 이상 새로운 언어를 발명했다고 주장할 수 없고, 단지 리스프의 새로운 방언을 발명했다고만 주장할 수 있기 때문일 수도 있습니다.

이것은 주로 농담으로 말하는 것이지만, 상당히 사실입니다. 만약 `car`, `cdr`, `cons`, `quote`, `cond`, `atom`, `eq` 그리고 리스트로 표현되는 함수에 대한 표기법을 가진 언어를 정의한다면, 그 언어로부터 리스프의 나머지 전체를 만들 수 있습니다. 이것이 사실 리스프의 정의적 특징입니다. 매카시가 리스프에 현재의 형태를 부여한 것은 바로 이렇게 만들기 위함이었습니다.

## 언어가 중요한 이유 (Where Languages Matter)

그렇다면 리스프가 주류 언어들이 점근적으로 접근하는 일종의 한계를 나타낸다고 가정해 봅시다. 그렇다면 실제로 리스프를 사용하여 소프트웨어를 작성해야 한다는 의미일까요? 덜 강력한 언어를 사용함으로써 얼마나 손해를 볼까요? 때로는 혁신의 최첨단에 있지 않는 것이 더 현명하지 않을까요?

그리고 인기가 어느 정도는 그 자체로 정당성이 되지 않을까요? 예를 들어, 뾰족한 머리 상사가 프로그래머를 쉽게 고용할 수 있는 언어를 사용하고 싶어 하는 것이 옳지 않을까요?

물론 프로그래밍 언어 선택이 크게 중요하지 않은 프로젝트도 있습니다. 일반적으로 애플리케이션이 까다로울수록 강력한 언어를 사용함으로써 더 많은 이점을 얻을 수 있습니다. 하지만 많은 프로젝트는 전혀 까다롭지 않습니다.

대부분의 프로그래밍은 작은 접착제 프로그램(glue programs)을 작성하는 것으로 구성되며, 이러한 작은 접착제 프로그램의 경우 이미 익숙하고 필요한 모든 작업을 위한 좋은 라이브러리가 있는 어떤 언어든 사용할 수 있습니다. 단순히 한 윈도우(Windows) 애플리케이션에서 다른 윈도우 애플리케이션으로 데이터를 공급해야 한다면, 물론 비주얼 베이직(Visual Basic)을 사용해도 됩니다.

리스프로도 작은 접착제 프로그램을 작성할 수 있지만(저는 리스프를 데스크톱 계산기로 사용합니다), 리스프와 같은 언어의 가장 큰 장점은 다른 스펙트럼의 끝에 있습니다. 즉, 치열한 경쟁 속에서 어려운 문제를 해결하기 위해 정교한 프로그램을 작성해야 할 때입니다.

좋은 예로는 ITA 소프트웨어(ITA Software)가 오르비츠(Orbitz)에 라이선스를 제공하는 항공 요금 검색 프로그램이 있습니다. 이들은 이미 트래블로시티(Travelocity)와 익스피디아(Expedia)라는 두 개의 크고 확고한 경쟁자들이 지배하는 시장에 진입했고, 기술적으로 그들을 압도한 것으로 보입니다.

ITA 애플리케이션의 핵심은 20만 줄의 커먼 리스프(Common Lisp) 프로그램으로, 경쟁사보다 수십만 배 더 많은 가능성을 검색합니다. 경쟁사들은 여전히 메인프레임(mainframe) 시대의 프로그래밍 기술을 사용하는 것으로 보입니다 (비록 ITA도 어떤 의미에서는 메인프레임 시대의 프로그래밍 언어를 사용하고 있지만).

저는 ITA의 코드를 본 적이 없지만, 그들의 최고 해커 중 한 명에 따르면 매크로를 많이 사용한다고 합니다. 이 말을 듣고 놀랍지 않았습니다.

## 구심력 (Centripetal Forces)

흔치 않은 기술을 사용하는 데 비용이 들지 않는다는 말은 아닙니다. 뾰족한 머리 상사가 이것에 대해 걱정하는 것이 완전히 틀린 것은 아닙니다. 하지만 그는 위험을 이해하지 못하기 때문에 그것을 과장하는 경향이 있습니다.

흔치 않은 언어를 사용함으로써 발생할 수 있는 세 가지 문제를 생각할 수 있습니다. 여러분의 프로그램이 다른 언어로 작성된 프로그램과 잘 작동하지 않을 수 있습니다. 사용할 수 있는 라이브러리가 더 적을 수 있습니다. 그리고 프로그래머를 고용하는 데 어려움을 겪을 수 있습니다.

이러한 문제들 각각이 얼마나 심각할까요? 첫 번째 문제의 중요성은 전체 시스템을 제어할 수 있는지 여부에 따라 달라집니다. 만약 버그가 많고 폐쇄된 운영 체제(이름은 언급하지 않겠습니다) 위에서 원격 사용자의 컴퓨터에서 실행되어야 하는 소프트웨어를 작성한다면, OS와 같은 언어로 애플리케이션을 작성하는 것이 유리할 수 있습니다.

하지만 만약 ITA처럼 전체 시스템을 제어하고 모든 부품의 소스 코드를 가지고 있다면, 원하는 어떤 언어든 사용할 수 있습니다. 어떤 비호환성이 발생하더라도 직접 고칠 수 있습니다.

서버 기반 애플리케이션에서는 가장 진보된 기술을 사용할 수 있으며, 이것이 조나단 에릭슨(Jonathan Erickson)이 "프로그래밍 언어 르네상스"라고 부르는 현상의 주요 원인이라고 생각합니다. 이것이 바로 우리가 펄이나 파이썬과 같은 새로운 언어에 대해 듣는 이유입니다. 사람들이 이 언어들을 윈도우 앱을 작성하는 데 사용하기 때문이 아니라, 서버에서 사용하기 때문입니다. 그리고 소프트웨어가 데스크톱에서 서버로 이동함에 따라(마이크로소프트(Microsoft)조차도 받아들이는 미래), 중간 수준의 기술을 사용해야 한다는 압력은 점점 줄어들 것입니다.

라이브러리의 중요성 또한 애플리케이션에 따라 달라집니다. 덜 까다로운 문제의 경우, 라이브러리의 가용성이 언어의 내재적 강력함보다 중요할 수 있습니다. 손익분기점은 어디일까요? 정확히 말하기는 어렵지만, 어디든 그것은 여러분이 "애플리케이션"이라고 부를 만한 것보다 한참 아래에 있을 겁니다. 만약 어떤 회사가 자신을 소프트웨어 사업에 종사한다고 여기고, 그들이 제품 중 하나가 될 애플리케이션을 작성하고 있다면, 아마도 여러 명의 해커가 참여하고 작성하는 데 최소 6개월이 걸릴 것입니다. 그 정도 규모의 프로젝트에서는 강력한 언어가 기존 라이브러리의 편리함보다 중요하게 여겨지기 시작할 것입니다.

뾰족한 머리 상사의 세 번째 걱정인, 프로그래머 고용의 어려움은 사실 헛된 고민이라고 생각합니다. 결국 몇 명의 해커를 고용해야 할까요? 이제는 소프트웨어가 10명 미만의 팀으로 개발될 때 가장 좋다는 것을 모두 알 겁니다. 그리고 어떤 언어든 들어본 적이 있는 언어라면 그 정도 규모의 해커를 고용하는 데 문제가 없을 것입니다. 만약 10명의 리스프 해커를 찾을 수 없다면, 여러분의 회사는 소프트웨어 개발에 적합한 도시에 위치하지 않은 것일 겁니다.

사실, 더 강력한 언어를 선택하면 필요한 팀 규모가 줄어들 가능성이 높습니다. 왜냐하면 (a) 더 강력한 언어를 사용하면 아마도 해커가 그렇게 많이 필요하지 않을 것이고, (b) 더 발전된 언어로 작업하는 해커들은 더 똑똑할 가능성이 높기 때문입니다.

"표준" 기술로 인식되는 것을 사용하라는 많은 압력을 받지 않을 것이라는 말은 아닙니다. 비아웹(Viaweb, 현 야후 스토어(Yahoo Store))에서 우리는 리스프를 사용하여 벤처 캐피털(VC)과 잠재적 인수자들 사이에서 눈썹을 치켜세우게 만들었습니다. 하지만 우리는 또한 썬(Sun)과 같은 "산업용 강도(industrial strength)" 서버 대신 일반 인텔(Intel) 박스를 서버로 사용하고, 윈도우 NT(Windows NT)와 같은 진정한 상용 OS 대신 당시에는 잘 알려지지 않은 오픈 소스 유닉스(Unix) 변형인 FreeBSD를 사용하고, 이제 아무도 기억하지 못하는 가상의 전자상거래 표준인 SET을 무시하는 등의 이유로도 눈썹을 치켜세우게 만들었습니다.

정장 입은 사람들이 기술적 결정을 내리게 해서는 안 됩니다. 우리가 리스프를 사용했다는 사실이 일부 잠재적 인수자들을 놀라게 했을까요? 일부는 약간 그랬지만, 우리가 리스프를 사용하지 않았다면, 그들이 우리를 인수하고 싶어 할 만한 소프트웨어를 작성할 수 없었을 겁니다. 그들에게는 이상 현상으로 보였던 것이 사실은 원인과 결과였습니다.

스타트업을 시작한다면, VC나 잠재적 인수자들을 만족시키기 위해 제품을 설계하지 마세요. 사용자들을 만족시키기 위해 제품을 설계하세요. 사용자들을 얻으면, 다른 모든 것은 따라올 것입니다. 그리고 사용자들을 얻지 못한다면, 여러분의 기술 선택이 얼마나 편안하게 정통적이었는지 아무도 신경 쓰지 않을 것입니다.

## 평범함의 대가 (The Cost of Being Average)

덜 강력한 언어를 사용함으로써 얼마나 손해를 볼까요? 실제로 이에 대한 몇 가지 데이터가 있습니다. '파워(power)'의 가장 편리한 측정 지표는 아마 '코드 크기(code size)'일 겁니다. 고수준 언어의 목적은 더 큰 추상화, 즉 말하자면 더 큰 벽돌을 제공하여 주어진 크기의 벽을 쌓는 데 필요한 벽돌의 수를 줄이는 것입니다. 따라서 언어가 강력할수록 프로그램은 더 짧아집니다(물론 단순히 글자 수가 아니라 고유한 요소의 수에서 말이죠).

더 강력한 언어가 어떻게 더 짧은 프로그램을 작성할 수 있게 해 줄까요? 언어가 허락한다면 사용할 수 있는 한 가지 기술은 '하향식 프로그래밍(bottom-up programming)'이라고 불리는 것입니다. 기본 언어로 단순히 애플리케이션을 작성하는 대신, 기본 언어 위에 여러분과 같은 프로그램을 작성하기 위한 언어를 구축한 다음, 그 언어로 프로그램을 작성하는 것입니다. 결합된 코드는 전체 프로그램을 기본 언어로 작성했을 때보다 훨씬 짧을 수 있습니다. 사실 대부분의 압축 알고리즘이 이런 방식으로 작동합니다.

하향식 프로그램은 수정하기도 더 쉬울 것입니다. 왜냐하면 많은 경우 언어 레이어(language layer)는 전혀 변경할 필요가 없기 때문입니다.

코드 크기가 중요한데, 프로그램을 작성하는 데 걸리는 시간은 주로 프로그램 길이에 따라 달라지기 때문입니다. 만약 여러분의 프로그램이 다른 언어에서 3배 더 길어진다면, 작성하는 데 3배 더 오래 걸릴 것입니다. 그리고 사람을 더 고용한다고 해서 이것을 피할 수는 없습니다. 왜냐하면 특정 규모를 넘어서면 신규 채용은 실제로 순손실(net lose)이기 때문입니다. 프레드 브룩스(Fred Brooks)는 그의 유명한 책 『맨먼스 미신(The Mythical Man-Month)』에서 이 현상을 설명했으며, 제가 본 모든 것이 그의 말을 확증하는 경향이 있습니다.

그렇다면 리스프로 프로그램을 작성하면 프로그램이 얼마나 더 짧아질까요? 예를 들어 리스프와 C를 비교했을 때 제가 들었던 대부분의 수치는 7~10배 정도였습니다. 하지만 최근 뉴 아키텍트(New Architect) 매거진에 실린 ITA에 대한 기사에서는 "리스프 한 줄이 C 코드 20줄을 대체할 수 있다"고 했으며, 이 기사는 ITA 사장의 인용문으로 가득했기 때문에 저는 그들이 이 수치를 ITA로부터 얻었을 것이라고 가정합니다. 만약 그렇다면, 우리는 이 수치를 신뢰할 수 있습니다. ITA의 소프트웨어는 리스프뿐만 아니라 많은 C와 C++ 코드도 포함하고 있으므로, 그들은 경험을 바탕으로 말하고 있는 것입니다.

제 생각에는 이 배율조차 일정하지 않습니다. 더 어려운 문제에 직면할 때와 더 똑똑한 프로그래머가 있을 때 증가한다고 생각합니다. 정말 뛰어난 해커는 더 나은 도구를 통해 더 많은 것을 짜낼 수 있습니다.

어쨌든, 곡선상의 한 데이터 포인트로서, 만약 ITA와 경쟁하여 소프트웨어를 C로 작성하기로 선택한다면, 그들은 여러분보다 20배 더 빠르게 소프트웨어를 개발할 수 있을 겁니다. 여러분이 새로운 기능을 개발하는 데 1년을 썼다면, 그들은 3주도 채 안 되어 복제할 수 있을 겁니다. 반면에 그들이 새로운 것을 개발하는 데 단 3개월만 썼다면, 여러분이 그것을 갖게 되기까지는 5년이 걸릴 것입니다.

그리고 그거 아세요? 그건 최상의 시나리오입니다. 코드 크기 비율에 대해 이야기할 때는 암묵적으로 약한 언어로 프로그램을 실제로 작성할 수 있다고 가정하는 겁니다. 하지만 사실 프로그래머가 할 수 있는 일에는 한계가 있습니다. 너무 저수준의 언어로 어려운 문제를 해결하려고 하면, 동시에 머릿속에 담아두어야 할 것이 너무 많아지는 지점에 도달하게 됩니다.

그래서 제가 ITA의 가상 경쟁자가 ITA가 리스프로 3개월 만에 작성할 수 있는 것을 복제하는 데 5년이 걸릴 것이라고 말할 때, 그것은 아무런 문제가 없을 때 5년이라는 의미입니다. 사실, 대부분의 회사에서 일이 돌아가는 방식으로는 5년이 걸릴 개발 프로젝트는 아예 완료되지 않을 가능성이 높습니다.

이것이 극단적인 경우라는 것은 인정합니다. ITA의 해커들은 비정상적으로 똑똑해 보이고, C는 상당히 저수준 언어입니다. 하지만 경쟁 시장에서는 2~3배의 차이만으로도 항상 뒤처질 수밖에 없을 겁니다.

## 레시피 (A Recipe)

이것은 뾰족한 머리 상사가 생각조차 하고 싶지 않은 종류의 가능성입니다. 그래서 대부분은 생각하지 않습니다. 왜냐하면 결국 뾰족한 머리 상사는 자신의 회사가 망해도 그것이 자신의 잘못이라는 것을 아무도 증명할 수만 없다면 크게 신경 쓰지 않기 때문입니다. 그 개인에게 가장 안전한 계획은 무리의 한가운데에 바싹 붙어있는 것입니다.

대기업에서는 이러한 접근 방식을 "업계 모범 사례(industry best practice)"라고 부릅니다. 그 목적은 뾰족한 머리 상사를 책임으로부터 보호하는 것입니다. 만약 그가 "업계 모범 사례"를 선택했고 회사가 손실을 입더라도, 그는 비난받을 수 없습니다. 그가 선택한 것이 아니라, 업계가 선택한 것이니까요.

저는 이 용어가 원래 회계 방법 등을 설명하는 데 사용되었다고 생각합니다. 대략적인 의미는 "이상한 짓 하지 마라"입니다. 그리고 회계에서는 아마 좋은 생각일 겁니다. "최첨단"과 "회계"라는 용어는 함께 잘 어울리지 않습니다. 하지만 이 기준을 기술 결정에 가져오면 잘못된 답변을 얻기 시작할 겁니다.

기술은 종종 최첨단이어야 합니다. 프로그래밍 언어에서는 에런 갯(Erann Gat)이 지적했듯이, "업계 모범 사례"가 실제로 가져다주는 것은 최고가 아니라 단지 평균일 뿐입니다. 어떤 결정이 여러분이 더 공격적인 경쟁자들보다 훨씬 느린 속도로 소프트웨어를 개발하게 만든다면, "모범 사례"는 잘못된 명칭입니다.

그래서 저는 매우 가치 있다고 생각하는 두 가지 정보를 얻었습니다. 사실, 제 자신의 경험으로도 알고 있습니다. 첫째, 언어는 힘이 다릅니다. 둘째, 대부분의 관리자들은 이를 의도적으로 무시합니다. 이 두 가지 사실을 합치면 말 그대로 돈을 버는 레시피가 됩니다. ITA는 이 레시피가 작동하는 예시입니다.

소프트웨어 사업에서 이기고 싶다면, 가장 어려운 문제를 찾아 가장 강력한 언어를 사용하고, 경쟁사 뾰족한 머리 상사들이 평균으로 회귀할 때까지 기다리세요.

## 부록: 강력함 (Appendix: Power)

프로그래밍 언어의 상대적 강력함에 대해 제가 의미하는 바를 설명하기 위해 다음 문제를 고려해 봅시다. 우리는 누산기(accumulator)를 생성하는 함수를 작성하려고 합니다. 이 함수는 숫자 `n`을 받아 다른 숫자 `i`를 받아 `n`을 `i`만큼 증가시킨 값을 반환하는 함수를 반환합니다.

(이것은 단순히 '더하는' 것이 아니라 '증가시키는' 것입니다. 누산기는 누적되어야 합니다.)

커먼 리스프(Common Lisp)에서는 다음과 같습니다.

```lisp
(defun foo (n)
  (lambda (i) (incf n i)))
```

그리고 펄 5(Perl 5)에서는 다음과 같습니다.

```perl
sub foo {  
  my ($n) = @_;
  sub {$n += shift}
}
```

이것은 펄에서 매개변수를 수동으로 추출해야 하기 때문에 리스프 버전보다 요소가 더 많습니다.

스몰토크(Smalltalk)에서는 코드가 리스프보다 약간 더 깁니다.

```smalltalk
foo: n                              
  |s|                      
  s := n.                          
  ^[:i| s := s+i. ]
```

일반적으로 어휘 변수(lexical variables)는 작동하지만, 매개변수에 할당할 수 없기 때문에 새 변수 `s`를 생성해야 하기 때문입니다.

자바스크립트(Javascript)에서는 다시 약간 더 깁니다. 자바스크립트는 문장과 표현식의 구별을 유지하므로, 값을 반환하기 위해 명시적인 `return` 문이 필요합니다.

```javascript
function foo(n) { 
  return function (i) { 
           return n += i } }
```

(공평하게 말하면, 펄도 이 구별을 유지하지만, `return`을 생략할 수 있게 함으로써 전형적인 펄 방식으로 처리합니다.)

리스프/펄/스몰토크/자바스크립트 코드를 파이썬으로 번역하려고 하면 몇 가지 제한에 부딪힙니다. 파이썬은 어휘 변수를 완전히 지원하지 않기 때문에, `n`의 값을 저장할 데이터 구조를 생성해야 합니다. 그리고 파이썬은 함수 데이터 타입을 가지고 있지만, 이를 위한 리터럴 표현은 없습니다(본문이 단일 표현식일 경우 제외). 따라서 반환할 명명된 함수를 생성해야 합니다. 결과는 다음과 같습니다.

```python
def foo(n):
  s = [n]
  def bar(i):
    s[0] += i
    return s[0] 
  return bar
```

파이썬 사용자들은 다음과 같이 작성할 수 없는 이유를 정당하게 물을 수 있습니다.

```python
def foo(n):
  return lambda i: return n += i
```

혹은 심지어

```python
def foo(n):
  lambda i: n += i
```

그리고 제 추측으로는 언젠가는 그렇게 될 것입니다. (하지만 파이썬이 리스프만큼 진화하기를 기다리고 싶지 않다면, 언제든지 그냥...)

객체 지향(OO) 언어에서는 클로저(closure, 둘러싸는 스코프(scope)에 정의된 변수를 참조하는 함수)를 제한된 범위 내에서 시뮬레이션할 수 있습니다. 즉, 하나의 메서드와 둘러싸는 스코프의 각 변수를 대체할 필드를 가진 클래스를 정의하는 것입니다. 이 방식은 프로그래머가 완전한 어휘 스코프 지원이 있는 언어에서는 컴파일러가 수행할 코드 분석을 직접 수행하게 만들고, 여러 함수가 동일한 변수를 참조하는 경우에는 작동하지 않지만, 이처럼 간단한 경우에는 충분합니다.

파이썬 전문가들은 이것이 파이썬에서 문제를 해결하는 선호되는 방법이라는 데 동의하는 것 같습니다. 다음 중 하나를 작성합니다.

```python
def foo(n):
  class acc:
    def __init__(self, s):
        self.s = s
    def inc(self, i):
        self.s += i
        return self.s
  return acc(n).inc
```

또는

```python
class foo:
  def __init__(self, n):
      self.n = n
  def __call__(self, i):
      self.n += i
      return self.n
```

이것들을 포함한 이유는 파이썬 옹호자들이 제가 언어를 잘못 표현했다고 말하는 것을 원치 않기 때문이지만, 둘 다 첫 번째 버전보다 더 복잡해 보입니다. 둘 다 같은 일을 합니다. 누산기를 저장할 별도의 공간을 설정하는 것이죠. 단지 리스트의 머리(head of a list) 대신 객체의 필드일 뿐입니다. 그리고 이 특별한 예약된 필드 이름, 특히 `__call__`을 사용하는 것은 약간의 꼼수(hack)처럼 보입니다.

펄과 파이썬의 경쟁에서 파이썬 해커들의 주장은 파이썬이 펄에 대한 더 우아한 대안이라는 것이지만, 이 사례는 강력함이 궁극적인 우아함이라는 것을 보여줍니다. 펄 프로그램은 문법이 다소 못생겼음에도 불구하고 더 간단합니다(요소가 더 적습니다).

다른 언어는 어떨까요? 이 강연에서 언급된 다른 언어들—포트란, C, C++, 자바, 그리고 비주얼 베이직—에서는 이 문제를 실제로 해결할 수 있는지 불분명합니다.

켄 앤더슨(Ken Anderson)은 자바에서 다음과 같은 코드가 가장 가깝다고 말합니다.

```java
public interface Inttoint {
  public int call(int i);
}

public static Inttoint foo(final int n) {
  return new Inttoint() {
    int s = n;
    public int call(int i) {
    s = s + i;
    return s;
    }};
}
```

이것은 정수에만 작동하기 때문에 사양에 미치지 못합니다. 자바 해커들과 여러 차례 이메일을 주고받은 결과, 앞선 예시들처럼 작동하는 제대로 된 다형성(polymorphic) 버전을 작성하는 것은 '매우 어색하거나 불가능에 가깝다'고 말할 수 있습니다. 만약 누군가 작성하고 싶다면 매우 궁금하겠지만, 저는 개인적으로 시간 초과되었습니다.

물론 다른 언어로는 이 문제를 해결할 수 없다는 것이 글자 그대로 사실은 아닙니다. 이 모든 언어가 튜링 동등(Turing-equivalent)하다는 사실은 엄밀히 말하면 어떤 프로그램이든 어떤 언어로든 작성할 수 있음을 의미합니다. 그렇다면 어떻게 할까요? 극한의 경우, 덜 강력한 언어로 리스프 인터프리터를 작성하는 것입니다.

이것은 농담처럼 들리지만, 큰 프로그래밍 프로젝트에서 다양한 정도로 너무 자주 발생해서 이 현상에 대한 이름이 있습니다. 바로 그린스펀의 열 번째 규칙(Greenspun's Tenth Rule)입니다.

> 충분히 복잡한 C 또는 포트란 프로그램에는 Common Lisp의 절반에 해당하는 즉흥적이고 비공식적으로 지정된 버그 투성이의 느린 구현이 포함되어 있다.

어려운 문제를 해결하려고 할 때, 문제는 여러분이 충분히 강력한 언어를 사용할 것인지가 아니라, (a) 강력한 언어를 사용할 것인지, (b) 사실상 그 언어를 위한 인터프리터를 작성할 것인지, 아니면 (c) 스스로 그 언어를 위한 인간 컴파일러가 될 것인지 하는 것입니다. 우리는 이미 파이썬 예시에서 이것이 시작되는 것을 봅니다. 여기서 우리는 사실상 어휘 변수를 구현하기 위해 컴파일러가 생성할 코드를 시뮬레이션하고 있습니다.

이러한 관행은 흔할 뿐만 아니라 제도화되어 있습니다. 예를 들어, 객체 지향(OO) 세계에서는 "패턴"에 대해 많이 듣습니다. 저는 이러한 패턴들이 때때로 (c)의 경우, 즉 인간 컴파일러의 작업의 증거가 아닌지 궁금합니다. 제 프로그램에서 패턴을 볼 때, 저는 그것을 문제의 신호로 간주합니다. 프로그램의 형태는 해결해야 할 문제만을 반영해야 합니다. 코드의 다른 규칙성은, 적어도 저에게는, 제가 충분히 강력하지 않은 추상화를 사용하고 있다는 신호입니다. 종종 제가 작성해야 할 어떤 매크로의 확장을 손으로 생성하고 있다는 신호이기도 합니다.

---

**주석**

IBM 704 CPU는 냉장고 크기 정도였지만 훨씬 무거웠다. CPU는 3150파운드였고, 4K 램은 별도의 상자에 담겨 4000파운드가 더 나갔다. 가장 큰 가정용 냉장고 중 하나인 Sub-Zero 690은 656파운드이다.

스티브 러셀은 1962년에 최초의 (디지털) 컴퓨터 게임인 스페이스워(Spacewar)도 만들었다.

뾰족한 머리 상사를 속여 리스프로 소프트웨어를 작성하게 만들고 싶다면, XML이라고 말해볼 수도 있다.

다음은 다른 리스프 방언(dialects)으로 작성된 누산기 생성기이다.

*   Scheme: `(define (foo n) (lambda (i) (set! n (+ n i)) n))`
*   Goo: `(df foo (n) (op incf n _)))`
*   Arc: `(def foo (n) [++ n _])`

에런 갯이 JPL에서 겪은 "업계 모범 사례"에 대한 슬픈 이야기는 제가 이 잘못 적용된 문구를 다루도록 영감을 주었다.

피터 노빅(Peter Norvig)은 『디자인 패턴(Design Patterns)』에 나오는 23개의 패턴 중 16개가 리스프에서는 "보이지 않거나 더 간단하다"는 것을 발견했다.

켄 앤더슨, 트레버 블랙웰(Trevor Blackwell), 에런 갯, 댄 기핀(Dan Giffin), 사라 할린(Sarah Harlin), 제레미 하일턴(Jeremy Hylton), 로버트 모리스(Robert Morris), 피터 노빅, 가이 스틸, 안톤 반 스트라튼(Anton van Straaten)을 포함하여 다양한 언어에 대한 질문에 답변하고 초고를 읽어주신 많은 분들께 감사드린다. 그들은 표현된 어떤 의견에 대해서도 비난받을 만한 점이 없다.

**관련 글:**

이 강연에 대해 많은 사람들이 반응하여, 제기된 문제들을 다루기 위해 추가 페이지 `Re: Revenge of the Nerds`를 설정했다.

또한 LL1 메일링 리스트에서 광범위하고 종종 유용한 토론을 촉발시켰다. 특히 안톤 반 스트라튼의 의미론적 압축(semantic compression)에 대한 메일을 참조하라.

LL1의 일부 메일은 `간결함이 힘이다(Succinctness is Power)`에서 언어의 힘이라는 주제에 대해 더 깊이 탐구하도록 이끌었다.

누산기 생성기 벤치마크의 더 큰 정식 구현 모음은 별도의 페이지에 모아져 있다.

일본어 번역, 스페인어 번역, 중국어 번역.