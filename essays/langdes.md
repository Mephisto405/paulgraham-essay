# 다섯 가지 프로그래밍 언어 설계에 관한 질문 (Five Questions about Language Design)

2001년 5월
(이 글은 2001년 5월 10일 MIT에서 열린 프로그래밍 언어 설계에 관한 패널 토론을 위해 제가 작성한 메모입니다.)

## 1. 프로그래밍 언어는 사람을 위한 것이다 (Programming Languages Are for People).

프로그래밍 언어는 사람들이 컴퓨터와 대화하는 방식입니다. 컴퓨터는 모호하지만 않다면 어떤 언어로든 기꺼이 대화할 것입니다. 우리가 고급 언어(high-level language)를 사용하는 이유는 사람들이 기계어(machine language)를 처리할 수 없기 때문입니다. 프로그래밍 언어의 핵심은 우리의 연약한 인간 두뇌가 세부 사항의 무게에 압도당하는 것을 방지하는 것입니다.

건축가들은 어떤 종류의 설계 문제가 다른 문제보다 더 개인적인지를 알고 있습니다. 가장 깔끔하고 추상적인 설계 문제 중 하나는 다리 설계입니다. 거기서 당신의 임무는 주어진 거리를 최소한의 재료로 연결하는 것입니다. 스펙트럼의 다른 끝에는 의자 설계가 있습니다. 의자 디자이너는 인간의 엉덩이에 대해 생각하는 데 시간을 써야 합니다.

소프트웨어도 마찬가지입니다. 네트워크를 통해 데이터를 라우팅하는 알고리즘(algorithm)을 설계하는 것은 다리를 설계하는 것처럼 멋지고 추상적인 문제입니다. 반면 프로그래밍 언어를 설계하는 것은 의자를 설계하는 것과 같습니다. 인간의 약점을 다루는 것이 전부이기 때문입니다.

우리 대부분은 이를 인정하고 싶어 하지 않습니다. 뛰어난 수학적 우아함(mathematical elegance)을 가진 시스템을 설계하는 것이 인간의 약점을 맞춰주는 것보다 우리 대부분에게 훨씬 더 매력적으로 들립니다. 그리고 수학적 우아함에는 역할이 있습니다. 어떤 종류의 우아함은 프로그램을 더 쉽게 이해하게 만듭니다. 하지만 우아함 자체가 목적은 아닙니다.

그리고 언어가 인간의 약점에 맞게 설계되어야 한다고 말할 때, 언어가 형편없는 프로그래머를 위해 설계되어야 한다는 의미는 아닙니다. 사실 저는 최고의 프로그래머를 위해 설계해야 한다고 생각하지만, 최고의 프로그래머조차 한계가 있습니다. 모든 변수가 정수 첨자(integer subscript)가 붙은 문자 'x'인 언어로 프로그래밍하는 것을 좋아할 사람은 아무도 없다고 생각합니다.

## 2. 당신 자신과 친구들을 위해 설계하라 (Design for Yourself and Your Friends).

프로그래밍 언어의 역사를 살펴보면, 최고의 언어 중 다수는 저자 자신이 사용하기 위해 설계한 언어였고, 최악의 언어 중 다수는 다른 사람들을 위해 설계된 것이었습니다.

다른 사람들을 위해 언어를 설계할 때는 항상 특정 집단, 즉 언어 설계자만큼 똑똑하지 않은 사람들을 대상으로 합니다. 그래서 당신은 당신을 깔보는 듯한 언어를 얻게 됩니다. 코볼(Cobol)이 가장 극단적인 사례지만, 많은 언어에 이러한 정신이 스며들어 있습니다. 이것이 언어가 얼마나 추상적인지와는 아무 관련이 없습니다. C는 상당히 저수준(low-level)이지만, 저자 자신이 사용하기 위해 설계되었으며, 이것이 해커(hacker)들이 C를 좋아하는 이유입니다.

형편없는 프로그래머들을 위해 언어를 설계해야 한다는 주장은 형편없는 프로그래머가 뛰어난 프로그래머보다 더 많다는 것입니다. 그것은 사실일 수 있습니다. 하지만 그 소수의 뛰어난 프로그래머들이 소프트웨어의 불균형적으로 많은 부분을 작성합니다.

저는 최고의 해커들이 좋아할 만한 언어를 어떻게 설계하는지에 대한 질문에 관심이 있습니다. 저는 이것이 좋은 프로그래밍 언어를 설계하는 방법과 동일하다고 생각하지만, 그렇지 않더라도 적어도 흥미로운 질문입니다.

## 3. 프로그래머에게 가능한 한 많은 제어권을 부여하라 (Give the Programmer as Much Control as Possible).

많은 언어들(특히 다른 사람들을 위해 설계된 언어들)은 가정교사(governess)와 같은 태도를 취합니다. 즉, 당신에게 좋지 않다고 생각하는 일을 하지 못하도록 막으려고 합니다. 저는 그 반대 접근 방식을 좋아합니다. 프로그래머에게 가능한 한 많은 제어권을 부여하는 것입니다.

제가 처음 리스프(Lisp)를 배울 때 가장 마음에 들었던 점은 저를 동등한 파트너로 존중했다는 것입니다. 제가 그때까지 배웠던 다른 언어들과 달리, 리스프에서는 제가 작성한 함수와 매크로(macro)가 언어 자체를 구성하는 것들과 똑같았습니다. 원한다면 언어를 재작성할 수도 있었습니다. 이는 오픈 소스 소프트웨어(open-source software)와 같은 매력을 지녔습니다.

## 4. 간결함을 추구하라 (Aim for Brevity).

간결함은 과소평가되고 심지어 경멸받기도 합니다. 하지만 해커들의 마음속을 들여다보면 그들이 간결함을 정말 사랑한다는 것을 알 수 있습니다. 예를 들어, APL에서 단 몇 줄의 코드로 놀라운 일을 할 수 있었다는 이야기에 대해 해커들이 긍정적으로 이야기하는 것을 몇 번이나 들었습니까? 저는 정말 똑똑한 사람들이 진정으로 사랑하는 것은 무엇이든 주의를 기울일 가치가 있다고 생각합니다.

프로그램을 더 짧게 만들 수 있는 거의 모든 것이 좋다고 생각합니다. 라이브러리 함수(library function)가 많아야 하고, 암시적(implicit)으로 처리될 수 있는 것은 무엇이든 그렇게 해야 하며, 구문(syntax)은 지나치게 간결해야 하고, 심지어 사물의 이름도 짧아야 합니다.

프로그램만 짧아야 하는 것은 아닙니다. 매뉴얼도 얇아야 합니다. 매뉴얼의 상당 부분은 설명, 유보 사항, 경고 및 특수 사례로 채워집니다. 매뉴얼을 강제로 축약한다면, 최선의 경우 그러한 설명을 많이 필요로 했던 언어의 문제점들을 바로잡음으로써 그렇게 하는 것입니다.

## 5. 해킹(Hacking)이 무엇인지 인정하라 (Admit What Hacking Is).

많은 사람들은 해킹이 수학이거나 적어도 자연 과학과 같은 것이기를 바랍니다. 저는 해킹이 건축에 더 가깝다고 생각합니다. 건축은 물리학과 관련이 있습니다. 건축가는 무너지지 않는 건물을 설계해야 하지만, 건축가의 실제 목표는 정역학(statics)에 대한 발견을 하는 것이 아니라 훌륭한 건물을 만드는 것입니다.

해커들이 하고 싶어 하는 일은 훌륭한 프로그램을 만드는 것입니다. 그리고 저는 적어도 우리 마음속에서는, 이 작업이 연구 논문(research paper)의 관습적인 지적 통화(intellectual currency)로 쉽게 전환되지 않더라도 훌륭한 프로그램을 작성하는 것이 칭찬받을 만한 일이라는 것을 기억해야 한다고 생각합니다. 지적으로, 프로그래머들이 사랑하는 언어를 설계하는 것은 당신이 논문으로 발표할 수 있는 어떤 아이디어를 구현한 끔찍한 언어를 설계하는 것만큼이나 가치 있는 일입니다.

### 향후 언어 설계를 위한 질문들 (Questions for Future Language Design)

### 1. 큰 라이브러리를 어떻게 구성할 것인가? (How to Organize Big Libraries?)

라이브러리는 프로그래밍 언어의 점점 더 중요한 구성 요소가 되고 있습니다. 또한 점점 더 커지고 있으며, 이는 위험할 수 있습니다. 원하는 작업을 수행할 라이브러리 함수를 찾는 데 직접 작성하는 것보다 더 오래 걸린다면, 그 모든 코드는 매뉴얼을 두껍게 만드는 것 외에 아무것도 하지 못하는 것입니다. (Symbolics의 매뉴얼이 좋은 예였습니다.) 따라서 우리는 라이브러리를 구성하는 방법에 대해 노력해야 한다고 생각합니다. 이상적인 것은 프로그래머가 올바른 작업을 수행할 라이브러리 호출을 추측할 수 있도록 설계하는 것입니다.

### 2. 사람들은 정말 접두사 구문(Prefix Syntax)을 두려워하는가? (Are People Really Scared of Prefix Syntax?)

이것은 열린 문제입니다. 왜냐하면 저는 수년간 그것에 대해 궁금해했지만 여전히 답을 모르기 때문입니다. 접두사 구문은 수학을 제외하고는 저에게 완벽하게 자연스럽게 느껴집니다. 하지만 리스프의 인기가 없는 이유 중 많은 부분이 단순히 익숙하지 않은 구문 때문일 수 있습니다. 그것이 사실이라면, 그것에 대해 무언가를 해야 할지 여부는 또 다른 질문입니다.

### 3. 서버 기반 소프트웨어(Server-Based Software)에는 무엇이 필요한가? (What Do You Need for Server-Based Software?)

향후 20년 동안 작성될 가장 흥미로운 새로운 애플리케이션(application) 중 많은 부분이 웹 기반 애플리케이션, 즉 서버에 상주하며 웹 브라우저를 통해 사용자와 대화하는 프로그램을 의미할 것이라고 생각합니다. 그리고 이러한 종류의 프로그램을 작성하기 위해 우리는 몇 가지 새로운 것이 필요할 수 있습니다.

우리가 필요로 할 한 가지는 서버 기반 앱이 출시되는 새로운 방식에 대한 지원입니다. 일년에 한두 번의 큰 릴리스(release)가 있는 대신, 서버 기반 앱은 일련의 작은 변경으로 출시됩니다. 하루에 다섯 번에서 열 번까지의 릴리스를 가질 수도 있습니다. 그리고 일반적으로 모든 사람이 최신 버전을 사용하게 될 것입니다.

프로그램을 디버깅(debug) 가능하도록 설계하는 방법을 알고 계실 것입니다. 마찬가지로 서버 기반 소프트웨어는 변경 가능하도록 설계되어야 합니다. 쉽게 변경하거나, 적어도 무엇이 작은 변경이고 무엇이 중대한 변경인지 알아야 합니다.

서버 기반 소프트웨어에 유용할 수 있는 또 다른 것은 놀랍게도 연속(continuation)입니다. 웹 기반 소프트웨어에서는 연속 전달 스타일(continuation-passing style)과 유사한 것을 사용하여 본질적으로 상태 비저장(stateless)인 웹 세션 세계에서 서브루틴(subroutine)의 효과를 얻을 수 있습니다. 비용이 너무 많이 들지 않는다면 실제 연속을 갖는 것이 가치 있을 수 있습니다.

### 4. 발견할 새로운 추상화(Abstraction)는 무엇인가? (What New Abstractions Are Left to Discover?)

이것이 얼마나 합리적인 희망인지는 확실하지 않지만, 제가 개인적으로 정말 하고 싶은 일 중 하나는 새로운 추상화를 발견하는 것입니다. 이는 일급 함수(first-class function)나 재귀(recursion) 또는 키워드 매개변수(keyword parameter)를 처음 갖게 되었을 때만큼의 차이를 만들 수 있는 무언가입니다. 이것은 불가능한 꿈일지도 모릅니다. 이러한 것들은 그다지 자주 발견되지 않습니다. 하지만 저는 항상 찾고 있습니다.

## 제가 틀렸거나 혹은 맞았을지도 모르는 것들 (Things I've Been Wrong About)

### 1. 원하는 어떤 언어든 사용할 수 있다 (You Can Use Whatever Language You Want).

애플리케이션 프로그램을 작성하는 것은 예전에는 데스크톱 소프트웨어를 작성하는 것을 의미했습니다. 그리고 데스크톱 소프트웨어에서는 운영 체제(operating system)와 동일한 언어로 애플리케이션을 작성하는 것에 대한 큰 편견이 있었습니다. 그래서 10년 전만 해도 소프트웨어 작성은 거의 C로 소프트웨어를 작성하는 것을 의미했습니다.

결국 다음과 같은 전통이 진화했습니다. 애플리케이션 프로그램은 특이한 언어로 작성해서는 안 됩니다. 그리고 이 전통은 너무 오랫동안 발전해 왔기 때문에 관리자(manager)나 벤처 캐피탈리스트(venture capitalist)와 같은 비기술적인 사람들도 그것을 배웠습니다.

서버 기반 소프트웨어는 이 모든 모델을 산산조각냅니다. 서버 기반 소프트웨어를 사용하면 원하는 어떤 언어든 사용할 수 있습니다. 거의 아무도 아직 이것을 이해하지 못합니다(특히 관리자나 벤처 캐피탈리스트는).

몇몇 해커들은 이를 이해하고 있으며, 이것이 바로 우리가 펄(Perl)이나 파이썬(Python)과 같은 새롭고 독립적인 언어에 대해 듣는 이유입니다. 우리는 사람들이 윈도우즈(Windows) 앱을 작성하기 위해 펄과 파이썬을 사용하기 때문에 그것에 대해 듣는 것이 아닙니다.

이것이 프로그래밍 언어 설계에 관심 있는 우리에게 의미하는 바는, 이제 우리의 작업에 잠재적으로 실제적인 잠재 고객이 있다는 것입니다.

### 2. 속도는 프로파일러(Profiler)에서 나온다 (Speed Comes from Profilers).

언어 설계자, 또는 적어도 언어 구현자(implementor)는 빠른 코드를 생성하는 컴파일러(compiler)를 작성하는 것을 좋아합니다. 하지만 이것이 사용자에게 언어를 빠르게 만드는 것이라고는 생각하지 않습니다.

너트(Knuth)는 오래전에 속도는 몇몇 중요한 병목 현상(bottleneck)에서만 중요하다는 점을 지적했습니다. 그리고 그것을 시도해 본 사람은 누구나 이 병목 현상이 어디인지 추측할 수 없다는 것을 알고 있습니다. 프로파일러가 해결책입니다.

언어 설계자들은 잘못된 문제를 해결하고 있습니다. 사용자들은 빠르게 실행되는 벤치마크(benchmark)를 실행할 필요가 없습니다. 그들이 필요로 하는 것은 자신의 프로그램의 어떤 부분이 재작성되어야 하는지를 보여줄 수 있는 언어입니다. 그것이 실제 속도가 나오는 곳입니다. 따라서 언어 구현자들이 컴파일러 최적화(compiler optimization)에 쏟는 시간의 절반을 들여 대신 좋은 프로파일러를 작성한다면 순이익이 될 수 있습니다.

### 3. 언어 설계를 주도할 애플리케이션이 필요하다 (You Need an Application to Drive the Design of a Language).

이것은 절대적인 규칙은 아닐 수 있지만, 최고의 언어들은 모두 그것을 사용하여 작성되던 특정 애플리케이션과 함께 발전한 것 같습니다. C는 시스템 프로그래밍(systems programming)을 위해 필요했던 사람들에 의해 작성되었습니다. 리스프는 부분적으로 기호 미분(symbolic differentiation)을 위해 개발되었으며, 매카시(McCarthy)는 시작할 의욕이 너무 넘쳐서 1960년 리스프에 관한 첫 논문에서 이미 미분 프로그램을 작성하고 있었습니다.

당신의 애플리케이션이 새로운 문제를 해결한다면 특히 좋습니다. 그것은 프로그래머들이 필요로 하는 새로운 기능들을 갖도록 언어를 이끌 것입니다. 저는 개인적으로 서버 기반 애플리케이션 작성을 잘하는 언어를 쓰는 데 관심이 있습니다.

(패널 토론 중에 Guy Steele도 이 점을 언급하며, 언어 자체의 컴파일러를 작성하는 것이 아니라면 애플리케이션은 언어 컴파일러를 작성하는 것으로 구성되어서는 안 된다는 추가 제안을 했습니다.)

### 4. 언어는 임시방편으로 작성하는 프로그램(Throwaway Program)에도 좋아야 한다 (A Language Has to Be Good for Writing Throwaway Programs).

임시방편 프로그램이 무엇인지 아실 것입니다. 특정 제한된 작업을 위해 빠르게 작성하는 것입니다. 주변을 둘러보면 많은 크고 진지한 프로그램이 임시방편 프로그램으로 시작되었다는 것을 발견할 수 있을 것입니다. 대부분의 프로그램이 임시방편 프로그램으로 시작되었다고 해도 놀라지 않을 것입니다. 따라서 전반적으로 소프트웨어를 작성하는 데 좋은 언어를 만들고 싶다면, 임시방편 프로그램 작성을 잘해야 합니다. 그것이 대부분의 소프트웨어의 초기 단계이기 때문입니다.

### 5. 구문(Syntax)은 의미론(Semantics)과 연결되어 있다 (Syntax Is Connected to Semantics).

구문과 의미론을 완전히 별개로 생각하는 것이 전통적입니다. 이것은 충격적으로 들릴 수 있지만, 그렇지 않을 수도 있습니다.

당신이 언어에서 원하는 것이 그것을 표현하는 방식과 관련이 있을 수 있다고 생각합니다.

최근 로버트 모리스(Robert Morris)와 이야기했는데, 그는 연산자 오버로딩(operator overloading)이 중위 표기법(infix syntax)을 사용하는 언어에서 더 큰 이점을 제공한다고 지적했습니다. 접두사 구문을 사용하는 언어에서는 정의하는 모든 함수가 효과적으로 연산자입니다. 새로운 종류의 숫자에 대한 덧셈을 정의하고 싶다면, 단순히 덧셈을 수행하는 새 함수를 정의할 수 있습니다. 중위 표기법을 사용하는 언어에서 그렇게 하면, 오버로딩된 연산자 사용과 함수 호출 사이에 외관상 큰 차이가 있습니다.

## 제가 맞았다고 생각하는 것들 (혹은 맞을지도 모르는 것들) (Things I've Been Right About (or might be))

### 1. 새로운 프로그래밍 언어 (New Programming Languages).

1970년대에는 새로운 프로그래밍 언어를 설계하는 것이 유행이었습니다. 최근에는 그렇지 않았습니다. 하지만 서버 기반 소프트웨어가 새로운 언어를 다시 유행하게 만들 것이라고 생각합니다. 서버 기반 소프트웨어를 사용하면 어떤 언어든 사용할 수 있으므로, 누군가가 실제로 다른 기존 언어들보다 더 나은 언어를 설계한다면, 위험을 감수하고 그것을 사용할 사람들이 있을 것입니다.

### 2. 시분할 (Time-Sharing).

리처드 켈시(Richard Kelsey)가 마지막 패널에서 시간이 다시 온 아이디어로 이것을 제시했고, 저는 그에게 전적으로 동의합니다.

제 추측(그리고 마이크로소프트의 추측인 것 같습니다)은 많은 컴퓨팅이 데스크톱에서 원격 서버로 이동할 것이라는 것입니다. 다른 말로 하면, 시분할이 돌아왔습니다. 그리고 저는 언어 수준에서 이를 지원할 필요가 있을 것이라고 생각합니다. 예를 들어, 리처드와 조나단 리스(Jonathan Rees)가 Scheme 48 내에서 프로세스 스케줄링(process scheduling)을 구현하는 데 많은 노력을 기울였다는 것을 알고 있습니다.

### 3. 효율성 (Efficiency).

최근 컴퓨터가 마침내 충분히 빨라진 것처럼 보이기 시작했습니다. 점점 더 많은 사람들이 바이트 코드(byte code)에 대해 이야기하는 것을 들었는데, 이는 적어도 우리가 사용할 수 있는 사이클(cycle)이 있다고 느끼는 것 같습니다. 하지만 서버 기반 소프트웨어에서는 그렇지 않을 것이라고 생각합니다. 서버에서 실행되는 소프트웨어 비용을 누군가는 지불해야 할 것이며, 기계당 지원할 수 있는 사용자 수는 자본 비용의 분모가 될 것입니다.

따라서 효율성이 중요해질 것이라고 생각합니다. 적어도 계산 병목 현상에서는요. 특히 서버 기반 애플리케이션은 I/O를 많이 수행하기 때문에 I/O를 빠르게 처리하는 것이 특히 중요할 것입니다.

결국 바이트 코드가 이점이 되지 않을 수도 있습니다. Sun과 Microsoft는 현재 일종의 바이트 코드 전쟁을 벌이고 있는 것 같습니다. 하지만 그들은 바이트 코드가 그 자체로 좋은 아이디어이기 때문이 아니라, 프로세스에 자신들을 끼워 넣을 편리한 장소이기 때문에 그렇게 하고 있습니다. 이 모든 전장(battleground)이 우회될 수도 있습니다. 그것은 꽤 재미있을 것입니다.

## 제가 틀릴지도 모르는 것들 (Things I Might Be Wrong About)

### 1. 클라이언트 (Clients).

이것은 추측일 뿐이지만, 제 추측은 대부분의 애플리케이션에 대한 승리 모델은 순전히 서버 기반이 될 것이라는 것입니다.

모든 사람이 당신의 클라이언트를 가지고 있다고 가정하고 소프트웨어를 설계하는 것은 모든 사람이 정직할 것이라고 가정하고 사회를 설계하는 것과 같습니다. 확실히 편리하겠지만, 절대 그런 일은 없을 것이라고 가정해야 합니다.

어떤 종류의 웹 접근성을 가진 기기들이 확산될 것이라고 생각합니다. 그리고 당신이 가정할 수 있는 모든 것은 그것들이 간단한 HTML(html)과 양식(forms)을 지원할 수 있다는 것뿐입니다. 휴대폰에 브라우저가 있을까요? 팜 파일럿(palm pilot)에 전화기가 있을까요? 블랙베리(blackberry) 화면이 더 커질까요? 게임보이(gameboy)로 웹을 검색할 수 있을까요? 당신의 시계는요? 저는 모릅니다.

그리고 저는 모든 것을 서버에 두는 것에 베팅한다면 알 필요가 없습니다. 모든 두뇌를 서버에 두는 것이 훨씬 더 강력합니다.

### 2. 객체 지향 프로그래밍 (Object-Oriented Programming).

이것이 논란의 여지가 있다는 것을 알고 있지만, 객체 지향 프로그래밍이 그렇게 대단한 일이라고는 생각하지 않습니다. 창 시스템(window system), 시뮬레이션(simulation), CAD 프로그램과 같이 특정 종류의 데이터 구조(data structure)가 필요한 특정 종류의 애플리케이션에는 훌륭한 모델입니다. 하지만 모든 프로그래밍에 그것이 모델이 되어야 하는 이유는 모르겠습니다.

대기업의 사람들이 객체 지향 프로그래밍을 좋아하는 이유 중 일부는 그것이 많은 일을 하는 것처럼 보이게 만들기 때문이라고 생각합니다. 예를 들어, 간단한 정수 목록으로 자연스럽게 표현될 수 있는 것이 이제 온갖 종류의 비계(scaffolding)와 부산스러움(hustle and bustle)을 가진 클래스(class)로 표현될 수 있습니다.

객체 지향 프로그래밍의 또 다른 매력은 메서드(method)가 일급 함수와 유사한 효과를 제공한다는 것입니다. 하지만 이것은 리스프 프로그래머들에게는 이미 알려진 사실입니다. 실제 일급 함수를 가지고 있으면, 모든 것을 클래스와 메서드의 틀에 억지로 맞추는 대신, 상황에 적합한 방식으로 자유롭게 사용할 수 있습니다.

이것이 언어 설계에 의미하는 바는, 객체 지향 프로그래밍을 너무 깊이 내장해서는 안 된다는 것입니다. 아마도 해답은 더 일반적이고 기본적인 요소들을 제공하고, 사람들이 라이브러리로서 원하는 어떤 객체 시스템(object system)이든 설계하도록 하는 것일 수 있습니다.

### 3. 위원회에 의한 설계 (Design by Committee).

위원회가 언어를 설계하게 하는 것은 큰 함정입니다. 그리고 모든 사람이 아는 이유뿐만 아니라요. 위원회는 뒤죽박죽이고 일관성 없는 설계를 내놓는 경향이 있다는 것을 모두가 알고 있습니다. 하지만 더 큰 위험은 그들이 위험을 감수하지 않을 것이라는 점이라고 생각합니다.

한 사람이 책임을 지고 있다면 위원회는 결코 동의하지 않을 위험을 감수할 수 있습니다.

하지만 좋은 언어를 설계하기 위해 위험을 감수하는 것이 필요한가요?

많은 사람들이 언어 설계는 관습적인 지혜(conventional wisdom)에 상당히 가까이 머물러야 하는 것이라고 생각할지도 모릅니다. 저는 이것이 사실이 아닐 것이라고 생각합니다.

사람들이 하는 다른 모든 일에서 보상은 위험에 비례합니다. 언어 설계는 왜 달라야 할까요?

{[^1]: 이 글은 2001년 5월 10일 MIT에서 열린 프로그래밍 언어 설계에 관한 패널 토론을 위해 작성된 메모를 기반으로 합니다.}
{[^2]: 여기서는 'hacking'을 넓은 의미의 프로그래밍, 특히 창의적이고 기술적인 프로그래밍 행위로 해석합니다.}
{[^3]: 'hackers'는 일반적으로 컴퓨터 시스템에 능숙하고 창의적인 프로그래머를 지칭하는 용어입니다.}
{[^4]: 'time-sharing'은 여러 사용자가 하나의 컴퓨터 시스템을 동시에 사용하는 방식입니다.}
{[^5]: 'i/o'는 input/output의 약자로, 컴퓨터 시스템과 외부 세계 간의 데이터 교환을 의미합니다.}
{[^6]: 'byte code'는 컴퓨터 프로그램의 중간 표현 형식으로, 특정 가상 머신에서 실행되도록 컴파일된 것입니다.}
{[^7]: 'object-oriented programming'은 데이터를 객체로 취급하고, 객체들이 서로 상호작용하는 방식으로 프로그래밍하는 패러다임입니다.}