# 언어 설계에 대한 다섯 가지 질문 (Five Questions about Language Design)

2001년 5월

(이 글은 2001년 5월 10일 MIT에서 열린 프로그래밍 언어 설계에 관한 패널 토론을 위해 제가 작성한 몇 가지 노트입니다.)

## 1. 프로그래밍 언어는 사람을 위한 것이다.

프로그래밍 언어는 사람들이 컴퓨터와 대화하는 방식입니다. 컴퓨터는 모호하지 않은 어떤 언어라도 기꺼이 사용하겠지만, 우리가 고급 언어를 사용하는 이유는 사람들이 기계어를 다룰 수 없기 때문입니다. 프로그래밍 언어의 목적은 우리의 약하고 나약한 인간 두뇌가 엄청난 양의 세부 사항에 압도당하는 것을 막는 것입니다.

건축가들은 어떤 종류의 설계 문제는 다른 문제보다 더 인간적이라는 것을 압니다. 가장 깔끔하고 추상적인 설계 문제 중 하나는 다리를 설계하는 것입니다. 거기서는 주어진 거리를 최소한의 재료로 연결하는 것이 주된 임무입니다. 스펙트럼의 다른 끝에는 의자를 설계하는 것이 있습니다. 의자 디자이너는 인간의 엉덩이에 대해 생각하며 시간을 보내야 합니다.

소프트웨어도 마찬가지입니다. 네트워크를 통해 데이터를 라우팅하는 알고리즘을 설계하는 것은 다리를 설계하는 것과 같은 멋지고 추상적인 문제입니다. 반면에 프로그래밍 언어를 설계하는 것은 의자를 설계하는 것과 같습니다. 이는 전적으로 인간의 약점을 다루는 것입니다.

우리 대부분은 이것을 인정하기를 싫어합니다. 위대한 수학적 우아함을 지닌 시스템을 설계하는 것은 인간의 약점을 비위 맞추는 것보다 훨씬 매력적으로 들립니다. 그리고 수학적 우아함의 역할도 있습니다. 어떤 종류의 우아함은 프로그램을 이해하기 쉽게 만듭니다. 하지만 우아함 자체가 목적은 아닙니다.

그리고 제가 언어가 인간의 약점에 맞게 설계되어야 한다고 말할 때, 언어가 나쁜 프로그래머를 위해 설계되어야 한다는 의미는 아닙니다. 사실 저는 최고의 프로그래머를 위해 설계해야 한다고 생각하지만, 최고의 프로그래머조차도 한계가 있습니다. 모든 변수가 정수 첨자가 붙은 'x'인 언어로 프로그래밍하는 것을 좋아할 사람은 없을 것이라고 생각합니다.

## 2. 자신과 친구들을 위해 설계하라.

프로그래밍 언어의 역사를 살펴보면, 최고의 언어 중 상당수는 그 저자 자신들이 사용하기 위해 설계된 언어였고, 최악의 언어 중 상당수는 다른 사람들을 위해 설계되었습니다.

언어가 다른 사람들을 위해 설계될 때는 항상 특정 그룹의 다른 사람들, 즉 언어 설계자만큼 똑똑하지 않은 사람들을 위한 것입니다. 그래서 당신을 깔보는 언어를 얻게 됩니다. 코볼(Cobol)이 가장 극단적인 사례이지만, 많은 언어들이 이런 정신에 물들어 있습니다.

이것은 언어가 얼마나 추상적인지와는 아무런 관련이 없습니다. C는 상당히 저수준(low-level)이지만, 그 저자들이 사용하기 위해 설계되었고, 그래서 해커들이 좋아하는 것입니다.

나쁜 프로그래머를 위해 언어를 설계해야 한다는 주장은 좋은 프로그래머보다 나쁜 프로그래머가 더 많기 때문입니다. 그럴 수도 있습니다. 하지만 그 소수의 좋은 프로그래머들이 불균형적으로 많은 비율의 소프트웨어를 작성합니다.

저는 최고의 해커들이 좋아할 만한 언어를 어떻게 설계할지에 관심이 있습니다. 저는 이것이 좋은 프로그래밍 언어를 어떻게 설계할지에 대한 질문과 동일하다고 생각하지만, 그렇지 않더라도 적어도 흥미로운 질문입니다.

## 3. 프로그래머에게 가능한 한 많은 제어권을 부여하라.

많은 언어들(특히 다른 사람들을 위해 설계된 언어들)은 가정교사(governess)와 같은 태도를 가지고 있습니다. 즉, 프로그래머에게 좋지 않다고 생각하는 일을 못하게 막으려 합니다. 저는 정반대의 접근 방식을 좋아합니다. 프로그래머에게 가능한 한 많은 제어권을 부여하는 것입니다.

제가 리스프(Lisp)를 처음 배웠을 때 가장 좋았던 점은 리스프가 저를 동등한 파트너로 여겼다는 것입니다. 제가 그때까지 배웠던 다른 언어에서는 언어와 그 언어로 작성된 제 프로그램이 있었고, 이 둘은 매우 분리되어 있었습니다. 하지만 리스프에서는 제가 작성한 함수(functions)와 매크로(macros)가 언어 자체를 구성하는 것과 똑같았습니다. 저는 원한다면 언어를 다시 작성할 수도 있었습니다. 이것은 오픈 소스 소프트웨어와 같은 매력을 가지고 있었습니다.

## 4. 간결함을 추구하라.

간결함은 과소평가되고 심지어 경멸당하기도 합니다. 하지만 해커들의 마음속을 들여다보면, 그들이 간결함을 정말로 좋아한다는 것을 알 수 있습니다. APL과 같은 언어에서 해커들이 어떻게 몇 줄의 코드만으로 놀라운 일을 할 수 있었는지 얼마나 자주 듣게 됩니까? 저는 정말 똑똑한 사람들이 정말로 좋아하는 것은 무엇이든 주목할 가치가 있다고 생각합니다.

저는 프로그램을 더 짧게 만들 수 있는 거의 모든 것이 좋다고 생각합니다. 많은 라이브러리 함수가 있어야 하고, 암묵적으로 처리될 수 있는 모든 것은 암묵적이어야 하며, 구문(syntax)은 지나치게 간결해야 하고, 심지어 사물의 이름도 짧아야 합니다.

그리고 짧아야 하는 것은 프로그램뿐만이 아닙니다. 매뉴얼도 얇아야 합니다. 매뉴얼의 상당 부분은 설명, 유보 사항, 경고, 특수 사례로 채워져 있습니다. 매뉴얼을 강제로 줄이면, 최선의 경우 언어 자체에서 그렇게 많은 설명을 필요로 했던 것들을 수정함으로써 그렇게 할 수 있습니다.

## 5. 해킹이 무엇인지 인정하라.

많은 사람들은 해킹이 수학이거나 적어도 자연 과학과 같은 것이기를 바랍니다. 저는 해킹이 건축과 더 비슷하다고 생각합니다. 건축은 물리학과 관련이 있습니다. 건축가는 무너지지 않는 건물을 설계해야 하지만, 건축가의 실제 목표는 위대한 건물을 만드는 것이지, 정역학에 대한 발견을 하는 것이 아닙니다.

해커들이 하고 싶어 하는 일은 위대한 프로그램을 만드는 것입니다. 그리고 저는 적어도 우리 자신의 마음속에서는, 이 작업이 연구 논문이라는 통상적인 지적 통화(intellectual currency)로 쉽게 번역되지 않더라도, 위대한 프로그램을 작성하는 것이 칭찬할 만한 일이라는 것을 기억해야 한다고 생각합니다. 지적으로, 프로그래머가 좋아할 언어를 설계하는 것은 당신이 논문을 발표할 수 있는 어떤 아이디어를 구현하는 끔찍한 언어를 설계하는 것만큼이나 가치 있는 일입니다.

### 1. 거대한 라이브러리를 어떻게 조직할까?

라이브러리는 프로그래밍 언어에서 점점 더 중요해지는 구성 요소가 되고 있습니다. 또한 점점 더 커지고 있으며, 이는 위험할 수 있습니다. 원하는 작업을 수행할 라이브러리 함수를 찾는 데 직접 작성하는 것보다 시간이 더 오래 걸린다면, 그 모든 코드는 매뉴얼만 두껍게 만들 뿐입니다. (Symbolics 매뉴얼이 좋은 예였습니다.) 그래서 저는 라이브러리를 조직하는 방법에 대해 연구해야 한다고 생각합니다. 이상적인 방법은 프로그래머가 어떤 라이브러리 호출이 올바른 일을 할지 추측할 수 있도록 설계하는 것입니다.

### 2. 사람들이 정말 접두사 구문(Prefix Syntax)을 두려워하는가?

이것은 제가 수년 동안 궁금해했지만 여전히 답을 모르는 의미에서 미해결 문제(open problem)입니다. 접두사 구문은 수학을 제외하고는 저에게 완벽하게 자연스러워 보입니다. 하지만 리스프의 인기가 낮은 이유 중 상당 부분이 단순히 익숙하지 않은 구문 때문일 수도 있습니다. 만약 그렇다면, 그것에 대해 어떤 조치를 취할지는 또 다른 문제입니다.

### 3. 서버 기반 소프트웨어에 무엇이 필요한가?

저는 향후 20년간 작성될 가장 흥미로운 새로운 애플리케이션 중 상당수가 웹 기반 애플리케이션, 즉 서버에 상주하며 웹 브라우저를 통해 사용자와 소통하는 프로그램이 될 것이라고 생각합니다. 그리고 이러한 종류의 프로그램을 작성하려면 몇 가지 새로운 것이 필요할 수 있습니다.

우리가 필요로 할 한 가지는 서버 기반 앱이 출시되는 새로운 방식에 대한 지원입니다. 데스크톱 소프트웨어처럼 1년에 한두 번의 대규모 출시가 아니라, 서버 기반 앱은 일련의 작은 변경 사항으로 출시됩니다. 하루에 다섯 번 또는 열 번의 출시가 있을 수도 있습니다. 그리고 일반적으로 모든 사람이 항상 최신 버전을 사용하게 될 것입니다.

프로그램을 디버깅 가능하도록 설계하는 방법을 아시죠? 마찬가지로 서버 기반 소프트웨어는 변경 가능하도록 설계되어야 합니다. 쉽게 변경할 수 있어야 하거나, 적어도 무엇이 작은 변경이고 무엇이 중대한 변경인지 알아야 합니다.

놀랍게도 서버 기반 소프트웨어에 유용할 수 있는 또 다른 것은 연속(continuations)입니다. 웹 기반 소프트웨어에서는 연속 전달 스타일(continuation-passing style)과 같은 것을 사용하여 본질적으로 상태가 없는 웹 세션의 세계에서 서브루틴(subroutines)의 효과를 얻을 수 있습니다. 비용이 너무 많이 들지 않는다면 실제 연속을 가지는 것이 가치 있을 수도 있습니다.

### 4. 발견할 새로운 추상화(Abstractions)는 무엇이 남아 있는가?

이것이 얼마나 합리적인 희망인지는 모르겠지만, 제가 개인적으로 정말로 하고 싶은 한 가지는 새로운 추상화를 발견하는 것입니다. 일급 함수(first class functions)나 재귀(recursion) 또는 심지어 키워드 매개변수(keyword parameters)만큼 큰 차이를 만들어낼 수 있는 어떤 것 말이죠. 이것은 불가능한 꿈일 수도 있습니다. 이런 것들은 그리 자주 발견되지 않습니다. 하지만 저는 항상 찾고 있습니다.

### 1. 원하는 어떤 언어든 사용할 수 있다.

애플리케이션 프로그램을 작성하는 것은 한때 데스크톱 소프트웨어를 작성하는 것을 의미했습니다. 그리고 데스크톱 소프트웨어에서는 애플리케이션을 운영 체제와 같은 언어로 작성하는 경향이 강했습니다. 그래서 10년 전에는 소프트웨어를 작성하는 것이 거의 C로 소프트웨어를 작성하는 것을 의미했습니다. 결국 전통이 생겨났습니다. 애플리케이션 프로그램은 특이한 언어로 작성되어서는 안 된다는 것이죠. 그리고 이 전통은 너무 오랫동안 발전하여 관리자나 벤처 캐피탈리스트와 같은 비기술적인 사람들도 이것을 배웠습니다.

서버 기반 소프트웨어는 이 모든 모델을 날려버립니다. 서버 기반 소프트웨어로는 원하는 어떤 언어든 사용할 수 있습니다. 아직 아무도 이것을 거의 이해하지 못하고 있습니다(특히 관리자와 벤처 캐피탈리스트는 더욱 그렇습니다). 소수의 해커들만이 이것을 이해하고 있으며, 그래서 우리가 펄(Perl)이나 파이썬(Python)과 같은 새로운 독립적인 언어에 대해 듣는 것입니다. 사람들이 이러한 언어를 사용하여 윈도우 앱을 작성하기 때문에 펄과 파이썬에 대해 듣는 것이 아닙니다.

이것이 언어 설계에 관심 있는 우리에게 의미하는 바는 이제 우리의 작업에 대한 실제 잠재적 사용자층이 있다는 것입니다.

### 2. 속도는 프로파일러(Profilers)에서 온다.

언어 설계자들, 적어도 언어 구현자들(implementors)은 빠른 코드를 생성하는 컴파일러(compilers)를 작성하는 것을 좋아합니다. 하지만 저는 이것이 사용자에게 언어를 빠르게 만드는 요소라고 생각하지 않습니다. 크누스(Knuth)는 오래전에 속도는 몇몇 중요한 병목 현상에서만 중요하다고 지적했습니다. 그리고 시도해 본 사람이라면 누구나 이러한 병목 현상이 어디에 있는지 추측할 수 없다는 것을 압니다. 프로파일러가 답입니다.

언어 설계자들은 잘못된 문제를 해결하고 있습니다. 사용자들은 벤치마크(benchmarks)가 빠르게 실행될 필요가 없습니다. 그들이 필요한 것은 자신의 프로그램 중 어느 부분을 다시 작성해야 하는지 보여줄 수 있는 언어입니다. 실질적으로 속도는 거기서 나옵니다. 그러므로 언어 구현자들이 컴파일러 최적화에 쓸 시간의 절반을 좋은 프로파일러를 작성하는 데 쓴다면 순이익(net win)이 될 수도 있습니다.

### 3. 언어 설계를 이끌 애플리케이션이 필요하다.

이것이 절대적인 규칙은 아닐 수 있지만, 최고의 언어들은 모두 작성되는 애플리케이션과 함께 진화한 것 같습니다. C는 시스템 프로그래밍에 필요한 사람들에 의해 작성되었습니다. 리스프는 부분적으로 심볼릭 미분(symbolic differentiation)을 위해 개발되었고, 매카시(McCarthy)는 너무나 시작하고 싶어서 1960년 리스프에 대한 첫 번째 논문에서도 미분 프로그램을 작성하고 있었습니다.

특히 당신의 애플리케이션이 어떤 새로운 문제를 해결한다면 좋습니다. 그것은 당신의 언어가 프로그래머에게 필요한 새로운 기능을 가지도록 이끌 것입니다. 저는 개인적으로 서버 기반 애플리케이션을 작성하는 데 유용한 언어를 작성하는 데 관심이 있습니다.

[패널 토론 중, 가이 스틸(Guy Steele)도 이 점을 언급하며, 언어가 컴파일러 작성을 위한 것이 아닌 한, 애플리케이션이 언어의 컴파일러를 작성하는 것으로 구성되어서는 안 된다는 추가적인 제안을 했습니다.]

### 4. 언어는 일회성 프로그램(Throwaway Programs)을 작성하는 데 유용해야 한다.

일회성 프로그램이 무엇인지 아실 겁니다. 어떤 제한된 작업을 위해 빠르게 작성하는 것입니다. 주변을 살펴보면 많은 크고 진지한 프로그램들이 일회성 프로그램으로 시작되었다는 것을 알 수 있을 것입니다. 대부분의 프로그램이 일회성 프로그램으로 시작되었다고 해도 놀라지 않을 것입니다. 따라서 일반적으로 소프트웨어를 작성하는 데 유용한 언어를 만들려면, 일회성 프로그램을 작성하는 데 유용해야 합니다. 왜냐하면 그것이 대부분의 소프트웨어의 유충 단계(larval stage)이기 때문입니다.

### 5. 구문(Syntax)은 의미론(Semantics)과 연결되어 있다.

구문과 의미론이 완전히 분리되어 있다고 생각하는 것이 전통적입니다. 이것은 충격적으로 들릴 수 있지만, 그렇지 않을 수도 있습니다. 저는 당신이 언어에서 원하는 것이 그것을 어떻게 표현하는지와 관련이 있을 수 있다고 생각합니다.

최근 로버트 모리스(Robert Morris)와 대화했는데, 그는 연산자 오버로딩(operator overloading)이 중위 구문(infix syntax)을 사용하는 언어에서 더 큰 이점이라고 지적했습니다. 접두사 구문을 사용하는 언어에서는 정의하는 모든 함수가 사실상 연산자(operator)입니다. 새로운 유형의 숫자를 만들어서 더하기 기능을 정의하고 싶다면, 단순히 새로운 함수를 정의하여 더하면 됩니다. 이것을 중위 구문을 사용하는 언어에서 한다면, 오버로딩된 연산자의 사용과 함수 호출 사이에 외관상 큰 차이가 있습니다.

### 1. 새로운 프로그래밍 언어.

1970년대에는 새로운 프로그래밍 언어를 설계하는 것이 유행이었습니다. 최근에는 그렇지 않았습니다. 하지만 저는 서버 기반 소프트웨어가 새로운 언어를 다시 유행시킬 것이라고 생각합니다. 서버 기반 소프트웨어로는 원하는 어떤 언어든 사용할 수 있으므로, 어떤 사람이 실제로 사용 가능한 다른 언어보다 더 나은 언어를 설계한다면, 위험을 감수하고 그것을 사용할 사람들이 있을 것입니다.

### 2. 시분할 (Time-Sharing).

리처드 켈시(Richard Kelsey)는 지난 패널에서 이것을 다시 때가 된 아이디어로 언급했고, 저는 전적으로 동의합니다. 제 생각(그리고 마이크로소프트의 생각인 것 같습니다)에는 대부분의 컴퓨팅이 데스크톱에서 원격 서버로 이동할 것이라는 것입니다. 다시 말해, 시분할이 돌아온 것입니다. 그리고 저는 언어 수준에서 이를 지원할 필요가 있다고 생각합니다. 예를 들어, 리처드와 조나단 리스(Jonathan Rees)는 스킴 48(Scheme 48) 내에서 프로세스 스케줄링(process scheduling)을 구현하는 데 많은 노력을 기울였다는 것을 알고 있습니다.

### 3. 효율성 (Efficiency).

최근에는 컴퓨터가 마침내 충분히 빨라진 것처럼 보이기 시작했습니다. 점점 더 많은 사람들이 바이트 코드(byte code)에 대해 이야기하기 시작했고, 이는 적어도 저에게는 우리가 여유 사이클(cycles to spare)을 가지고 있다고 느낀다는 것을 의미합니다. 하지만 저는 서버 기반 소프트웨어에서는 그렇지 않을 것이라고 생각합니다. 누군가는 소프트웨어가 실행되는 서버 비용을 지불해야 할 것이고, 머신당 지원할 수 있는 사용자 수는 자본 비용의 제수(divisor)가 될 것입니다.

그래서 저는 효율성이 중요할 것이라고 생각합니다. 적어도 계산 병목 현상에서는 말이죠. 특히 I/O를 빠르게 처리하는 것이 중요할 것입니다. 서버 기반 애플리케이션은 I/O를 많이 하기 때문입니다.

결국 바이트 코드가 이득이 아닐 수도 있습니다. 선(Sun)과 마이크로소프트는 현재 일종의 바이트 코드 전쟁에 직면하고 있는 것 같습니다. 하지만 그들은 바이트 코드 자체가 좋은 아이디어라서가 아니라, 바이트 코드가 프로세스에 자신들을 삽입하기 편리한 지점이기 때문에 그렇게 하고 있습니다. 이 전체 전쟁터가 우회될 수도 있습니다. 그것은 좀 재미있을 것입니다.

### 1. 클라이언트 (Clients).

이것은 단지 추측일 뿐이지만, 대부분의 애플리케이션에 대한 성공적인 모델은 순전히 서버 기반이 될 것이라고 생각합니다. 모든 사람이 클라이언트를 가질 것이라는 가정 하에 소프트웨어를 설계하는 것은 모든 사람이 정직할 것이라는 가정 하에 사회를 설계하는 것과 같습니다. 물론 편리하겠지만, 그런 일은 결코 일어나지 않을 것이라고 가정해야 합니다.

저는 웹 접근이 가능한 다양한 장치들이 확산될 것이라고 생각하며, 그 장치들에 대해 가정할 수 있는 모든 것은 단순한 HTML과 폼(forms)을 지원한다는 것뿐입니다. 휴대폰에 브라우저가 있을까요? 팜 파일럿(palm pilot)에 전화기가 있을까요? 블랙베리(blackberry)의 화면이 더 커질까요? 게임보이(gameboy)에서 웹을 검색할 수 있을까요? 시계에서? 저는 모릅니다. 그리고 모든 것이 서버에 있을 것이라고 내기한다면 알 필요도 없습니다. 모든 지능이 서버에 있는 것이 훨씬 더 견고합니다.

### 2. 객체 지향 프로그래밍 (Object-Oriented Programming).

이것이 논란의 여지가 있다는 것을 알고 있지만, 저는 객체 지향 프로그래밍(Object-Oriented Programming, OOP)이 그렇게 대단하다고 생각하지 않습니다. 저는 창 시스템, 시뮬레이션, CAD 프로그램과 같이 특정 종류의 데이터 구조가 필요한 특정 유형의 애플리케이션에 적합한 모델이라고 생각합니다. 하지만 왜 모든 프로그래밍의 모델이 되어야 하는지는 모르겠습니다.

저는 대기업의 사람들이 객체 지향 프로그래밍을 좋아하는 이유 중 하나는 그것이 많은 작업처럼 보이는 것을 만들어내기 때문이라고 생각합니다. 예를 들어, 정수 목록으로 자연스럽게 표현될 수 있는 것이 이제는 온갖 스캐폴딩(scaffolding)과 분주함으로 가득 찬 클래스(class)로 표현될 수 있습니다.

객체 지향 프로그래밍의 또 다른 매력은 메소드(methods)가 일급 함수(first class functions)의 일부 효과를 제공한다는 것입니다. 하지만 이것은 리스프 프로그래머들에게는 오래된 소식입니다. 실제 일급 함수가 있다면, 모든 것을 클래스와 메소드라는 틀에 억지로 끼워 넣는 대신, 당면한 작업에 적합한 방식으로 사용할 수 있습니다.

이것이 언어 설계에 의미하는 바는, 객체 지향 프로그래밍을 너무 깊이 내장해서는 안 된다는 것입니다. 아마도 해결책은 더 일반적인, 근본적인 것을 제공하고, 사람들이 라이브러리로 원하는 객체 시스템을 설계하도록 하는 것일 겁니다.

### 3. 위원회에 의한 설계 (Design by Committee).

언어를 위원회에 의해 설계하는 것은 큰 함정이며, 모든 사람이 아는 이유뿐만이 아닙니다. 위원회가 덩어리지고 일관성 없는 디자인을 만들어내는 경향이 있다는 것은 모두가 알고 있습니다. 하지만 저는 더 큰 위험은 그들이 위험을 감수하지 않을 것이라는 점이라고 생각합니다. 한 사람이 책임자일 때는 위원회가 결코 동의하지 않을 위험을 감수할 수 있습니다.

하지만 좋은 언어를 설계하려면 위험을 감수해야 할까요? 많은 사람들은 언어 설계가 통상적인 지식에 상당히 가깝게 유지해야 하는 것이라고 생각할 수도 있습니다. 저는 이것이 사실이 아니라고 생각합니다. 사람들이 하는 다른 모든 일에서 보상은 위험에 비례합니다. 언어 설계가 왜 달라야 할까요?