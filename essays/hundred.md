# 백 년짜리 언어 (The Hundred-Year Language)

2003년 4월
(이 에세이는 2003년 PyCon에서의 기조연설을 바탕으로 작성되었습니다.)

백 년 뒤의 삶이 어떨지 예측하기란 어렵습니다. 확실하게 말할 수 있는 것은 몇 가지 되지 않습니다. 사람들은 모두 비행 자동차를 운전하고, 용도 지역 규제는 완화되어 수백 층짜리 건물들이 들어서고, 대부분의 시간은 어두울 것이며, 여성들은 모두 무술을 훈련받을 것이라는 점은 알고 있습니다.
하지만 여기서 이 그림의 한 가지 세부 사항에 초점을 맞추고 싶습니다. 그 비행 자동차를 제어하는 소프트웨어를 작성하는 데 어떤 종류의 프로그래밍 언어를 사용할까요?
이것은 우리가 실제로 이 언어들을 사용하게 될 가능성 때문이라기보다는, 운이 좋다면 우리가 이 시점에서 저 시점으로 가는 경로 상의 언어들을 사용하게 될 것이라는 점 때문에 생각해 볼 가치가 있습니다.

저는 종족처럼 언어들도 진화의 계통을 형성할 것이며, 모든 곳에서 막다른 골목들이 갈라져 나올 것이라고 생각합니다. 우리는 이것이 이미 일어나고 있는 것을 볼 수 있습니다.
Cobol은 한때 인기가 많았음에도 불구하고, 지적인 후손이 없어 보입니다. 그것은 진화의 막다른 골목, 즉 네안데르탈 언어와 같습니다.
저는 Java 역시 비슷한 운명을 맞을 것이라고 예측합니다. 사람들은 때때로 제게 "Java가 성공적인 언어가 되지 않을 것이라고 어떻게 말할 수 있습니까? 이미 성공적인 언어인데요."라고 메일을 보냅니다. 그리고 저는 그것이, 만약 성공을 그것에 관한 책의 양(특히 개별 책에 관한 것)이나, 직업을 얻기 위해 그것을 배워야 한다고 믿는 학부생들의 수로 측정한다면, 성공적이라는 것을 인정합니다. 제가 Java가 성공적인 언어가 되지 않을 것이라고 말할 때는, 더 구체적인 의미, 즉 Java가 Cobol처럼 진화의 막다른 골목이 될 것이라고 말하는 것입니다.
이것은 단지 추측일 뿐입니다. 제가 틀릴 수도 있습니다. 여기서 제 요점은 Java를 폄하하려는 것이 아니라, 진화의 계통이라는 문제를 제기하고 사람들이 "X 언어는 계통의 어디에 있는가?"라고 묻도록 하는 것입니다.
이 질문을 하는 이유는 단순히 백 년 뒤 우리의 유령들이 "내가 말했었지"라고 말할 수 있게 하기 위해서가 아닙니다. 그것은 주된 가지에 가까이 머무르는 것이 현재 프로그래밍하기 좋은 언어를 찾는 데 유용한 휴리스틱이기 때문입니다.
어떤 시점에서든, 당신은 아마도 진화의 계통의 주된 가지 위에 있을 때 가장 행복할 것입니다.
네안데르탈인이 아직 많이 남아 있었을 때에도, 그들은 힘들었을 것입니다. 크로마뇽인들은 끊임없이 와서 그들을 때리고 음식을 빼앗았을 것입니다.
제가 백 년 뒤 언어들이 어떨지 알고 싶은 이유는 지금 어떤 계통에 걸어야 할지 알기 위해서입니다.

언어의 진화는 종의 진화와 다릅니다. 왜냐하면 가지들이 합쳐질 수 있기 때문입니다. 예를 들어 Fortran 계통은 Algol의 후손들과 합쳐지는 것으로 보입니다. 이론적으로는 종에게도 이것이 가능하지만, 세포보다 더 큰 규모로는 일어나지 않았을 가능성이 높습니다.
언어의 경우 가능성의 공간이 더 작고, 변이가 무작위가 아니기 때문에 수렴이 더 가능성이 높습니다. 언어 설계자들은 다른 언어의 아이디어를 의도적으로 통합합니다.
특히 언어 설계자들이 프로그래밍 언어의 진화가 어디로 이어질지 생각하는 것은 중요합니다. 그래야 그에 따라 방향을 잡을 수 있기 때문입니다.
그런 경우, "주된 가지에 머무르라"는 것은 좋은 언어를 선택하는 방법을 넘어서는 것이 됩니다.
그것은 언어 설계를 위한 올바른 결정을 내리는 휴리스틱이 됩니다.

모든 프로그래밍 언어는 두 부분으로 나눌 수 있습니다. 하나는 공리 역할을 하는 기본 연산자들의 집합이고, 다른 하나는 이론적으로 이 기본 연산자들의 용어로 작성될 수 있는 나머지 부분입니다.
저는 기본 연산자들이 언어의 장기적인 생존에 가장 중요한 요소라고 생각합니다. 나머지는 바꿀 수 있습니다. 마치 집을 살 때 무엇보다 위치를 고려해야 한다는 규칙과 같습니다. 다른 모든 것은 나중에 고칠 수 있지만, 위치는 고칠 수 없습니다.
공리가 잘 선택되는 것뿐만 아니라, 공리가 적은 것이 중요하다고 생각합니다. 수학자들은 항상 공리에 대해 "적을수록 좋다"고 느껴왔으며, 저는 그들이 무언가에 통달했다고 생각합니다.
적어도, 언어의 핵심을 면밀히 살펴보고 제거할 수 있는 공리가 있는지 확인하는 것은 유용한 연습입니다. 저는 게으름뱅이로서의 긴 경력 동안 불필요한 군더더기는 또 다른 군더더기를 낳는다는 것을 발견했으며, 이것이 침대 밑이나 방구석뿐만 아니라 소프트웨어에서도 발생하는 것을 보았습니다.
저는 진화의 계통의 주된 가지들이 가장 작고 깨끗한 핵심을 가진 언어들을 통과할 것이라는 추측을 하고 있습니다.

언어의 더 많은 부분을 그 언어 자체로 작성할 수 있다면 더 좋습니다.
물론, 백 년 뒤 프로그래밍 언어가 어떨지 묻는 것 자체가 큰 가정입니다.
백 년 뒤에도 우리가 프로그램을 작성할까요? 그냥 컴퓨터에게 우리가 원하는 것을 말해주면 되지 않을까요?
그 방면에서는 지금까지 큰 진전이 없었습니다.
제 추측은 백 년 뒤에도 사람들은 여전히 우리가 인식할 수 있는 종류의 프로그램으로 컴퓨터에게 지시할 것이라는 것입니다. 지금은 프로그램을 작성하여 해결하는 작업들이 백 년 뒤에는 프로그램을 작성할 필요 없이 해결될 수도 있겠지만, 여전히 우리가 오늘날 하는 종류의 프로그래밍이 많이 있을 것이라고 생각합니다.
백 년 뒤 어떤 기술이 보일지 아무도 예측할 수 있다고 생각하는 것은 건방질 수 있습니다. 하지만 우리는 이미 50년 가까운 역사를 가지고 있다는 것을 기억하십시오.
백 년을 내다보는 것은 지난 50년간 언어가 얼마나 느리게 진화했는지를 고려할 때 파악 가능한 아이디어입니다.
언어는 실제로 기술이 아니기 때문에 느리게 진화합니다. 언어는 표기법입니다. 프로그램은 컴퓨터가 당신을 위해 해결해주기를 바라는 문제를 형식적으로 설명한 것입니다. 따라서 프로그래밍 언어의 진화 속도는 운송이나 통신과 같은 것들보다는 수학적 표기법의 진화 속도에 더 가깝습니다.
수학적 표기법은 진화하지만, 기술에서 볼 수 있는 거대한 도약과는 그렇지 않습니다.

백 년 뒤 컴퓨터가 무엇으로 만들어지든, 지금보다 훨씬 빨라질 것이라고 예측하는 것은 안전해 보입니다. 만약 무어의 법칙이 계속해서 나온다면, 그것들은 7400경 (73,786,976,294,838,206,464) 배 더 빨라질 것입니다. 그것은 상상하기 어렵습니다. 그리고 실제로, 속도 부서에서 가장 가능성 있는 예측은 무어의 법칙이 작동하지 않게 될 것이라는 점일 수 있습니다.
18개월마다 두 배가 되기로 되어 있는 것은 결국 어떤 종류의 근본적인 한계에 부딪힐 가능성이 높습니다.
하지만 컴퓨터가 훨씬 더 빨라질 것이라는 것을 믿는 데 아무런 문제가 없습니다. 설령 백만 배만 빨라진다고 해도, 그것은 프로그래밍 언어의 기본 규칙을 상당히 바꿔야 합니다. 다른 것들 중에서도, 현재로서는 느린 언어, 즉 매우 효율적인 코드를 생성하지 못하는 언어들을 위한 더 많은 공간이 있을 것입니다.
하지만 여전히 일부 애플리케이션은 속도를 요구할 것입니다.
우리가 컴퓨터로 해결하려는 문제 중 일부는 컴퓨터 자체에 의해 만들어집니다. 예를 들어, 비디오 이미지를 처리해야 하는 속도는 다른 컴퓨터가 이미지를 생성할 수 있는 속도에 따라 달라집니다. 그리고 사이클을 흡수할 무한한 능력을 본질적으로 가진 또 다른 종류의 문제들이 있습니다: 이미지 렌더링, 암호화, 시뮬레이션.
일부 애플리케이션은 점점 더 비효율적이 될 수 있지만 다른 것들은 하드웨어가 제공할 수 있는 모든 속도를 계속 요구한다면, 더 빠른 컴퓨터는 언어가 점점 더 넓은 범위의 효율성을 다루어야 함을 의미할 것입니다. 우리는 이것이 이미 일어나고 있는 것을 보았습니다. 일부 인기 있는 새 언어들의 현재 구현은 이전 수십 년의 기준에서 볼 때 놀랍도록 낭비적입니다.
이것은 프로그래밍 언어에서만 일어나는 일이 아닙니다. 이것은 일반적인 역사적 추세입니다. 기술이 발전함에 따라 각 세대는 이전 세대가 낭비라고 생각했을 법한 일들을 할 수 있습니다. 30년 전 사람들은 우리가 원거리 전화 통화를 얼마나 아무렇지 않게 하는지에 놀랐을 것입니다.
100년 전 사람들은 한때 보스턴에서 멤피스를 거쳐 뉴욕으로 소포가 여행할 것이라는 사실에 더욱 놀랐을 것입니다.
저는 앞으로 100년 동안 더 빨라진 하드웨어가 우리에게 줄 추가적인 사이클이 모두 어디로 갈지 이미 말해줄 수 있습니다. 거의 전부 낭비될 것입니다.
저는 컴퓨터 파워가 부족했던 시절에 프로그래밍을 배웠습니다.
TRS-80의 4K 메모리에 맞추기 위해 Basic 프로그램의 모든 공백을 제거했던 것을 기억합니다. 반복적으로 같은 일을 하는 이 엄청나게 비효율적인 소프트웨어가 사이클을 태워버린다는 생각은 제게 좀 역겹게 느껴집니다. 하지만 제 직관이 틀렸다고 생각합니다. 저는 가난하게 자라서 중요한 일, 예를 들어 의사에게 가는 것조차 돈을 쓰는 것을 참을 수 없는 사람과 같습니다.
어떤 종류의 낭비는 정말 역겹습니다. 예를 들어 SUV는 연료가 절대 떨어지지 않고 오염을 전혀 발생시키지 않는다고 가정하더라도 혐오스러울 수 있습니다. SUV는 혐오스러운 문제에 대한 해결책이기 때문에 혐오스럽습니다. (미니밴을 더 남성적으로 보이게 하는 방법.)
하지만 모든 낭비가 나쁜 것은 아닙니다. 이제 그것을 지원할 기반 시설이 생겼으므로, 장거리 통화 시간을 세는 것은 하찮아 보이기 시작합니다. 자원이 있다면, 모든 전화 통화를 어떤 종류의 것이든 하나로 생각하는 것이 더 우아합니다. 상대방이 어디에 있든 상관없이 말입니다.
낭비에는 좋은 것과 나쁜 것이 있습니다. 저는 좋은 낭비, 즉 더 많이 지출함으로써 더 단순한 설계를 얻을 수 있는 종류의 낭비에 관심이 있습니다. 새로운 더 빠른 하드웨어에서 얻을 기회를 어떻게 활용하여 사이클을 낭비할까요?
우리의 빈약한 컴퓨터와 함께 우리의 본성에 너무 깊이 각인된 속도에 대한 갈망은 그것을 극복하기 위해 의식적인 노력이 필요할 것입니다. 언어 설계에서 우리는 효율성을 아주 작은 편의성 향상과 거래할 수 있는 상황을 의식적으로 찾아야 합니다.
대부분의 자료 구조는 속도 때문에 존재합니다. 예를 들어, 오늘날 많은 언어들은 문자열과 리스트를 모두 가지고 있습니다. 의미론적으로 문자열은 요소가 문자인 리스트의 부분집합이나 다름없습니다. 그렇다면 왜 별도의 데이터 타입을 필요로 할까요?
사실 필요하지 않습니다. 문자열은 오직 효율성을 위해서만 존재합니다. 하지만 프로그램을 더 빨리 실행하기 위한 해킹으로 언어의 의미론을 어지럽히는 것은 구립니다.
언어에 문자열을 포함시키는 것은 조기 최적화의 사례인 것 같습니다.
만약 우리가 언어의 핵심을 공리 집합으로 생각한다면, 단순히 효율성을 위해 표현력에 아무런 기여도 하지 않는 추가 공리를 갖는 것은 확실히 역겹습니다. 효율성은 중요하지만, 그것을 얻는 올바른 방법은 아니라고 생각합니다.
그 문제를 해결하는 올바른 방법은 프로그램의 의미와 구현 세부 사항을 분리하는 것이라고 생각합니다. 리스트와 문자열을 모두 가지는 대신, 리스트만 가지고 컴파일러에게 필요하다면 문자열을 연속된 바이트로 배치할 수 있도록 하는 최적화 조언을 제공할 방법을 갖추는 것입니다.
프로그램의 대부분에서는 속도가 중요하지 않으므로, 일반적으로 이러한 종류의 미세한 관리에 대해 걱정할 필요가 없을 것입니다.
컴퓨터가 빨라질수록 이것은 점점 더 사실이 될 것입니다.
구현에 대해 더 적게 말하는 것은 프로그램을 더 유연하게 만드는 데 도움이 될 것입니다.

프로그램이 작성되는 동안 명세는 변경되며, 이는 필연적일 뿐만 아니라 바람직합니다.
"에세이(essay)"라는 단어는 프랑스어 동사 "essayer"에서 유래했으며, 이는 "시도하다"를 의미합니다.
에세이는 원래 의미에서 무언가를 파악하기 위해 쓰는 것입니다. 이것은 소프트웨어에서도 발생합니다. 저는 최고의 프로그램 중 일부는 에세이였다고 생각합니다. 작성자들이 시작할 때 무엇을 쓰려는지 정확히 알지 못했다는 점에서 말입니다.

Lisp 해커들은 이미 자료 구조의 유연성의 가치를 알고 있습니다. 우리는 프로그램의 첫 번째 버전을 모든 것을 리스트로 처리하도록 작성하는 경향이 있습니다. 이러한 초기 버전은 너무나 비효율적이어서, 그것들이 하는 일에 대해 생각하지 않으려는 의식적인 노력이 필요합니다. 마치 제 경우 적어도 스테이크를 먹는 데 그것이 어디서 왔는지 생각하지 않으려는 의식적인 노력이 필요한 것처럼 말입니다.
백 년 뒤 프로그래머들이 가장 찾게 될 것은 가능한 최소한의 노력으로 엄청나게 비효율적인 버전 1 프로그램을 엮어낼 수 있는 언어일 것입니다. 적어도 그것이 현재 용어로 우리가 설명하는 방식입니다. 그들이 말하려는 것은 프로그래밍하기 쉬운 언어를 원한다는 것입니다.
비효율적인 소프트웨어는 역겹지 않습니다. 역겨운 것은 프로그래머가 불필요한 작업을 하게 만드는 언어입니다. 프로그래머 시간을 낭비하는 것이 진정한 비효율이며, 기계 시간을 낭비하는 것이 아닙니다. 컴퓨터가 빨라짐에 따라 이것은 점점 더 명확해질 것입니다.
문자열을 없애는 것은 우리가 이미 생각해 볼 수 있는 것이라고 생각합니다. 우리는 Arc에서 그렇게 했으며, 그것은 좋은 결과인 것 같습니다. 정규 표현식으로 설명하기 어색했던 일부 연산은 재귀 함수로 쉽게 설명될 수 있습니다.
자료 구조의 평탄화가 어디까지 갈까요? 제 의식적으로 넓어진 마음으로도 충격적인 가능성들을 생각해낼 수 있습니다. 예를 들어 배열을 없애버릴까요? 결국 그것들은 키가 정수 벡터인 해시 테이블의 부분집합일 뿐입니다. 해시 테이블 자체를 리스트로 대체할까요?
그보다 더 충격적인 전망도 있습니다. 예를 들어 McCarthy가 1960년에 설명한 Lisp에는 숫자가 없었습니다. 논리적으로 숫자를 별도의 개념으로 가질 필요는 없습니다. 리스트로 표현할 수 있기 때문입니다: 정수 n은 n개의 요소를 가진 리스트로 표현될 수 있습니다. 이런 식으로 수학을 할 수 있습니다. 단지 참을 수 없을 정도로 비효율적일 뿐입니다.
실제로 숫자를 리스트로 구현하자고 제안한 사람은 아무도 없습니다. 사실, McCarthy의 1960년 논문은 당시에는 구현될 의도가 아니었습니다. 그것은 이론적 연습, 튜링 기계에 대한 더 우아한 대안을 만들려는 시도였습니다. 예상치 못하게 누군가가 이 논문을 가져와 작동하는 Lisp 인터프리터로 번역했을 때, 숫자는 확실히 리스트로 표현되지 않았습니다. 그것들은 모든 다른 언어에서처럼 이진수로 표현되었습니다.
프로그래밍 언어가 숫자를 기본 데이터 타입으로 없애는 것까지 갈 수 있을까요? 저는 이것을 심각한 질문이라기보다는 미래와 치킨 게임을 하는 방식으로 묻습니다. 그것은 마치 불가능한 힘이 움직이지 않는 물체를 만나는 가상적인 경우와 같습니다. 여기서는 상상할 수 없을 정도로 비효율적인 구현과 상상할 수 없을 정도로 큰 자원이 만나는 것입니다.
왜 안 될까요? 미래는 꽤 깁니다. 만약 우리가 언어 핵심의 공리 수를 줄이기 위해 할 수 있는 일이 있다면, t가 무한대로 갈 때 걸어야 할 쪽은 그것이라고 생각됩니다. 만약 그 생각이 백 년 뒤에도 여전히 참을 수 없다면, 아마 천 년 뒤에는 그렇지 않을지도 모릅니다.
이것을 명확히 하기 위해, 모든 수치 계산이 실제로 리스트를 사용하여 수행될 것이라고 제안하는 것은 아닙니다. 저는 추가적인 구현 관련 표기법 이전에 핵심 언어가 이런 식으로 정의되어야 한다고 제안하는 것입니다. 실제로는 많은 양의 수학을 하고 싶은 프로그램은 아마도 숫자를 이진수로 표현하겠지만, 이것은 최적화이지 핵심 언어 의미론의 일부는 아닐 것입니다.

사이클을 태워버리는 또 다른 방법은 애플리케이션과 하드웨어 사이에 많은 소프트웨어 계층을 두는 것입니다. 이것 또한 이미 일어나고 있는 추세입니다. 많은 최신 언어는 바이트 코드로 컴파일됩니다. Bill Woods는 경험 법칙으로 각 해석 계층마다 속도가 10배씩 비용이 든다고 말했습니다. 이 추가 비용은 유연성을 제공합니다.
Arc의 첫 번째 버전은 이러한 다단계 느림의 극단적인 사례였으며, 그에 상응하는 이점도 있었습니다. 그것은 Common Lisp 위에 작성된 전형적인 "메타순환" 인터프리터였으며, McCarthy의 원래 Lisp 논문에서 정의된 eval 함수와 뚜렷한 가족적 유사성을 가졌습니다.
전체 시스템은 불과 수백 줄의 코드였기 때문에 이해하고 변경하기가 매우 쉬웠습니다. 우리가 사용한 Common Lisp, 즉 CLisp는 그 자체로 바이트 코드 인터프리터 위에 실행됩니다. 그래서 우리는 두 단계의 해석을 가지고 있었고, 그중 하나(가장 위쪽)는 놀랍도록 비효율적이었지만 언어는 사용할 수 있었습니다. 간신히 사용할 수 있었지만 말입니다.
소프트웨어를 여러 계층으로 작성하는 것은 애플리케이션 내에서도 강력한 기법입니다. 하향식 프로그래밍은 프로그램을 일련의 계층으로 작성하는 것을 의미하며, 각 계층은 그 위의 계층을 위한 언어 역할을 합니다. 이 접근 방식은 더 작고 유연한 프로그램을 생성하는 경향이 있습니다. 또한 재사용성이라는 성배에 도달하는 가장 좋은 경로이기도 합니다. 언어는 정의상 재사용 가능합니다. 애플리케이션의 더 많은 부분을 해당 종류의 애플리케이션을 작성하는 언어로 밀어 넣을수록 더 많은 소프트웨어를 재사용할 수 있습니다.
어떻게든 재사용성에 대한 아이디어가 1980년대에 객체 지향 프로그래밍과 연결되었고, 그 반대 증거가 아무리 많아도 그것을 떨쳐낼 수 없는 것 같습니다. 하지만 일부 객체 지향 소프트웨어가 재사용 가능하더라도, 그것을 재사용 가능하게 만드는 것은 객체 지향성 때문이 아니라 하향식(bottom-upness) 때문입니다.
라이브러리를 고려해 보십시오. 라이브러리가 객체 지향 스타일로 작성되었든 아니든 상관없이 언어이기 때문에 재사용 가능합니다.
참고로 객체 지향 프로그래밍의 종말을 예측하지는 않습니다. 좋은 프로그래머에게는 특정 전문 분야를 제외하고는 별로 제공할 것이 없다고 생각하지만, 대규모 조직에게는 거부할 수 없습니다. 객체 지향 프로그래밍은 스파게티 코드를 작성하는 지속 가능한 방법을 제공합니다. 그것은 프로그램을 패치의 연속으로 축적할 수 있게 해줍니다.
대규모 조직은 항상 이런 식으로 소프트웨어를 개발하는 경향이 있으며, 이는 오늘날처럼 백 년 뒤에도 마찬가지일 것이라고 예상합니다.

미래에 대해 이야기하는 김에, 병렬 컴퓨팅에 대해서도 이야기해야 합니다. 이 아이디어는 거기에 사는 것처럼 보이기 때문입니다. 즉, 언제 이야기하든 병렬 컴퓨팅은 미래에 일어날 일이라고들 합니다.
미래가 그것을 따라잡을 수 있을까요? 사람들은 적어도 20년 동안 병렬 컴퓨팅을 임박한 것으로 이야기해 왔지만, 지금까지 프로그래밍 관행에 큰 영향을 미치지 못했습니다.
아니면 영향을 미치지 않았을까요? 이미 칩 설계자들은 그것에 대해 생각해야 하며, 다중 CPU 컴퓨터에서 시스템 소프트웨어를 작성하려는 사람들도 마찬가지입니다.
진정한 질문은 추상화 계층을 따라 병렬성이 얼마나 멀리 퍼져 나갈 것인가입니다.
백 년 뒤에도 애플리케이션 프로그래머에게 영향을 미칠까요? 아니면 컴파일러 개발자들이 생각하는 무언가가 되겠지만, 일반적으로 애플리케이션의 소스 코드에서는 보이지 않을까요?
가능성이 높은 한 가지는 병렬성의 대부분의 기회가 낭비될 것이라는 점입니다. 이것은 우리가 얻는 대부분의 추가 컴퓨터 파워가 낭비될 것이라는 제 더 일반적인 예측의 특별한 경우입니다. 기본 하드웨어의 엄청난 속도와 마찬가지로, 병렬성은 명시적으로 요청하면 사용할 수 있지만 일반적으로 사용되지 않는 무언가가 될 것이라고 예상합니다. 이는 백 년 뒤 우리가 갖게 될 병렬성은 특별한 애플리케이션을 제외하고는 대규모 병렬성이 아닐 것임을 의미합니다. 일반 프로그래머에게는 모든 것이 병렬로 실행되는 프로세스를 생성할 수 있는 것과 비슷할 것이라고 예상합니다.
그리고 이것은 자료 구조의 특정 구현을 요청하는 것과 마찬가지로, 최적화하려고 할 때 프로그램 수명 주기 후반부에 하게 될 무언가가 될 것입니다. 버전 1은 병렬 연산에서 얻을 수 있는 이점이나 데이터의 특정 표현에서 얻을 수 있는 이점을 무시할 것입니다.

특별한 종류의 애플리케이션을 제외하고, 백 년 뒤 작성되는 프로그램에는 병렬성이 만연하지 않을 것입니다. 만약 그렇다면 그것은 조기 최적화일 것입니다.

백 년 뒤에는 프로그래밍 언어가 몇 개나 있을까요? 최근에 엄청나게 많은 수의 새로운 프로그래밍 언어가 나온 것 같습니다. 그 이유 중 일부는 더 빠른 하드웨어 덕분에 프로그래머들이 애플리케이션에 따라 속도와 편의성 간의 다른 절충을 할 수 있게 되었다는 것입니다. 이것이 실제 추세라면, 백 년 뒤의 하드웨어는 그것을 더욱 증가시켜야 합니다.
하지만 백 년 뒤에는 널리 사용되는 언어가 몇 개 없을 수도 있습니다. 제가 그렇게 말하는 이유 중 일부는 낙관론입니다. 만약 당신이 정말 좋은 일을 했다면, 느린 버전 1을 작성하는 데 이상적인 언어를 만들 수 있었을 것이고, 올바른 최적화 조언을 컴파일러에 제공하면 필요할 때 매우 빠른 코드를 생성할 수도 있었을 것입니다.
따라서 저는 낙관적이므로, 허용 가능한 효율성과 최대 효율성 사이의 엄청난 격차가 벌어지더라도 백 년 뒤의 프로그래머들은 대부분의 범위를 포괄할 수 있는 언어를 갖게 될 것이라고 예측합니다.
이 격차가 벌어짐에 따라 프로파일러는 점점 더 중요해질 것입니다.
지금은 프로파일링에 거의 주의를 기울이지 않습니다. 많은 사람들은 여전히 빠른 애플리케이션을 얻는 방법은 빠른 코드를 생성하는 컴파일러를 작성하는 것이라고 믿는 것 같습니다. 허용 가능한 성능과 최대 성능 사이의 격차가 벌어짐에 따라, 빠른 애플리케이션을 얻는 방법은 한쪽에서 다른 쪽으로 가는 좋은 안내자를 갖는 것이라는 점이 점점 더 명확해질 것입니다.
언어가 몇 개 없을 수도 있다고 말할 때, 저는 도메인 특화 "작은 언어"는 포함하지 않습니다. 저는 그러한 임베디드 언어가 훌륭한 아이디어라고 생각하며, 그것들이 확산될 것이라고 예상합니다. 하지만 사용자들이 그 아래에 있는 범용 언어를 볼 수 있도록 충분히 얇게 작성될 것이라고 예상합니다.

미래의 언어를 누가 설계할까요? 지난 10년간 가장 흥미로운 추세 중 하나는 Perl, Python, Ruby와 같은 오픈 소스 언어의 부상입니다.
언어 설계는 해커들에 의해 인수되고 있습니다. 지금까지의 결과는 지저분하지만 고무적입니다. 예를 들어 Perl에는 놀랍도록 참신한 아이디어들이 있습니다. 많은 아이디어는 놀랍도록 나쁘지만, 야심 찬 노력에는 항상 그렇습니다. 현재의 변이 속도로는, 백 년 뒤 Perl이 무엇으로 진화할지 신만이 아실 것입니다.
할 수 없는 사람이 가르친다는 것은 사실이 아닙니다 (제가 아는 최고의 해커 중 일부는 교수입니다). 하지만 가르치는 사람들이 할 수 없는 일이 많다는 것은 사실입니다.
연구는 제약을 가합니다. 어떤 학문 분야든 괜찮은 주제와 그렇지 않은 주제가 있습니다. 불행히도 허용 가능한 주제와 금지된 주제의 구분은 보통 연구 논문에서 어떻게 들리는지에 따라 결정되며, 좋은 결과를 얻는 데 얼마나 중요한지에 따라 결정되지는 않습니다. 극단적인 경우는 문학일 것입니다. 문학을 연구하는 사람들은 그것을 생산하는 사람들에게 조금이라도 도움이 될 만한 말을 거의 하지 않습니다.
과학에서는 상황이 더 낫지만, 허용되는 작업과 좋은 언어를 산출하는 작업 사이의 중첩은 놀랍도록 작습니다. (Olin Shivers는 이에 대해 능숙하게 불평했습니다.) 예를 들어, 타입은 연구 논문의 고갈되지 않는 원천인 것처럼 보이지만, 정적 타이핑은 실제 매크로를 배제하는 것으로 보입니다. 제 의견으로는 매크로 없이는 어떤 언어도 사용할 가치가 없습니다.
추세는 언어가 "연구"가 아니라 오픈 소스 프로젝트로 개발되는 쪽으로만 가는 것이 아니라, 컴파일러 개발자가 아니라 그것들을 사용해야 하는 애플리케이션 프로그래머에 의해 설계되는 쪽으로도 가고 있습니다. 이것은 좋은 추세인 것 같으며 계속될 것으로 예상합니다.
물리학과는 달리 백 년 뒤의 물리학은 거의 필연적으로 예측할 수 없지만, 백 년 뒤 사용자에게 어필할 수 있는 언어를 지금 설계하는 것은 원칙적으로 가능할 수도 있다고 생각합니다.

언어를 설계하는 한 가지 방법은 번역할 수 있는 컴파일러나 실행할 수 있는 하드웨어가 있는지 여부에 관계없이 작성하고 싶은 프로그램을 그냥 작성하는 것입니다.
이렇게 할 때 무제한의 자원을 가정할 수 있습니다. 백 년 뒤뿐만 아니라 오늘날에도 무제한의 자원을 상상할 수 있어야 할 것 같습니다.
어떤 프로그램을 쓰고 싶을까요? 가장 적은 노력이 드는 것.
정확히는 아니지만: 당신의 프로그래밍 아이디어가 현재 사용 중인 언어의 영향을 받지 않는다면 가장 적은 노력이 드는 것. 그러한 영향은 너무 널리 퍼져 있어서 극복하기 위해 큰 노력이 필요할 수 있습니다. 우리처럼 게으른 생명체에게 최소한의 노력으로 프로그램을 표현하는 방법을 아는 것은 명백해야 할 것입니다. 실제로 우리가 가능한 것에 대한 아이디어는 우리가 생각하는 언어에 의해 너무 제한되어 있어서, 프로그램의 더 쉬운 표현은 매우 놀랍습니다. 그것들은 당신이 발견해야 하는 것이지, 당신이 자연스럽게 빠져드는 것이 아닙니다.

여기서 도움이 되는 트릭 중 하나는 프로그램의 길이를 작성하는 데 드는 노력의 근사치로 사용하는 것입니다. 물론 문자 단위의 길이가 아니라, 구문 요소의 수, 기본적으로 파스 트리(parse tree)의 크기입니다. 가장 짧은 프로그램이 작성하는 데 가장 적은 노력이라고 완전히는 아닐지라도, 그것은 충분히 가까워서 노력보다는 간결함이라는 확고한 목표를 겨냥하는 것이 더 낫습니다.
그러면 언어 설계 알고리즘은 다음과 같습니다: 프로그램을 보고, 이것을 더 짧게 작성할 방법이 있는지 묻는 것입니다.
실제로는 상상의 백 년짜리 언어로 프로그램을 작성하는 것이 핵심에 얼마나 가까운지에 따라 다양한 정도로 작동할 것입니다. 정렬 루틴은 지금 작성할 수 있습니다. 하지만 백 년 뒤에 어떤 종류의 라이브러리가 필요할지 지금 예측하는 것은 어려울 것입니다. 아마도 많은 라이브러리는 아직 존재하지 않는 도메인을 위한 것일 것입니다. 만약 SETI@home이 작동한다면, 예를 들어 외계인과의 통신을 위한 라이브러리가 필요할 것입니다. 물론 그들이 이미 XML로 통신할 만큼 충분히 발전하지 않은 이상은 말입니다.
다른 극단에서는 핵심 언어를 오늘날 설계할 수 있다고 생각합니다. 사실, 어떤 사람들은 그것이 이미 1958년에 대부분 설계되었다고 주장할 수도 있습니다.

만약 백 년짜리 언어가 오늘날 사용 가능하다면, 우리는 그것으로 프로그래밍하고 싶을까요? 이 질문에 답하는 한 가지 방법은 과거를 돌아보는 것입니다. 만약 현재의 프로그래밍 언어가 1960년에 사용 가능했다면, 누군가 그것을 사용하고 싶었을까요?
어떤 면에서는 답은 '아니오'입니다. 오늘날의 언어는 1960년에는 존재하지 않았던 기반 시설을 가정합니다. 예를 들어, Python처럼 들여쓰기가 중요한 언어는 프린터 터미널에서는 잘 작동하지 않았을 것입니다. 하지만 그러한 문제를 제쳐두고 (예를 들어, 모든 프로그램이 종이에 작성되었다고 가정하면) 1960년대의 프로그래머들은 지금 우리가 사용하는 언어로 프로그램을 작성하는 것을 좋아했을까요?
그렇다고 생각합니다.
상상력이 부족한 일부 사람들은, 프로그램이란 무엇인가에 대한 그들의 생각 속에 초기 언어의 아티팩트가 내장되어 있어서 어려움을 겪었을 것입니다. (포인터 연산을 하지 않고 어떻게 데이터를 조작할 수 있습니까? goto 없이 플로우 차트를 어떻게 구현할 수 있습니까?) 하지만 가장 똑똑한 프로그래머들은 현재의 언어를 가지고 있었다면 그것들을 최대한 활용하는 데 아무런 문제가 없었을 것이라고 생각합니다.
만약 우리가 지금 백 년짜리 언어를 가지고 있다면, 그것은 적어도 훌륭한 의사 코드(pseudocode) 역할을 할 것입니다. 소프트웨어를 작성하는 데는 어떨까요? 백 년짜리 언어는 일부 애플리케이션에 대해 빠른 코드를 생성해야 하므로, 아마도 오늘날의 하드웨어에서 합리적으로 잘 실행될 만큼 효율적인 코드를 생성할 수 있을 것입니다. 백 년 뒤 사용자들보다 더 많은 최적화 조언을 제공해야 할 수도 있지만, 여전히 순이익이 될 수 있습니다.

이제 두 가지 아이디어가 있는데, 이 둘을 결합하면 흥미로운 가능성을 시사합니다: (1) 백 년짜리 언어는 원칙적으로 오늘날 설계될 수 있으며, (2) 그러한 언어가 존재한다면 오늘날 프로그래밍하기에 좋을 수 있습니다. 이 아이디어들을 그렇게 나열하면, 왜 지금 백 년짜리 언어를 작성해 보지 않느냐는 생각이 들지 않을 수 없습니다.
언어 설계를 할 때, 그러한 목표를 가지고 의식적으로 염두에 두는 것이 좋다고 생각합니다. 운전을 배울 때, 그들이 당신에게 가르치는 원칙 중 하나는 후드를 도로에 칠해진 줄에 맞추는 것이 아니라 멀리 있는 지점을 목표로 삼아 자동차를 정렬하는 것입니다. 설령 당신이 신경 쓰는 것이 다음 10피트의 일뿐이라고 해도, 이것이 올바른 답입니다. 프로그래밍 언어에 대해서도 마찬가지라고 생각하며, 그렇게 할 수 있고 해야 합니다.

각주
저는 Lisp Machine Lisp가 선언(동적 변수의 선언 제외)이 단순히 최적화 조언이며 올바른 프로그램의 의미를 변경하지 않는다는 원칙을 처음으로 구현했다고 믿습니다. Common Lisp는 이것을 명시적으로 명시한 최초의 언어인 것 같습니다.

감사합니다
이 글의 초안을 읽어준 Trevor Blackwell, Robert Morris, Dan Giffin에게 감사드리며, Guido van Rossum, Jeremy Hylton 및 나머지 Python 팀에게 PyCon에서 연설할 기회를 준 것에 감사드립니다.