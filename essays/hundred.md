# 백 년 후의 언어 (The Hundred-Year Language)

2003년 4월

(이 에세이는 PyCon 2003의 기조연설에서 발췌한 것입니다.)

백 년 후의 삶이 어떨지 예측하기란 어렵습니다. 확실하게 말할 수 있는 몇 가지 것들이 있습니다. 모두가 나는 자동차를 운전하고, 건축법이 완화되어 수백 층짜리 건물을 지을 수 있게 되며, 대부분의 시간이 어둡고, 여성들은 모두 무술 훈련을 받을 것이라는 사실을 우리는 압니다.

여기서 저는 이 그림의 한 가지 세부 사항에 집중하고 싶습니다. 그 나는 자동차를 제어하는 소프트웨어를 작성하는 데 어떤 종류의 프로그래밍 언어를 사용할까요?

이것을 생각해보는 이유는 우리가 실제로 그 언어들을 사용하게 될 것이기 때문이 아니라, 운이 좋다면 지금부터 그 시점까지의 길목에 있는 언어들을 사용하게 될 것이기 때문입니다.

저는 언어가 종처럼 진화의 나무를 형성할 것이며, 곳곳에 막다른 길들이 갈라져 나올 것이라고 생각합니다. 우리는 이미 이런 현상이 일어나고 있음을 볼 수 있습니다. 코볼(Cobol)은 한때 인기가 많았음에도 불구하고, 어떤 지적 후손도 없는 것 같습니다. 그것은 진화의 막다른 길, 즉 네안데르탈 언어입니다.

저는 자바(Java)도 비슷한 운명을 맞을 것이라고 예측합니다. 사람들은 때때로 저에게 "어떻게 자바가 성공적인 언어가 되지 못할 것이라고 말할 수 있습니까? 이미 성공적인 언어인데요."라고 이메일을 보냅니다. 저는 그것이 책들이 차지하는 서가 공간(특히 그 언어에 대한 개별 책들)이나 직업을 얻기 위해 배워야 한다고 믿는 학부생의 수로 성공을 측정한다면 성공적임을 인정합니다. 제가 자바가 성공적인 언어가 되지 못할 것이라고 말할 때는 좀 더 구체적인 의미입니다. 즉, 자바가 코볼처럼 진화의 막다른 길이 될 것이라는 뜻입니다.

이것은 단지 추측일 뿐입니다. 제가 틀릴 수도 있습니다. 여기서 제 요점은 자바를 비방하려는 것이 아니라, 진화의 나무라는 문제를 제기하고 사람들이 '언어 X는 그 나무의 어디에 있는가?'라는 질문을 던지게 하는 것입니다.

이 질문을 던지는 이유는 백 년 후에 우리의 유령들이 '내가 말했잖아'라고 말하기 위함만은 아닙니다. 지금 프로그래밍하기 좋은 언어를 찾는 데 주요 가지에 가까이 머무는 것이 유용한 발견법(heuristic)이기 때문입니다.

어느 시점에서든, 진화의 나무의 주요 가지에 있을 때 가장 행복할 것입니다. 네안데르탈인이 아직 많았을 때조차도, 그들로 사는 것은 끔찍했을 것입니다. 크로마뇽인들이 끊임없이 와서 그들을 때리고 음식을 훔쳐갔을 테니까요. 제가 백 년 후의 언어가 어떨지 알고 싶은 이유는 지금 어떤 나무의 가지에 걸어야 할지 알기 위해서입니다.

언어의 진화는 종의 진화와 다릅니다. 가지들이 수렴할 수 있기 때문입니다. 예를 들어, 포트란(Fortran) 가지는 알골(Algol)의 후손들과 합쳐지는 것 같습니다. 이론적으로는 종에게도 가능하지만, 세포보다 큰 것에게는 일어날 가능성이 낮습니다. 언어의 수렴이 더 가능성이 높은 이유는 부분적으로 가능성의 공간이 더 작기 때문이고, 부분적으로 돌연변이가 무작위가 아니기 때문입니다. 언어 설계자들은 다른 언어의 아이디어를 의도적으로 통합합니다.

특히 언어 설계자들이 프로그래밍 언어의 진화가 어디로 이어질지 생각하는 것이 유용합니다. 그에 맞춰 방향을 잡을 수 있기 때문입니다. 이 경우, "주요 가지에 머물러라"는 좋은 언어를 선택하는 방법 이상이 됩니다. 언어 설계에 대한 올바른 결정을 내리는 발견법(heuristic)이 됩니다.

모든 프로그래밍 언어는 두 부분으로 나눌 수 있습니다. 공리(axiom) 역할을 하는 근본적인 연산자(operator)들의 집합과, 원칙적으로 이 근본적인 연산자들로 작성될 수 있는 언어의 나머지 부분입니다. 저는 근본적인 연산자들이 언어의 장기적인 생존에 가장 중요한 요소라고 생각합니다. 나머지는 바꿀 수 있습니다. 집을 살 때 위치를 최우선으로 고려해야 한다는 규칙과 같습니다. 다른 모든 것은 나중에 고칠 수 있지만, 위치는 고칠 수 없습니다.

저는 공리가 잘 선택되는 것뿐만 아니라, 그 수가 적어야 한다는 것이 중요하다고 생각합니다. 수학자들은 항상 공리에 대해 그렇게 생각했습니다. 적을수록 좋다는 것이죠. 그리고 그들은 뭔가를 발견했습니다. 적어도 언어의 핵심을 면밀히 살펴보아 제거할 수 있는 공리가 있는지 확인하는 것은 유용한 연습이 되어야 합니다. 게으른 사람으로서 오랜 경력을 쌓으면서 잡동사니가 잡동사니를 낳는다는 것을 발견했고, 침대 밑이나 방 모퉁이뿐만 아니라 소프트웨어에서도 이런 일이 일어나는 것을 보았습니다.

저는 진화의 나무의 주요 가지들이 가장 작고 깔끔한 핵심을 가진 언어들을 통과한다는 직감을 가지고 있습니다. 언어 자체로 더 많은 부분을 작성할 수록 더 좋습니다.

물론, 제가 백 년 후의 프로그래밍 언어가 어떨지 묻는 것조차 큰 가정을 하고 있는 것입니다. 백 년 후에도 우리가 프로그램을 작성하고 있을까요? 컴퓨터에게 우리가 원하는 것을 말해주기만 하면 되는 것이 아닐까요?

지금까지 그 분야에서는 많은 진전이 없었습니다.

제 추측으로는 백 년 후에도 사람들은 우리가 지금과 같은 프로그램으로 인식할 수 있는 것을 사용하여 컴퓨터에게 무엇을 해야 할지 말해줄 것입니다. 지금은 프로그램을 작성하여 해결하는 작업 중 일부는 백 년 후에는 프로그램을 작성할 필요가 없을 수도 있지만, 저는 오늘날 우리가 하는 유형의 프로그래밍이 여전히 상당 부분 존재할 것이라고 생각합니다.

어떤 기술이 백 년 후에 어떻게 보일지 누군가가 예측할 수 있다고 생각하는 것은 주제넘게 보일 수 있습니다. 하지만 우리는 이미 거의 오십 년의 역사를 가지고 있다는 것을 기억해야 합니다. 지난 오십 년 동안 언어가 얼마나 느리게 진화했는지를 고려할 때, 백 년을 내다보는 것은 파악할 수 있는 생각입니다.

언어는 느리게 진화합니다. 실제로 기술이 아니기 때문입니다. 언어는 표기법입니다. 프로그램은 컴퓨터가 당신을 위해 해결하기를 원하는 문제에 대한 공식적인 설명입니다. 따라서 프로그래밍 언어의 진화 속도는 운송이나 통신보다는 수학적 표기법의 진화 속도와 더 비슷합니다. 수학적 표기법은 진화하지만, 기술에서 볼 수 있는 거대한 도약은 없습니다.

백 년 후에 컴퓨터가 무엇으로 만들어지든, 지금보다 훨씬 빠를 것이라고 예측하는 것은 안전해 보입니다. 무어의 법칙(Moore's Law)이 계속 적용된다면, 74 경(73,786,976,294,838,206,464)배 더 빨라질 것입니다. 이것은 상상하기 어렵습니다. 그리고 실제로 속도 측면에서 가장 가능성 있는 예측은 무어의 법칙이 작동을 멈출 것이라는 것입니다. 18개월마다 두 배가 되어야 하는 모든 것은 결국 어떤 종류의 근본적인 한계에 부딪힐 가능성이 있습니다.

하지만 컴퓨터가 훨씬 더 빨라질 것이라는 것은 의심할 여지가 없습니다. 설령 고작 백만 배만 빨라진다 해도, 그것은 프로그래밍 언어의 기본 규칙을 상당히 바꿀 것입니다. 다른 무엇보다도, 지금은 느린 언어로 간주될 수 있는, 즉 매우 효율적인 코드를 생성하지 못하는 언어를 위한 공간이 더 많아질 것입니다.

그러나 일부 애플리케이션은 여전히 속도를 요구할 것입니다. 우리가 컴퓨터로 해결하고자 하는 문제 중 일부는 컴퓨터에 의해 생성됩니다. 예를 들어, 비디오 이미지를 처리해야 하는 속도는 다른 컴퓨터가 이미지를 생성할 수 있는 속도에 따라 달라집니다. 그리고 사이클을 흡수하는 무한한 능력을 본질적으로 가진 또 다른 종류의 문제가 있습니다. 이미지 렌더링, 암호화, 시뮬레이션입니다.

일부 애플리케이션은 점점 더 비효율적일 수 있고, 다른 애플리케이션은 하드웨어가 제공할 수 있는 모든 속도를 계속 요구한다면, 더 빠른 컴퓨터는 언어가 훨씬 더 넓은 범위의 효율성을 포괄해야 함을 의미할 것입니다. 우리는 이미 이런 현상이 일어나고 있음을 보았습니다. 일부 인기 있는 새 언어의 현재 구현은 이전 수십 년의 기준으로는 충격적으로 낭비적입니다.

이것은 프로그래밍 언어에서만 일어나는 일이 아닙니다. 일반적인 역사적 추세입니다. 기술이 향상될수록, 각 세대는 이전 세대가 낭비적이라고 생각했을 일을 할 수 있습니다. 삼십 년 전 사람들은 우리가 장거리 전화를 얼마나 아무렇지도 않게 거는지에 놀랄 것입니다. 백 년 전 사람들은 소포가 언젠가 보스턴에서 뉴욕으로 멤피스를 경유하여 이동한다는 사실에 훨씬 더 놀랄 것입니다.

저는 이미 앞으로 백 년 동안 더 빠른 하드웨어가 우리에게 줄 그 모든 여분의 사이클이 어떻게 될지 말해줄 수 있습니다. 거의 모두 낭비될 것입니다.

저는 컴퓨터 성능이 부족했던 시절에 프로그래밍을 배웠습니다. 4K TRS-80의 메모리에 맞추기 위해 베이직(Basic) 프로그램에서 모든 공백을 제거했던 것을 기억합니다. 이 모든 엄청나게 비효율적인 소프트웨어가 똑같은 일을 반복하면서 사이클을 소모하는 것을 생각하면 좀 역겹게 느껴집니다. 하지만 제 직관이 틀렸다고 생각합니다. 저는 가난하게 자란 사람과 같아서, 의사에게 가는 것과 같은 중요한 일에도 돈을 쓰는 것을 참을 수 없습니다.

어떤 종류의 낭비는 정말 혐오스럽습니다. 예를 들어, SUV는 연료가 고갈되지 않고 오염도 발생시키지 않는다 해도 역겨울 수 있습니다. SUV가 역겨운 이유는 역겨운 문제에 대한 해결책이기 때문입니다. (미니밴을 더 남성적으로 보이게 하는 방법).

하지만 모든 낭비가 나쁜 것은 아닙니다. 이제 우리는 그것을 지원할 인프라를 갖추었으므로, 장거리 전화 통화 시간을 계산하는 것이 구두쇠처럼 느껴지기 시작합니다. 자원이 있다면, 상대방이 어디에 있든 모든 전화 통화를 한 종류의 것으로 생각하는 것이 더 우아합니다.

좋은 낭비와 나쁜 낭비가 있습니다. 저는 좋은 낭비에 관심이 있습니다. 즉, 더 많은 비용을 지불함으로써 더 간단한 디자인을 얻을 수 있는 종류의 낭비입니다. 새롭고 더 빠른 하드웨어로부터 얻게 될 사이클 낭비의 기회를 어떻게 활용할까요?

속도에 대한 욕구는 우리의 보잘것없는 컴퓨터에 깊이 새겨져 있어서, 그것을 극복하려면 의식적인 노력이 필요할 것입니다. 언어 설계에서 우리는 효율성을 아주 작은 편의성과 교환할 수 있는 상황을 의식적으로 찾아야 합니다.

대부분의 데이터 구조는 속도 때문에 존재합니다. 예를 들어, 오늘날 많은 언어에는 문자열(string)과 리스트(list)가 모두 있습니다. 의미론적으로 문자열은 요소가 문자인 리스트의 부분집합과 거의 같습니다. 그렇다면 왜 별도의 데이터 타입이 필요할까요? 실제로는 필요하지 않습니다. 문자열은 효율성을 위해서만 존재합니다. 하지만 프로그램을 더 빨리 실행시키기 위한 해킹(hack)으로 언어의 의미론을 복잡하게 만드는 것은 형편없는 일입니다.

언어에 문자열이 있는 것은 조기 최적화(premature optimization)의 경우인 것 같습니다. 언어의 핵심을 공리 집합으로 생각한다면, 단지 효율성을 위해 표현력을 추가하지 않는 추가적인 공리가 있는 것은 분명히 역겹습니다. 효율성은 중요하지만, 그것을 얻는 올바른 방법은 아니라고 생각합니다.

그 문제를 해결하는 올바른 방법은 프로그램의 의미와 구현 세부 사항을 분리하는 것이라고 생각합니다. 리스트와 문자열을 모두 갖는 대신, 필요한 경우 컴파일러가 문자열을 연속된 바이트로 배치할 수 있도록 최적화 조언을 줄 수 있는 방법과 함께 리스트만 갖는 것입니다.

대부분의 프로그램에서 속도가 중요하지 않으므로, 일반적으로 이런 종류의 미세 관리에 신경 쓸 필요가 없을 것입니다. 컴퓨터가 빨라질수록 이것은 점점 더 사실이 될 것입니다. 구현에 대해 덜 말하는 것은 프로그램이 더 유연해지도록 만들 것입니다.

프로그램을 작성하는 동안 사양이 변경되는데, 이것은 불가피할 뿐만 아니라 바람직한 일입니다. '에세이(essay)'라는 단어는 '시도하다'라는 뜻의 프랑스어 동사 'essayer'에서 유래했습니다. 원래 의미의 에세이는 무언가를 알아내기 위해 쓰는 것입니다. 소프트웨어에서도 이런 일이 발생합니다. 저는 최고의 프로그램 중 일부는 에세이였다고 생각합니다. 저자들이 시작할 때 정확히 무엇을 쓰려고 했는지 몰랐다는 의미에서 말입니다.

리습(Lisp) 해커들은 이미 데이터 구조에 유연성을 갖는 것의 가치를 알고 있습니다. 우리는 프로그램의 첫 번째 버전을 모든 것을 리스트로 처리하도록 작성하는 경향이 있습니다. 이 초기 버전은 너무나 충격적으로 비효율적이어서, 제가 스테이크를 먹을 때 그것이 어디서 왔는지 생각하지 않기 위해 의식적인 노력을 기울여야 하는 것처럼, 그들이 무엇을 하고 있는지 생각하지 않기 위해 의식적인 노력이 필요합니다.

백 년 후의 프로그래머들이 가장 찾을 것은 최소한의 노력으로 믿을 수 없을 정도로 비효율적인 프로그램 버전 1을 만들어낼 수 있는 언어입니다. 적어도 이것이 현재의 용어로 우리가 설명하는 방식입니다. 그들이 말할 것은 프로그래밍하기 쉬운 언어를 원한다는 것입니다.

비효율적인 소프트웨어는 역겹지 않습니다. 역겨운 것은 프로그래머에게 불필요한 작업을 시키는 언어입니다. 프로그래머 시간을 낭비하는 것이 진정한 비효율성이지, 기계 시간을 낭비하는 것이 아닙니다. 컴퓨터가 빨라질수록 이것은 더욱 명확해질 것입니다.

문자열을 제거하는 것은 이미 우리가 생각할 만한 일이라고 생각합니다. 우리는 아크(Arc)에서 그렇게 했고, 그것은 이점인 것 같습니다. 정규 표현식으로 설명하기 어색한 일부 연산은 재귀 함수로 쉽게 설명할 수 있습니다.

데이터 구조의 이러한 평탄화는 어디까지 갈까요? 의식적으로 마음을 넓혔음에도 저조차도 놀랄 만한 가능성들이 떠오릅니다. 예를 들어, 배열(array)을 없앨 수 있을까요? 결국 배열은 키가 정수 벡터인 해시 테이블(hash table)의 부분집합일 뿐입니다. 해시 테이블 자체를 리스트로 대체할까요?

그보다 더 충격적인 전망도 있습니다. 예를 들어, 매카시(McCarthy)가 1960년에 설명한 리습에는 숫자가 없었습니다. 논리적으로 숫자에 대한 별도의 개념을 가질 필요는 없습니다. 숫자를 리스트로 표현할 수 있기 때문입니다. 정수 n은 n개의 요소로 구성된 리스트로 표현될 수 있습니다. 이런 식으로 수학을 할 수 있습니다. 단지 참을 수 없을 정도로 비효율적일 뿐입니다.

아무도 실제로 숫자를 리스트로 구현하는 것을 제안하지 않았습니다. 사실 매카시의 1960년 논문은 당시에는 전혀 구현될 의도가 없었습니다. 그것은 이론적인 연습이었습니다. 튜링 기계(Turing Machine)에 대한 더 우아한 대안을 만들려는 시도였습니다. 누군가가 예기치 않게 이 논문을 가져와 작동하는 리습 인터프리터로 번역했을 때, 숫자는 확실히 리스트로 표현되지 않았습니다. 다른 모든 언어처럼 이진수로 표현되었습니다.

프로그래밍 언어가 기본적인 데이터 타입으로서 숫자를 제거하는 데까지 갈 수 있을까요? 저는 이것을 심각한 질문이라기보다는 미래와 치킨 게임을 하는 방식으로서 묻습니다. 이것은 상상할 수 없을 정도로 비효율적인 구현이 상상할 수 없을 정도로 거대한 자원을 만나는, 저항할 수 없는 힘이 움직이지 않는 물체를 만나는 가상의 경우와 같습니다.

안 될 이유가 없다고 생각합니다. 미래는 아주 깁니다. 핵심 언어의 공리 수를 줄일 수 있는 방법이 있다면, t가 무한대에 가까워질 때 그쪽에 걸어야 할 것 같습니다. 백 년 후에도 그 생각이 여전히 참을 수 없다면, 천 년 후에는 그렇지 않을 수도 있습니다.

분명히 말해서, 저는 모든 수치 계산이 실제로 리스트를 사용하여 수행될 것이라고 제안하는 것이 아닙니다. 저는 어떤 구현에 대한 추가적인 표기법이 있기 전에 핵심 언어가 이런 방식으로 정의되어야 한다고 제안하는 것입니다. 실제로는 어떤 수학적 계산이든 하고 싶은 프로그램은 숫자를 이진수로 표현하겠지만, 이것은 최적화일 뿐 핵심 언어의 의미론의 일부가 아닐 것입니다.

사이클을 소모하는 또 다른 방법은 애플리케이션과 하드웨어 사이에 여러 소프트웨어 계층을 두는 것입니다. 이것 또한 우리가 이미 보고 있는 추세입니다. 많은 최근 언어는 바이트 코드(byte code)로 컴파일됩니다. 빌 우즈(Bill Woods)는 제게 경험상 각 해석 계층이 속도에서 10배의 비용을 초래한다고 말한 적이 있습니다. 이 추가 비용은 유연성을 제공합니다.

아크의 첫 번째 버전은 이런 종류의 다단계 느림의 극단적인 경우였으며, 그에 상응하는 이점을 가졌습니다. 그것은 Common Lisp 위에 작성된 전형적인 "메타순환(metacircular)" 인터프리터였으며, 매카시의 원래 리습 논문에 정의된 `eval` 함수와 확실한 가족적 유사성을 가졌습니다. 전체 코드는 겨우 몇 백 줄에 불과해서 이해하고 변경하기가 매우 쉬웠습니다. 우리가 사용한 Common Lisp인 CLisp 자체는 바이트 코드 인터프리터 위에서 실행됩니다. 그래서 여기에는 두 단계의 해석이 있었고, 그중 하나(가장 상위)는 충격적으로 비효율적이었지만 언어는 사용 가능했습니다. 겨우 사용 가능했지만, 사용 가능했습니다.

소프트웨어를 여러 계층으로 작성하는 것은 애플리케이션 내에서도 강력한 기술입니다. 상향식 프로그래밍(bottom-up programming)은 프로그램을 일련의 계층으로 작성하는 것을 의미하며, 각 계층은 그 위에 있는 계층의 언어 역할을 합니다. 이 접근 방식은 더 작고 유연한 프로그램을 만드는 경향이 있습니다. 또한 재사용성(reusability)이라는 성배에 이르는 최상의 경로입니다. 언어는 정의상 재사용 가능합니다. 애플리케이션을 작성하는 언어로 더 많은 부분을 밀어넣을 수록, 더 많은 소프트웨어를 재사용할 수 있습니다.

왠지 모르게 재사용성이라는 아이디어가 1980년대에 객체 지향 프로그래밍(Object-Oriented Programming, OOP)과 연결되었고, 어떤 반대 증거도 그 연결을 끊을 수 없는 것 같습니다. 하지만 일부 객체 지향 소프트웨어는 재사용 가능하지만, 그것을 재사용 가능하게 만드는 것은 객체 지향성 때문이 아니라 상향식 특성 때문입니다. 라이브러리(library)를 생각해보십시오. 그것들은 객체 지향 스타일로 작성되었든 아니든 언어이기 때문에 재사용 가능합니다.

덧붙여서, 저는 객체 지향 프로그래밍의 종말을 예측하지 않습니다. 좋은 프로그래머에게는 특정 전문 분야 외에는 많은 것을 제공하지 못한다고 생각하지만, 대규모 조직에는 저항할 수 없는 매력이 있습니다. 객체 지향 프로그래밍은 스파게티 코드(spaghetti code)를 작성하는 지속 가능한 방법을 제공합니다. 일련의 패치(patch)로 프로그램을 축적할 수 있게 해줍니다. 대규모 조직은 항상 이런 식으로 소프트웨어를 개발하는 경향이 있으며, 오늘날과 마찬가지로 백 년 후에도 그럴 것이라고 예상합니다.

미래에 대해 이야기하는 김에 병렬 컴퓨팅(parallel computation)에 대해서도 이야기해야 합니다. 이 아이디어가 바로 그곳에 사는 것 같기 때문입니다. 즉, 언제 이야기하든 병렬 컴퓨팅은 미래에 일어날 일처럼 보입니다.

과연 미래는 그것을 따라잡을 수 있을까요? 사람들은 적어도 20년 동안 병렬 컴퓨팅을 임박한 것으로 이야기해왔지만, 아직까지 프로그래밍 관행에 큰 영향을 미치지 못했습니다. 혹은 그렇지 않을까요? 이미 칩 설계자들은 그것에 대해 생각해야 하고, 다중 CPU 컴퓨터에서 시스템 소프트웨어를 작성하려는 사람들도 마찬가지입니다. 진정한 질문은 병렬성이 추상화 계층의 어느 정도까지 올라갈 것인가입니다.

백 년 후에는 애플리케이션 프로그래머에게까지 영향을 미칠까요? 아니면 컴파일러 작성자들이 생각하는 것이지만, 애플리케이션의 소스 코드에서는 일반적으로 보이지 않는 것이 될까요?

한 가지 확실해 보이는 것은 병렬성의 대부분의 기회가 낭비될 것이라는 점입니다. 이것은 우리가 받게 될 추가 컴퓨터 성능의 대부분이 낭비될 것이라는 저의 더 일반적인 예측의 특별한 경우입니다. 저는 기본 하드웨어의 엄청난 속도와 마찬가지로, 병렬성은 명시적으로 요청하면 사용할 수 있지만, 일반적으로는 사용되지 않을 것이라고 예상합니다. 이것은 백 년 후에 우리가 갖게 될 병렬성의 종류는 특별한 애플리케이션을 제외하고는 대규모 병렬성(massive parallelism)이 아닐 것임을 의미합니다. 일반 프로그래머의 경우, 모든 프로세스가 병렬로 실행되는 프로세스를 포크(fork)할 수 있는 것과 더 비슷할 것이라고 예상합니다.

그리고 이것은 데이터 구조의 특정 구현을 요청하는 것과 마찬가지로, 프로그램을 최적화하려고 할 때 프로그램 수명 후반에 할 일이 될 것입니다. 버전 1은 일반적으로 병렬 컴퓨팅에서 얻을 수 있는 이점을 무시할 것입니다. 특정 데이터 표현에서 얻을 수 있는 이점을 무시하는 것과 마찬가지로 말입니다.

특정 종류의 애플리케이션을 제외하고는 병렬성이 백 년 후에 작성될 프로그램에 스며들지는 않을 것입니다. 만약 그렇게 된다면, 그것은 조기 최적화가 될 것입니다.

백 년 후에는 몇 개의 프로그래밍 언어가 있을까요? 최근에는 엄청나게 많은 새로운 프로그래밍 언어가 나타나고 있는 것 같습니다. 그 이유 중 하나는 더 빠른 하드웨어가 프로그래머가 애플리케이션에 따라 속도와 편의성 사이에서 다른 절충점을 만들 수 있도록 허용했기 때문입니다. 이것이 실제 추세라면, 백 년 후에 우리가 갖게 될 하드웨어는 그것을 더욱 증가시킬 것입니다.

하지만 백 년 후에는 널리 사용되는 언어가 몇 개밖에 없을 수도 있습니다. 제가 이렇게 말하는 이유 중 일부는 낙관론 때문입니다. 정말 잘 해낸다면, 느린 버전 1을 작성하는 데 이상적인 언어를 만들 수 있으면서도, 컴파일러에 올바른 최적화 조언을 제공하면 필요할 때 매우 빠른 코드를 생성할 수 있을 것 같습니다. 그래서 낙관적인 저는 허용 가능한 효율성과 최대 효율성 사이의 엄청난 격차에도 불구하고, 백 년 후의 프로그래머들은 그 격차의 대부분을 아우를 수 있는 언어를 갖게 될 것이라고 예측합니다.

이 격차가 넓어질수록 프로파일러(profiler)의 중요성은 더욱 커질 것입니다. 지금은 프로파일링에 거의 관심을 기울이지 않습니다. 많은 사람들이 여전히 빠른 애플리케이션을 얻는 방법은 빠른 코드를 생성하는 컴파일러를 작성하는 것이라고 믿는 것 같습니다. 허용 가능한 성능과 최대 성능 사이의 격차가 넓어질수록, 빠른 애플리케이션을 얻는 방법은 둘 사이를 잘 안내하는 것이라는 점이 점점 더 명확해질 것입니다.

언어가 몇 개밖에 없을 것이라고 말할 때, 저는 도메인 특정 "작은 언어"를 포함하지 않습니다. 저는 그런 내장 언어(embedded languages)가 훌륭한 아이디어라고 생각하며, 그것들이 확산될 것이라고 예상합니다. 하지만 사용자에게 기본 범용 언어(general-purpose language)가 보이도록 충분히 얇은 스킨(skin)으로 작성될 것이라고 예상합니다.

미래의 언어는 누가 설계할까요? 지난 10년 동안 가장 흥미로운 추세 중 하나는 펄(Perl), 파이썬(Python), 루비(Ruby)와 같은 오픈 소스(open-source) 언어의 부상이었습니다. 언어 설계는 해커들이 장악하고 있습니다. 지금까지의 결과는 지저분하지만, 고무적입니다. 예를 들어, 펄에는 놀라울 정도로 새로운 아이디어가 있습니다. 많은 것이 놀라울 정도로 나쁘지만, 야심 찬 노력은 항상 그렇습니다. 현재의 변이 속도로 볼 때, 백 년 후 펄이 무엇으로 진화할지는 아무도 모릅니다.

할 수 없는 사람이 가르친다는 것은 사실이 아닙니다 (제가 아는 최고의 해커 중 일부는 교수입니다). 하지만 가르치는 사람 중에는 할 수 없는 많은 것들이 있다는 것은 사실입니다. 연구는 제한적인 계급적 제약을 부과합니다. 어떤 학문 분야에서든 연구해도 괜찮은 주제와 그렇지 않은 주제가 있습니다. 불행히도 허용되는 주제와 금지된 주제의 구분은 일반적으로 연구 논문에 기술될 때 작업이 얼마나 지적으로 들리는지에 기반하며, 좋은 결과를 얻는 데 얼마나 중요한지는 아닙니다. 극단적인 경우는 아마 문학일 것입니다. 문학을 연구하는 사람들은 문학을 생산하는 사람들에게 조금이라도 유용할 만한 것을 거의 말하지 않습니다.

과학 분야에서는 상황이 더 좋지만, 허용되는 작업의 종류와 좋은 언어를 산출하는 작업의 종류 사이의 중복은 놀랍도록 작습니다. (올린 시버스(Olin Shivers)는 이에 대해 유창하게 불평했습니다.) 예를 들어, 타입(type)은 정적 타이핑(static typing)이 진정한 매크로(macro)를 배제하는 것처럼 보임에도 불구하고 무궁무진한 연구 논문의 원천인 것 같습니다. 제 생각에는 매크로가 없으면 어떤 언어도 사용할 가치가 없습니다.

추세는 언어가 "연구"가 아닌 오픈 소스 프로젝트로 개발되는 것뿐만 아니라, 컴파일러 작성자가 아닌 언어를 사용해야 하는 애플리케이션 프로그래머에 의해 설계되는 방향으로 나아가고 있습니다. 이것은 좋은 추세이며 계속될 것이라고 예상합니다.

백 년 후의 물리학은 거의 필연적으로 예측 불가능하지만, 원칙적으로 지금 백 년 후의 사용자들에게 어필할 만한 언어를 설계하는 것이 가능하다고 생각합니다.

언어를 설계하는 한 가지 방법은 컴파일러가 번역할 수 있는지, 하드웨어가 실행할 수 있는지와 상관없이 작성하고 싶은 프로그램을 그냥 적어보는 것입니다. 이렇게 할 때 무한한 자원을 가정할 수 있습니다. 백 년 후와 마찬가지로 오늘날에도 무한한 자원을 상상할 수 있어야 할 것 같습니다.

어떤 프로그램을 쓰고 싶을까요? 가장 적은 노력이 드는 것입니다. 그렇지만 완전히 그런 것은 아닙니다. 프로그래밍에 대한 당신의 생각이 이미 익숙한 언어의 영향을 받지 않았다면 가장 적은 노력이 들었을 것입니다. 그런 영향은 너무나 광범위해서 그것을 극복하는 데는 엄청난 노력이 필요합니다. 우리처럼 게으른 존재들이 프로그램을 가장 적은 노력으로 표현하는 방법을 아는 것은 당연하다고 생각할 것입니다. 사실, 우리가 생각하는 것이 무엇이든 간에 우리의 가능성에 대한 생각은 너무나 제한적이어서, 더 쉬운 프로그램 공식화는 매우 놀랍게 느껴집니다. 그것들은 당신이 발견해야 할 것이지, 자연스럽게 빠져들 수 있는 것이 아닙니다.

여기서 유용한 한 가지 방법은 프로그램의 길이를 작성하는 데 드는 노력의 근사치로 사용하는 것입니다. 물론 문자 수가 아니라, 고유한 구문 요소의 길이, 기본적으로 구문 트리(parse tree)의 크기입니다. 가장 짧은 프로그램이 작성하는 데 가장 적은 노력이 드는 것은 아닐지라도, 가장 적은 노력이라는 모호한 목표보다 간결성이라는 확실한 목표를 지향하는 것이 더 나을 정도로 가깝습니다.

그렇다면 언어 설계 알고리즘은 다음과 같습니다. 프로그램을 보고, 이것을 더 짧게 작성할 방법이 있을까? 라고 묻는 것입니다.

실제로 상상의 백 년 후 언어로 프로그램을 작성하는 것은 핵심에 얼마나 가까운지에 따라 다양한 정도로 작동할 것입니다. 정렬 루틴은 지금도 작성할 수 있습니다. 하지만 백 년 후에 어떤 종류의 라이브러리가 필요할지 지금 예측하기는 어려울 것입니다. 아마도 많은 라이브러리는 아직 존재하지 않는 도메인을 위한 것일 것입니다. 예를 들어, SETI@home이 작동한다면, 외계인과 통신하기 위한 라이브러리가 필요할 것입니다. 물론 외계인이 충분히 발전하여 이미 XML로 통신하고 있지 않다면 말입니다.

다른 극단에서는 오늘날 핵심 언어를 설계할 수 있다고 생각합니다. 사실, 어떤 사람들은 그것이 1958년에 이미 거의 설계되었다고 주장할 수도 있습니다.

백 년 후의 언어가 오늘날 사용 가능했다면, 우리는 그것으로 프로그래밍하고 싶을까요? 이 질문에 답하는 한 가지 방법은 과거를 돌아보는 것입니다. 현대 프로그래밍 언어가 1960년에 사용 가능했다면, 누군가가 그것을 사용하고 싶어 했을까요?

어떤 면에서는 아니오입니다. 오늘날의 언어는 1960년에는 존재하지 않았던 인프라를 가정합니다. 예를 들어, 파이썬처럼 들여쓰기(indentation)가 중요한 언어는 프린터 터미널(printer terminals)에서는 잘 작동하지 않았을 것입니다. 하지만 그런 문제를 제쳐두고, 예를 들어 프로그램이 모두 종이에 작성되었다고 가정했을 때, 1960년대의 프로그래머들은 우리가 지금 사용하는 언어로 프로그램을 작성하는 것을 좋아했을까요?

저는 그렇다고 생각합니다.

초기 언어의 특징이 프로그램에 대한 아이디어에 내재되어 있던 상상력이 부족한 일부 사람들은 어려움을 겪었을 것입니다. (포인터 산술 없이 데이터를 어떻게 조작할 수 있지? `goto` 없이 플로우차트(flow chart)를 어떻게 구현할 수 있지?) 하지만 저는 가장 똑똑한 프로그래머들은 현대 언어를 최대한 활용하는 데 아무런 문제가 없었을 것이라고 생각합니다. 만약 그들이 그것들을 가지고 있었다면 말입니다.

만약 우리가 지금 백 년 후의 언어를 가지고 있다면, 적어도 훌륭한 의사 코드(pseudocode)가 될 것입니다. 소프트웨어를 작성하는 데 사용하는 것은 어떨까요? 백 년 후의 언어는 일부 애플리케이션을 위해 빠른 코드를 생성해야 할 것이므로, 아마도 우리 하드웨어에서 충분히 잘 실행될 수 있을 만큼 효율적인 코드를 생성할 수 있을 것입니다. 백 년 후의 사용자들보다 더 많은 최적화 조언을 주어야 할 수도 있지만, 여전히 순이익이 될 수 있습니다.

이제 우리는 두 가지 아이디어를 가지고 있는데, 그것들을 결합하면 흥미로운 가능성을 제시합니다. (1) 백 년 후의 언어는 원칙적으로 오늘날 설계될 수 있고, (2) 그런 언어가 존재한다면 오늘날 프로그래밍하기 좋을 수 있다는 것입니다. 이런 아이디어들을 이렇게 늘어놓으면, '지금 백 년 후의 언어를 작성해보는 것은 어떨까?'라고 생각하지 않기 어렵습니다.

언어 설계를 할 때, 그런 목표를 가지고 의식적으로 염두에 두는 것이 좋다고 생각합니다. 운전을 배울 때 가르치는 원칙 중 하나는 차를 도로에 그려진 줄에 맞춰서 정렬하는 것이 아니라, 멀리 있는 어떤 지점을 목표로 삼아 정렬하는 것입니다. 당장 10피트 이내에서 일어나는 일에만 신경 쓴다 해도, 이것이 올바른 답입니다. 저는 우리가 프로그래밍 언어도 마찬가지로 할 수 있고, 또 그래야 한다고 생각합니다.

**참고**

Lisp Machine Lisp은 선언(동적 변수(dynamic variable) 선언 제외)이 단순히 최적화 조언일 뿐 올바른 프로그램의 의미를 변경하지 않는다는 원칙을 구현한 최초의 언어라고 생각합니다. [1] Common Lisp은 이것을 명시적으로 언급한 최초의 언어인 것 같습니다. [2]

**감사**

이 글의 초안을 읽어준 트레버 블랙웰(Trevor Blackwell), 로버트 모리스(Robert Morris), 댄 기핀(Dan Giffin)에게 감사드립니다. 그리고 PyCon에서 연설할 기회를 준 귀도 반 로섬(Guido van Rossum), 제레미 힐튼(Jeremy Hylton), 그리고 다른 파이썬 팀에게도 감사드립니다.

[1] 저는 Lisp Machine Lisp에서 어떤 선언이 (동적 변수에 대한 선언을 제외하고) 단지 최적화 조언일 뿐이고 올바른 프로그램의 의미를 변경하지 않을 것이라는 원칙을 구현한 최초의 언어였다고 생각합니다.
[2] Common Lisp은 이것을 명시적으로 언급한 최초의 언어인 것 같습니다.