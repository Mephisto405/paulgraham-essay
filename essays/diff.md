# Lisp는 무엇이 다른가? (What Made Lisp Different)

2001년 12월 (개정 2002년 5월)

이 글은 LL1 메일링 리스트에 올라온 몇몇 질문에 대한 답변으로 작성되었으며, 현재 'Revenge of the Nerds'에 통합되었습니다.[^1]

맥카시(McCarthy)가 1950년대 후반 리스프(Lisp)를 설계했을 당시, 이는 당시 가장 중요했던 포트란(Fortran)과는 근본적으로 다른 출발점이었습니다.

리스프는 아홉 가지 새로운 아이디어를 구현했습니다:

1.  **조건문 (Conditionals).**
    조건문은 if-then-else 구문입니다. 우리는 이것을 당연하게 받아들이지만, 이는 맥카시가 리스프 개발 과정에서 발명한 것입니다. (당시 포트란은 기반 하드웨어의 분기 명령(branch instruction)에 기반한 조건부 goto 구문만 가지고 있었습니다.) 알골(Algol) 위원회에 참여했던 맥카시는 조건문을 알골에 도입했고, 이는 다른 대부분의 언어로 퍼져나갔습니다.

2.  **함수 타입 (A function type).**
    리스프에서 함수는 일급 객체(first-class objects)입니다. 즉, 정수나 문자열 등과 같은 데이터 타입이며, 리터럴 표현(literal representation)을 가지고 변수에 저장할 수 있고, 인수로 전달하는 등 다양한 작업이 가능합니다.

3.  **재귀 (Recursion).**
    물론 재귀는 리스프 이전에 이미 수학적 개념으로 존재했지만, 리스프는 이를 지원한 최초의 프로그래밍 언어였습니다. (이는 함수가 일급 객체라는 개념에 내포되어 있다고도 볼 수 있습니다.)

4.  **변수에 대한 새로운 개념 (A new concept of variables).**
    리스프에서는 모든 변수가 사실상 포인터(pointers)처럼 작동합니다. 타입이 있는 것은 변수가 아니라 값이며, 변수에 값을 할당하거나 바인딩(binding)하는 것은 변수가 가리키는 대상이 아닌, 포인터를 복사하는 것을 의미합니다.

5.  **가비지 컬렉션 (Garbage-collection).**

6.  **표현식으로 구성된 프로그램 (Programs composed of expressions).**
    리스프 프로그램은 각각 값을 반환하는 표현식(expressions)들의 트리 구조입니다. (일부 리스프 구현에서는 표현식이 여러 값을 반환할 수도 있습니다.) 이는 표현식과 문장(statements)을 구분하는 포트란 및 그 후속 언어들과 대조됩니다.
    포트란에서는 이러한 구분이 자연스러웠는데, (천공 카드(punched cards)가 입력 형식이었던 언어라는 점을 감안하면 놀랍지 않게도) 언어가 줄 단위 지향적(line-oriented)이었기 때문입니다. 문장을 중첩할 수 없었습니다. 수학 연산을 위해서는 표현식이 필요했지만, 다른 어떤 것도 값을 반환하게 할 필요는 없었습니다. 왜냐하면 그 값을 기다릴 대상이 있을 수 없었기 때문입니다.
    이러한 한계는 블록 구조 언어(block-structured languages)의 등장과 함께 사라졌지만, 때는 이미 늦었습니다. 표현식과 문장의 구분은 굳어져 버렸습니다. 이 구분은 포트란에서 알골로 퍼져나갔고, 그 후손 격인 다른 언어들로 이어졌습니다.
    언어가 온전히 표현식으로 이루어져 있다면, 원하는 방식으로 표현식을 조합할 수 있습니다. 아크(Arc) 구문을 사용하면 다음과 같이 쓸 수 있습니다.
    `(if foo (= x 1) (= x 2))`
    또는
    `(= x (if foo 1 2))`

7.  **심볼 타입 (A symbol type).**
    심볼(Symbols)은 포인터 비교를 통해 등가성(equality)을 테스트할 수 있다는 점에서 문자열과 다릅니다.

8.  **심볼 트리로 이루어진 코드 표기법 (A notation for code using trees of symbols).**

9.  **언제나 사용 가능한 전체 언어 (The whole language always available).**
    읽기 시점(read-time), 컴파일 시점(compile-time), 런타임(runtime) 사이에는 실질적인 구분이 없습니다. 코드를 읽으면서 컴파일하거나 실행할 수 있고, 코드를 읽거나 실행하면서 컴파일할 수도 있으며, 런타임에 코드를 읽거나 컴파일할 수도 있습니다.
    읽기 시점에 코드를 실행하면 사용자는 리스프의 구문(syntax)을 재정의할 수 있습니다. 컴파일 시점의 코드는 매크로(macros)의 기반이 됩니다. 런타임 컴파일은 Emacs와 같은 프로그램에서 리스프가 확장 언어(extension language)로 사용되는 기반이며, 런타임 읽기는 프로그램 간에 s-표현식(s-expressions)을 사용하여 통신할 수 있게 합니다. 이는 최근 XML이라는 이름으로 재발명된 아이디어입니다.

리스프가 처음 발명되었을 당시, 이 모든 아이디어는 1950년대 후반의 가용 하드웨어(hardware)에 의해 크게 좌우되던 일반적인 프로그래밍 관행과는 거리가 멀었습니다.
시간이 흐르면서, 인기 있는 언어들의 연이은 등장으로 구현된 기본 언어는 점진적으로 리스프를 향해 진화해 왔습니다. 1번에서 5번 아이디어는 이제 널리 퍼졌습니다. 6번 아이디어는 나타나기 시작했습니다.
파이썬(Python)은 7번 아이디어의 한 형태를 가지고 있지만, 이를 위한 문법은 없어 보입니다. 8번 아이디어는 (9번 아이디어와 함께) 리스프 매크로를 가능하게 하는 것인데, 이는 아직까지 리스프 고유의 특징입니다. 아마도 (a) 괄호가 필요하거나 그와 비슷한 불편함이 있기 때문일 것이고, (b) 만약 그 마지막 단계의 힘을 더한다면, 더 이상 새로운 언어를 발명했다고 주장할 수 없고 단지 리스프의 새로운 방언(dialect)을 설계했다고만 말할 수 있기 때문일 것입니다 ;-)

현대의 프로그래머에게 유용함에도 불구하고, 리스프를 다른 언어들이 채택한 임의의 편법(random expedients)과의 변형이라는 관점에서 설명하는 것은 이상합니다. 맥카시가 그것을 그렇게 생각했을 가능성은 낮습니다. 리스프는 포트란의 실수를 수정하기 위해 설계된 것이 아니라, 계산을 공리화(axiomatize computation)하려는 시도의 부산물로 탄생했습니다.

[^1]: 이 글은 LL1 메일링 리스트에 올라온 몇몇 질문에 대한 답변으로 작성되었으며, 현재 'Revenge of the Nerds'에 통합되었습니다.