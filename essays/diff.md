# 왓 메이드 리스프 디퍼런트 (What Made Lisp Different)

2001년 12월 (2002년 5월 개정)

(이 글은 LL1 메일링 리스트의 질문에 대한 답변으로 작성되었습니다. 현재는 '너드들의 복수 (Revenge of the Nerds)'에 포함되어 있습니다.)

매카시가 1950년대 후반에 리스프(Lisp)를 설계했을 때, 리스프는 당시 존재하던 언어들, 그 중 가장 중요했던 포트란(Fortran)과는 급진적으로 달랐습니다.

리스프에는 아홉 가지 새로운 아이디어가 담겨 있습니다.

1.  **조건문 (Conditionals)**

    조건문은 `if-then-else` 구조입니다. 우리는 지금 이것을 당연하게 여깁니다. 이것은 매카시가 리스프를 개발하는 과정에서 발명되었습니다. (당시 포트란에는 기본 하드웨어의 분기 명령에 기반한 조건부 `goto`만 있었습니다.) 알고(Algol) 위원회에 참여했던 매카시는 조건문을 알고에 포함시켰고, 거기서부터 대부분의 다른 언어로 확산되었습니다.

2.  **함수형 (A function type)**

    리스프에서 함수는 일급 객체(first class objects)입니다. 즉, 정수, 문자열 등과 같은 데이터 타입이며, 리터럴(literal) 표현을 가지고 변수에 저장될 수 있고, 인수로 전달될 수 있는 등입니다.

3.  **재귀 (Recursion)**

    재귀는 물론 리스프 이전에 수학적 개념으로 존재했지만, 리스프는 이를 지원하는 최초의 프로그래밍 언어였습니다. (함수를 일급 객체로 만드는 것에 암묵적으로 포함되어 있다고 볼 수도 있습니다.)

4.  **변수의 새로운 개념 (A new concept of variables)**

    리스프에서 모든 변수는 사실상 포인터(pointer)입니다. 타입(type)을 갖는 것은 변수가 아니라 값이며, 변수를 할당하거나 바인딩하는 것은 포인터를 복사하는 것을 의미하고, 포인터가 가리키는 것을 복사하는 것이 아닙니다.

5.  **가비지 컬렉션 (Garbage-collection)**

6.  **표현식으로 구성된 프로그램 (Programs composed of expressions)**

    리스프 프로그램은 표현식(expression)으로 구성된 트리(tree)이며, 각 표현식은 값을 반환합니다. (일부 리스프에서는 표현식이 여러 값을 반환할 수 있습니다.) 이는 포트란 및 대부분의 후속 언어들이 표현식과 문장(statement)을 구별하는 것과는 대조적입니다.

    포트란에서 이러한 구별이 있었던 것은 자연스러운 일이었습니다. 왜냐하면 (펀치 카드 입력 형식을 사용했던 언어에서 놀랄 일도 아니지만) 언어가 라인(line) 지향적이었기 때문입니다. 문장을 중첩할 수 없었습니다. 그래서 수학 연산을 위해 표현식이 필요했지만, 다른 어떤 것이라도 값을 반환하도록 만들 필요가 없었습니다. 왜냐하면 그 값을 기다리는 것이 있을 수 없었기 때문입니다.

    블록 구조 언어(block-structured languages)가 등장하면서 이러한 제약은 사라졌지만, 그때는 이미 너무 늦었습니다. 표현식과 문장의 구별은 굳건히 자리 잡았습니다. 이는 포트란에서 알고로, 그리고 그들의 후손들에게까지 퍼졌습니다.

    언어가 전적으로 표현식으로만 구성되면, 원하는 방식으로 표현식을 조합할 수 있습니다. 예를 들어, (Arc 문법을 사용하여) 다음과 같이 표현할 수 있습니다.

    `(if foo (= x 1) (= x 2))`

    또는

    `(= x (if foo 1 2))`

7.  **심볼 타입 (A symbol type)**

    심볼은 포인터를 비교하여 동등성을 테스트할 수 있다는 점에서 문자열과 다릅니다.

8.  **심볼 트리(trees of symbols)를 이용한 코드 표기법 (A notation for code using trees of symbols)**

9.  **항상 사용 가능한 전체 언어 (The whole language always available)**

    읽기 시간(read-time), 컴파일 시간(compile-time), 런타임(runtime) 사이에 진정한 구별이 없습니다. 읽는 동안 코드를 컴파일하거나 실행할 수 있고, 컴파일하는 동안 코드를 읽거나 실행할 수 있으며, 런타임에 코드를 읽거나 컴파일할 수 있습니다.

    읽기 시간에 코드를 실행하면 사용자가 리스프의 문법을 재프로그래밍할 수 있습니다. 컴파일 시간에 코드를 실행하는 것은 매크로(macros)의 기반입니다. 런타임에 컴파일하는 것은 이맥스(Emacs)와 같은 프로그램에서 리스프가 확장 언어(extension language)로 사용되는 기반입니다. 그리고 런타임에 읽는 것은 프로그램이 S-표현식(s-expressions)을 사용하여 통신할 수 있게 하는데, 이는 최근 XML로 다시 발명된 아이디어입니다.

리스프가 처음 발명되었을 때, 이 모든 아이디어는 1950년대 후반에 사용 가능한 하드웨어에 의해 주로 결정되었던 일반적인 프로그래밍 관행과는 거리가 멀었습니다.

시간이 지남에 따라, 일련의 인기 있는 언어들에 구현된 기본 언어들은 점진적으로 리스프를 향해 진화해 왔습니다. 1번부터 5번까지는 이제 널리 퍼져 있습니다. 6번은 주류 언어에서 나타나기 시작하고 있습니다. 파이썬(Python)은 7번의 한 형태를 가지고 있지만, 이에 대한 문법은 없는 것 같습니다. 8번은 (9번과 함께) 리스프 매크로를 가능하게 하는 것인데, 지금까지는 여전히 리스프에만 고유합니다. 아마도 (a) 괄호나 그만큼 나쁜 것이 필요하기 때문이거나, (b) 그 마지막 단계의 힘을 추가하면 더 이상 새로운 언어를 발명했다고 주장할 수 없고 단지 리스프의 새로운 방언을 설계했다고 주장할 수밖에 없기 때문일 것입니다. ;-)

현재의 프로그래머들에게는 유용하겠지만, 리스프를 다른 언어들이 채택한 무작위적인 편의(expedients)와의 차이점으로 설명하는 것은 이상합니다. 매카시는 아마 그렇게 생각하지 않았을 것입니다. 리스프는 포트란의 실수를 고치기 위해 설계된 것이 아니라, 계산을 공리화하려는(axiomatize computation) 시도의 부산물로 탄생한 것이 더 가깝습니다.