# 또 다른 비전 (The Other Road Ahead)

2001년 9월

(이 글은 차세대 소프트웨어의 상당 부분이 왜 서버 기반이 될 수 있는지, 그것이 프로그래머에게 무엇을 의미하는지, 그리고 왜 이러한 새로운 종류의 소프트웨어가 스타트업에게 큰 기회가 되는지를 설명합니다. 이 내용은 BBN 랩스에서의 강연을 바탕으로 작성되었습니다.)

1995년 여름, 제 친구 로버트 모리스와 저는 스타트업을 시작하기로 결정했습니다. 당시 넷스케이프(Netscape)의 IPO를 앞두고 대대적인 홍보 캠페인이 진행 중이었고, 언론에서는 온라인 상거래에 대한 이야기가 많았습니다. 그 당시 웹에는 손으로 직접 만든 상점이 30개 정도 있었을 것입니다. 온라인 상점이 많아지려면 그것을 만들 소프트웨어가 필요할 것이라고 생각했고, 그래서 우리는 그 소프트웨어를 만들기로 했습니다.

처음 일주일 정도는 이것을 일반적인 데스크톱 애플리케이션으로 만들 생각이었습니다. 그러던 어느 날, 소프트웨어를 웹 서버에서 실행하고 브라우저를 인터페이스로 사용하는 아이디어를 떠올렸습니다. 우리는 소프트웨어를 웹에서 작동하도록 다시 작성해 보았고, 이것이 올바른 방향이라는 것이 명확해졌습니다. 소프트웨어를 서버에서 실행하도록 만들면 사용자뿐만 아니라 우리에게도 훨씬 더 쉬울 것이었습니다.

이것은 좋은 계획으로 판명되었습니다. 현재 야후 스토어(Yahoo Store)라는 이름으로 이 소프트웨어는 약 14,000명의 사용자를 보유한 가장 인기 있는 온라인 스토어 빌더입니다.

우리가 비아웹(Viaweb)을 시작했을 때, 소프트웨어가 서버에서 실행된다고 말하면 거의 아무도 우리가 무슨 뜻인지 이해하지 못했습니다. 1년 후 핫메일(Hotmail)이 출시되고 나서야 사람들은 이 개념을 이해하기 시작했습니다. 이제는 모두가 이것이 유효한 접근 방식이라는 것을 알고 있습니다. 우리가 그때 불렸던 이름은 애플리케이션 서비스 제공업체(Application Service Provider, ASP)였습니다.

저는 차세대 소프트웨어의 상당 부분이 이러한 모델로 작성될 것이라고 생각합니다. 가장 많은 것을 잃을 마이크로소프트(Microsoft)조차도 일부 기능을 데스크톱에서 서버로 옮기는 것이 불가피하다는 것을 깨닫고 있는 것 같습니다. 소프트웨어가 데스크톱에서 서버로 옮겨진다면, 개발자들에게는 매우 다른 세상이 될 것입니다. 이 글은 우리가 이 새로운 세상의 첫 방문객 중 일부로서 보았던 놀라운 것들을 설명합니다. 소프트웨어가 서버로 이동하는 한, 제가 여기서 설명하는 것은 미래입니다.

## 다음 단계는 무엇일까? (The Next Thing?)

데스크톱 소프트웨어 시대를 되돌아보면, 초기 자동차 소유자들이 겪었던 불편함에 놀라는 것처럼, 사람들이 감수했던 불편함에 놀라게 될 것이라고 생각합니다. 처음 20년에서 30년 동안은 자동차를 소유하려면 자동차 전문가여야 했습니다. 하지만 자동차는 너무나 큰 이점을 주었기 때문에 자동차 전문가가 아닌 많은 사람들도 자동차를 갖고 싶어 했습니다.

컴퓨터는 지금 이 단계에 있습니다. 데스크톱 컴퓨터를 소유하면, 그 안에 무엇이 일어나고 있는지 원치 않는 많은 것을 배우게 됩니다. 하지만 미국 가정의 절반 이상이 컴퓨터를 소유하고 있습니다. 저희 어머니는 이메일과 회계 장부 정리를 위해 컴퓨터를 사용하십니다. 약 1년 전, 애플(Apple)로부터 새 버전의 운영체제(operating system) 할인 혜택을 제공하는 편지를 받고 놀라셨습니다. 65세 여성이 이메일과 회계 장부 정리를 위해 컴퓨터를 사용하는데 새 운영체제를 설치하는 것을 고민해야 한다면, 뭔가 잘못된 것입니다. 일반 사용자는 "운영체제"라는 단어조차 몰라야 하며, "장치 드라이버(device driver)"나 "패치(patch)"는 더더욱 몰라야 합니다.

이제 사용자들을 시스템 관리자(system administrator)가 되는 수고를 덜어줄 수 있는 또 다른 소프트웨어 제공 방식이 있습니다. 웹 기반 애플리케이션(Web-based applications)은 웹 서버에서 실행되고 웹 페이지를 사용자 인터페이스(user interface)로 사용하는 프로그램입니다. 일반 사용자에게 이러한 새로운 종류의 소프트웨어는 데스크톱 소프트웨어보다 더 쉽고, 저렴하며, 더 휴대성이 좋고(mobile), 더 안정적이며, 종종 더 강력할 것입니다.

웹 기반 소프트웨어를 사용하면 대부분의 사용자는 자신이 사용하는 애플리케이션 외에는 아무것도 생각할 필요가 없습니다. 모든 지저분하고 변화하는 것들은 어딘가에 있는 서버에 앉아, 그러한 일에 능숙한 사람들이 관리할 것입니다. 따라서 소프트웨어를 사용하기 위해 컴퓨터 자체(per se)가 보통 필요하지 않을 것입니다. 키보드, 화면, 웹 브라우저가 있는 것만 있으면 됩니다. 아마도 무선 인터넷 접속이 될 수도 있고, 휴대폰이 될 수도 있을 것입니다. 무엇이든 간에, 그것은 가전제품이 될 것입니다. 약 200달러 정도의 비용이 들고, 사람들은 주로 케이스의 외관을 보고 선택할 것입니다. 지금 휴대폰처럼 하드웨어보다 인터넷 서비스에 더 많은 비용을 지불하게 될 것입니다.[1]

서버에 클릭이 도달하고 다시 돌아오는 데 약 0.1초가 걸릴 것이므로, 포토샵(Photoshop)과 같이 상호작용이 많은 소프트웨어 사용자는 여전히 데스크톱에서 연산을 수행하기를 원할 것입니다. 하지만 대부분의 사람들이 컴퓨터를 사용하는 종류의 작업을 보면, 0.1초의 지연(latency)은 문제가 되지 않을 것입니다. 저희 어머니는 사실 데스크톱 컴퓨터가 필요 없고, 어머니와 같은 사람들이 많습니다.

## 사용자들을 위한 이점 (The Win for Users)

저희 집 근처에 "불편함보다는 죽음(death before inconvenience)"이라고 쓰인 범퍼 스티커가 붙은 자동차가 있습니다. 대부분의 사람들은 대부분의 경우 가장 적은 노력이 필요한 선택을 할 것입니다. 웹 기반 소프트웨어가 승리한다면, 그것은 더 편리하기 때문일 것입니다. 그리고 사용자뿐만 아니라 개발자에게도 그렇게 될 것으로 보입니다.

순수 웹 기반 애플리케이션을 사용하려면, 인터넷에 연결된 브라우저만 있으면 됩니다. 따라서 웹 기반 애플리케이션은 어디서든 사용할 수 있습니다. 데스크톱 컴퓨터에 소프트웨어를 설치하면, 그 컴퓨터에서만 사용할 수 있습니다. 더 나쁜 것은 파일이 그 컴퓨터에 갇혀 있다는 것입니다. 사람들이 네트워크에 익숙해질수록 이 모델의 불편함은 점점 더 명확해집니다.

이러한 변화의 시작은 웹 기반 이메일이었습니다. 수백만 명의 사람들이 이제 어디에 있든 이메일 메시지에 액세스할 수 있어야 한다는 것을 깨닫고 있습니다. 그리고 이메일을 볼 수 있다면, 캘린더는 왜 안 될까요? 동료들과 문서를 논의할 수 있다면, 왜 편집할 수 없을까요? 왜 여러분의 데이터가 멀리 떨어진 책상에 놓인 어떤 컴퓨터에 갇혀 있어야 할까요?

"나의 컴퓨터"라는 개념 자체가 사라지고, "나의 데이터"로 대체되고 있습니다. 어떤 컴퓨터에서든 자신의 데이터에 접근할 수 있어야 합니다. 아니, 오히려 어떤 클라이언트에서든 접근할 수 있어야 하며, 클라이언트가 반드시 컴퓨터일 필요는 없습니다.

클라이언트는 데이터를 저장해서는 안 됩니다. 전화기처럼 되어야 합니다. 사실 클라이언트는 전화기가 될 수도 있고, 그 반대도 될 수 있습니다. 그리고 클라이언트가 작아질수록 데이터를 클라이언트에 보관하지 않을 또 다른 이유가 생깁니다. 휴대하고 다니는 것은 분실되거나 도난당할 수 있습니다. PDA를 택시에 두고 내리는 것은 디스크 고장과 같지만, 데이터가 증발하는 대신 다른 사람에게 넘겨진다는 점이 다릅니다.

순수 웹 기반 소프트웨어는 데이터나 애플리케이션 모두 클라이언트에 보관되지 않습니다. 따라서 사용하기 위해 아무것도 설치할 필요가 없습니다. 설치할 필요가 없으면 설치가 잘못될까 봐 걱정할 필요도 없습니다. 애플리케이션과 운영체제 사이에 비호환성(incompatibilities)이 있을 수 없습니다. 소프트웨어가 운영체제에서 실행되지 않기 때문입니다.

설치가 필요 없으므로 웹 기반 소프트웨어는 "구매"하기 전에 시도해 보기가 쉽고 흔해질 것입니다. 웹 기반 애플리케이션은 제공되는 사이트에 접속하기만 하면 무료로 시험 사용(test-drive)할 수 있을 것으로 예상해야 합니다. 비아웹에서는 전체 사이트가 사용자들을 시험 사용으로 안내하는 거대한 화살표와 같았습니다.

데모를 사용해 본 후, 서비스 가입은 간단한 양식(간단할수록 좋습니다)만 작성하면 됩니다. 그리고 그것이 사용자가 해야 할 마지막 작업이어야 합니다. 웹 기반 소프트웨어는 추가 비용을 지불하거나, 어떤 작업도 하지 않거나, 심지어 알지 못하는 사이에 새로운 릴리즈를 받을 수 있어야 합니다.

업그레이드(upgrade)는 지금처럼 큰 충격이 아닐 것입니다. 시간이 지남에 따라 애플리케이션은 조용히 더 강력해질 것입니다. 이는 개발자들의 노력이 필요할 것입니다. 사용자들을 혼란시키지 않고 소프트웨어를 업데이트할 수 있도록 설계해야 할 것입니다. 그것은 새로운 문제이지만, 해결 방법은 있습니다.

웹 기반 애플리케이션에서는 모든 사람이 동일한 버전을 사용하며, 버그(bug)는 발견되는 즉시 수정될 수 있습니다. 따라서 웹 기반 소프트웨어는 데스크톱 소프트웨어보다 훨씬 적은 버그를 가져야 합니다. 비아웹에서는 우리가 동시에 알려진 버그가 10개를 넘은 적이 있었는지 의심스럽습니다. 이는 데스크톱 소프트웨어보다 훨씬 나은 수준입니다.

웹 기반 애플리케이션은 여러 사람이 동시에 사용할 수 있습니다. 이는 협업 애플리케이션(collaborative applications)에 명백한 이점이지만, 사용자들이 가능하다는 것을 깨닫고 나면 대부분의 애플리케이션에서 이를 원하기 시작할 것이라고 생각합니다. 예를 들어, 두 사람이 같은 문서를 편집할 수 있도록 하는 것이 종종 유용할 것입니다. 비아웹은 여러 사용자가 동시에 사이트를 편집할 수 있도록 했는데, 이는 사용자들이 원할 것이라고 예상해서라기보다는 소프트웨어를 올바르게 작성하는 방법이었기 때문이었지만, 많은 사용자들이 실제로 이를 원했습니다.

웹 기반 애플리케이션을 사용하면 데이터가 더 안전할 것입니다. 디스크 고장(Disk crashes)은 과거의 일이 아닐 것이지만, 사용자들은 더 이상 그것에 대해 듣지 못할 것입니다. 그것은 서버 팜(server farm) 내에서 발생할 것입니다. 그리고 웹 기반 애플리케이션을 제공하는 회사들은 실제로 백업(backup)을 수행할 것입니다. 실제 시스템 관리자들이 그러한 일들을 걱정할 것이기 때문일 뿐만 아니라, 사용자들의 데이터를 잃어버리는 ASP는 매우 큰 문제에 직면할 것이기 때문입니다. 사람들이 디스크 고장으로 자신의 데이터를 잃어버릴 때, 그들은 자신에게만 화를 낼 수 있기 때문에 그다지 화를 내지 못합니다. 회사가 그들을 위해 데이터를 잃어버리면, 그들은 훨씬 더 화를 낼 것입니다.

마지막으로, 웹 기반 소프트웨어는 바이러스(virus)에 덜 취약해야 합니다. 클라이언트가 브라우저 외에는 아무것도 실행하지 않는다면, 바이러스가 실행될 가능성이 적고, 로컬에 손상될 데이터도 없습니다. 그리고 서버 자체를 공격하는 프로그램은 서버가 매우 잘 방어되어 있음을 알게 될 것입니다.[2]

사용자들에게 웹 기반 소프트웨어는 스트레스가 덜할 것입니다. 평균적인 윈도우(Windows) 사용자의 내면을 들여다보면, 그러한 설명을 만족시키는 소프트웨어에 대한 엄청나고 거의 손대지 않은 욕구가 있을 것이라고 생각합니다. 그것이 풀려난다면 강력한 힘이 될 수 있습니다.

## 코드의 도시 (City of Code)

개발자들에게 웹 기반 소프트웨어와 데스크톱 소프트웨어의 가장 눈에 띄는 차이점은 웹 기반 애플리케이션이 단일 코드 조각이 아니라는 것입니다. 그것은 단일하고 큰 바이너리(binary)가 아니라, 다양한 유형의 프로그램들의 모음이 될 것입니다. 따라서 웹 기반 소프트웨어를 설계하는 것은 건물을 설계하는 것보다 도시를 설계하는 것과 같습니다. 건물뿐만 아니라 도로, 도로 표지판, 공공시설, 경찰 및 소방서, 그리고 성장과 다양한 종류의 재난에 대한 계획이 필요합니다.

비아웹에서 소프트웨어는 사용자와 직접 대화하는 상당히 큰 애플리케이션, 그러한 애플리케이션이 사용하는 프로그램, 백그라운드에서 끊임없이 문제를 찾는 프로그램, 문제가 발생하면 다시 시작하려는 프로그램, 통계를 컴파일하거나 검색을 위한 인덱스를 구축하기 위해 가끔 실행되는 프로그램, 자원을 가비지 컬렉션(garbage-collect)하거나 데이터를 이동 또는 복원하기 위해 명시적으로 실행하는 프로그램, 사용자 행세를 하는 프로그램(성능을 측정하거나 버그를 노출하기 위해), 네트워크 문제 진단 프로그램, 백업 프로그램, 외부 서비스 인터페이스, 실시간 서버 통계를 표시하는 인상적인 다이얼 컬렉션을 구동하는 소프트웨어(방문객에게 인기가 있었지만 우리에게도 필수적이었음), 오픈 소스 소프트웨어(open-source software)에 대한 수정 사항(버그 수정 포함), 그리고 수많은 구성 파일 및 설정으로 구성되었습니다. 야후(Yahoo)에 인수된 후 트레버 블랙웰(Trevor Blackwell)은 전국적으로 상점을 중단하지 않고 새로운 서버로 이동시키는 놀라운 프로그램을 작성했습니다. 프로그램들은 우리에게 호출을 보냈고, 사용자들에게 팩스와 이메일을 보냈으며, 신용카드 처리업체와 거래를 수행했고, 소켓(socket), 파이프(pipe), HTTP 요청(request), SSH(Secure Shell), UDP(User Datagram Protocol) 패킷(packet), 공유 메모리(shared memory), 파일(file)을 통해 서로 통신했습니다. 비아웹의 일부는 프로그램의 부재로 구성되기도 했습니다. 유닉스(Unix) 보안의 핵심 중 하나는 사람들이 서버에 침입하는 데 사용할 수 있는 불필요한 유틸리티를 실행하지 않는 것이기 때문입니다.

소프트웨어만으로 끝나지 않았습니다. 우리는 서버 구성에 대해 많은 시간을 생각했습니다. 우리는 부품으로 서버를 직접 만들었습니다. 부분적으로는 비용을 절약하기 위해서였고, 부분적으로는 우리가 원하는 것을 정확히 얻기 위해서였습니다. 우리는 업스트림 인터넷 서비스 제공업체(ISP)가 모든 백본(backbone)에 충분히 빠른 연결을 가지고 있는지 생각해야 했습니다. 우리는 RAID(Redundant Array of Independent Disks) 공급업체들과 연속적으로 데이트를 했습니다.

하지만 하드웨어는 단지 걱정해야 할 대상이 아닙니다. 하드웨어를 제어하면 사용자들을 위해 더 많은 것을 할 수 있습니다. 데스크톱 애플리케이션을 사용하면 특정 최소 하드웨어를 지정할 수 있지만, 더 추가할 수는 없습니다. 서버를 관리하면 관련 하드웨어를 설치하는 것만으로 모든 사용자가 사람들에게 호출을 하거나, 팩스를 보내거나, 전화로 명령을 보내거나, 신용카드를 처리하는 등의 작업을 한 번에 가능하게 할 수 있습니다. 우리는 항상 하드웨어로 기능을 추가할 새로운 방법을 찾았습니다. 단순히 사용자들을 만족시키기 위해서가 아니라, 직접 하드웨어를 제어할 수 없는 경쟁업체(데스크톱 소프트웨어를 판매하거나 ISP를 통해 웹 기반 애플리케이션을 재판매하기 때문)와 차별화하기 위한 방법이기도 했습니다.

웹 기반 애플리케이션의 소프트웨어는 단일 바이너리가 아니라 프로그램들의 모음이기 때문에 다양한 언어로 작성될 수 있습니다. 데스크톱 소프트웨어를 작성할 때는 사실상 기본 운영체제와 동일한 언어, 즉 C와 C++로 애플리케이션을 작성해야 했습니다. 그래서 이러한 언어들은 (관리자나 벤처 캐피탈리스트(VC)와 같은 비기술적인 사람들 사이에서) "진지한(serious)" 소프트웨어 개발을 위한 언어로 간주되었습니다. 하지만 그것은 단지 데스크톱 소프트웨어가 제공되어야 하는 방식의 인공물(artifact)이었습니다. 서버 기반 소프트웨어의 경우 원하는 어떤 언어든 사용할 수 있습니다.[3] 오늘날 많은 상위 해커들은 C와 C++에서 멀리 떨어진 언어, 즉 펄(Perl), 파이썬(Python), 심지어 리스프(Lisp)를 사용하고 있습니다.

서버 기반 소프트웨어의 경우, 시스템 전체를 하드웨어까지 제어하기 때문에 아무도 어떤 언어를 사용해야 하는지 말할 수 없습니다. 다른 언어는 다른 작업에 적합합니다. 각각에 가장 적합한 것을 사용할 수 있습니다. 그리고 경쟁업체가 있다면 "할 수 있다"는 "해야 한다"를 의미합니다(이에 대해서는 나중에 다시 다룰 것입니다). 이 가능성을 활용하지 않으면 경쟁업체가 활용할 것이기 때문입니다.

우리 경쟁자 대부분은 C와 C++를 사용했는데, 이로 인해 그들의 소프트웨어는 (다른 것들 중에서도) CGI(Common Gateway Interface) 스크립트의 무상태성(statelessness)을 해결할 방법이 없었기 때문에 눈에 띄게 열등했습니다. 무언가를 변경하려면 모든 변경 사항이 한 페이지에서 이루어져야 했고, 아래에 '업데이트' 버튼이 있었습니다. 제가 다른 곳에서 썼듯이, 많은 사람들이 여전히 '연구 언어(research language)'라고 생각하는 리스프(Lisp)를 사용함으로써 우리는 비아웹 에디터가 데스크톱 소프트웨어처럼 작동하도록 만들 수 있었습니다.

## 릴리즈 (Releases)

이 새로운 세상에서 가장 중요한 변화 중 하나는 릴리즈 방식입니다. 데스크톱 소프트웨어 사업에서는 릴리즈를 하는 것이 거대한 트라우마입니다. 온 회사가 하나의 거대한 코드 덩어리를 내보내기 위해 땀을 흘리고 안간힘을 씁니다. 그 과정과 결과물 모두에서 명백한 비교가 가능합니다.

서버 기반 소프트웨어에서는 직접 작성하는 프로그램처럼 거의 즉시 변경할 수 있습니다. 가끔 발생하는 큰 폭발 대신, 일련의 점진적인 변경 사항으로 소프트웨어를 릴리즈합니다. 일반적인 데스크톱 소프트웨어 회사는 1년에 한두 번 릴리즈를 할 것입니다. 비아웹에서는 종종 하루에 세 번에서 다섯 번 릴리즈를 했습니다.

이 새로운 모델로 전환하면 소프트웨어 개발이 릴리즈 방식에 얼마나 많은 영향을 받는지 깨닫게 됩니다. 데스크톱 소프트웨어 사업에서 볼 수 있는 가장 심각한 문제 중 상당수는 릴리즈의 치명적인 특성 때문입니다.

1년에 한 번만 새로운 버전을 릴리즈하면 버그를 한 번에 처리하려는 경향이 있습니다. 릴리즈 날짜 한참 전에 코드의 절반을 뜯어내고 교체한 새로운 버전을 조립하는데, 이로 인해 셀 수 없는 버그가 발생합니다. 그러면 QA(Quality Assurance) 팀이 투입되어 버그를 세기 시작하고, 프로그래머들은 목록을 따라 내려가며 버그를 수정합니다. 그들은 일반적으로 목록의 끝에 도달하지 못하며, 사실 아무도 끝이 어디인지 확신하지 못합니다. 연못에서 잔해를 낚아 올리는 것과 같습니다. 소프트웨어 내부에서 무슨 일이 일어나고 있는지 정말로 알 수 없습니다. 기껏해야 통계적인 종류의 정확성을 얻게 됩니다.

서버 기반 소프트웨어의 경우, 대부분의 변경 사항은 작고 점진적입니다. 그 자체로 버그를 유발할 가능성이 적습니다. 또한 소프트웨어를 릴리즈하기 직전에 무엇을 가장 신중하게 테스트해야 하는지 알 수 있습니다. 즉, 마지막으로 변경한 것입니다. 코드를 훨씬 더 단단히 제어하게 됩니다. 일반적으로 코드 내부에서 무슨 일이 일어나고 있는지 알고 있습니다. 물론 소스 코드(source code)를 외우고 있는 것은 아니지만, 소스를 읽을 때는 탐정이 어떤 미스터리를 풀려고 하는 것처럼이 아니라, 조종사가 계기판을 스캔하듯이 읽습니다.

데스크톱 소프트웨어는 버그에 대한 일종의 운명론을 낳습니다. 버그로 가득 찬 것을 출시하고 있다는 것을 알고 있으며, 심지어 이를 보완하기 위한 메커니즘(예: 패치 릴리즈)까지 마련해 두었습니다. 그렇다면 몇몇 버그에 대해 왜 걱정해야 할까요? 곧 작동하지 않는다는 것을 아는 전체 기능을 릴리즈하게 될 것입니다.

애플은 올해 초 이런 일을 했습니다. 그들은 이미 네 번이나 미뤄진 새 OS를 출시해야 한다는 압박을 느꼈지만, 일부 소프트웨어(CD 및 DVD 지원)는 준비되지 않았습니다. 해결책은? 미완성 부분을 제외하고 OS를 출시했으며, 사용자들은 나중에 설치해야 할 것입니다.

웹 기반 소프트웨어는 작동하기 전에 소프트웨어를 출시할 필요가 없으며, 작동하는 즉시 출시할 수 있습니다.

업계 베테랑들은 작동하기 전에 소프트웨어를 출시할 필요가 없다는 것이 멋진 아이디어처럼 들리지만, 특정 날짜까지 새로운 버전의 소프트웨어를 제공하겠다고 약속했을 때는 어떻게 되는지 생각할 것입니다. 웹 기반 소프트웨어에서는 그러한 약속을 하지 않을 것입니다. 버전이 없기 때문입니다. 소프트웨어는 점진적이고 지속적으로 변경됩니다. 일부 변경 사항은 다른 것보다 클 수 있지만, 버전이라는 개념은 웹 기반 소프트웨어에 자연스럽게 들어맞지 않습니다.

누군가 비아웹을 기억한다면 이것이 이상하게 들릴 수 있습니다. 우리는 항상 새로운 버전을 발표했기 때문입니다. 이것은 전적으로 홍보(PR) 목적으로 이루어졌습니다. 우리는 업계 언론이 버전 번호로 생각한다는 것을 알게 되었습니다. 그들은 주요 릴리즈, 즉 버전 번호의 첫 번째 자리가 바뀌는 경우에 대해 대대적인 보도를 할 것이고, 일반적으로 소수점 이하의 자리가 바뀌는 포인트 릴리즈(point release)에 대해서는 기껏해야 한 단락만 쓸 것입니다.

우리 경쟁사 중 일부는 데스크톱 소프트웨어를 제공하고 있었고 실제로 버전 번호가 있었습니다. 그리고 이러한 릴리즈에 대해, 그 존재 자체가 우리에게는 그들의 후진성(backwardness)의 증거로 보였음에도 불구하고, 그들은 온갖 홍보를 얻었습니다. 우리는 놓치고 싶지 않아서 우리 소프트웨어에도 버전 번호를 부여하기 시작했습니다. 홍보를 원할 때마다, 지난 "릴리즈" 이후 추가된 모든 기능 목록을 만들고, 소프트웨어에 새로운 버전 번호를 붙여, 새로운 버전이 즉시 사용 가능하다고 보도 자료를 발표했습니다. 놀랍게도 아무도 우리에게 그것에 대해 묻지 않았습니다.

우리가 인수될 때까지 우리는 이것을 세 번 했고, 그래서 버전 4였습니다. 제가 기억하기로는 버전 4.1이었습니다. 비아웹이 야후 스토어가 된 후에는 더 이상 그렇게 절박하게 홍보할 필요가 없었기 때문에, 소프트웨어는 계속 발전했지만, 버전 번호라는 개념은 조용히 사라졌습니다.

## 버그 (Bugs)

웹 기반 소프트웨어의 또 다른 주요 기술적 이점은 대부분의 버그를 재현할 수 있다는 것입니다. 사용자의 데이터가 디스크에 바로 있습니다. 누군가 소프트웨어를 망가뜨리면, 데스크톱 소프트웨어처럼 무엇이 문제인지 추측할 필요가 없습니다. 사용자가 전화 통화 중에도 오류를 재현할 수 있어야 합니다. 애플리케이션에 오류 감지 코드가 내장되어 있다면, 이미 알고 있을 수도 있습니다.

웹 기반 소프트웨어는 24시간 내내 사용되므로, 여러분이 하는 모든 일이 즉시 검증됩니다. 버그는 빠르게 나타납니다. 소프트웨어 회사들은 때때로 사용자에게 소프트웨어 디버깅을 맡긴다는 비난을 받기도 합니다. 그리고 그것이 바로 제가 옹호하는 것입니다. 웹 기반 소프트웨어의 경우 실제로 좋은 계획입니다. 버그가 적고 일시적이기 때문입니다. 소프트웨어를 점진적으로 출시하면 애초에 버그가 훨씬 적습니다. 그리고 오류를 재현하고 변경 사항을 즉시 출시할 수 있으면, 대부분의 버그를 나타나는 즉시 찾아 수정할 수 있습니다. 우리는 공식적인 버그 추적 시스템에 신경 쓸 만큼 동시에 버그가 많았던 적이 없습니다.

물론 릴리즈하기 전에 변경 사항을 테스트해야 하므로, 주요 버그가 출시되지 않아야 합니다. 필연적으로 발생하는 소수의 버그는 경계 사례(borderline cases)와 관련될 것이며, 누군가 불평하기 위해 전화하기 전에 그 버그를 마주치는 소수의 사용자에게만 영향을 미칠 것입니다. 버그를 즉시 수정하는 한, 일반 사용자에게 미치는 순 효과는 훨씬 적은 버그입니다. 평균적인 비아웹 사용자가 버그를 본 적이 있을지 의심스럽습니다.

새로운 버그를 수정하는 것이 오래된 버그를 수정하는 것보다 쉽습니다. 방금 작성한 코드에서 버그를 찾는 것은 보통 상당히 빠릅니다. 버그가 나타나면 소스를 보기도 전에 무엇이 잘못되었는지 이미 아는 경우가 많습니다. 무의식적으로 이미 걱정하고 있었기 때문입니다. 6개월 전에 작성한 것(1년에 한 번 릴리즈하는 경우 평균적인 경우)에서 버그를 수정하는 것은 훨씬 더 많은 작업입니다. 그리고 코드를 잘 이해하지 못하기 때문에, 지저분한 방식으로 수정하거나 더 많은 버그를 유발할 가능성이 높습니다.[4]

버그를 조기에 발견하면 복합 버그(compound bug)도 줄어듭니다. 복합 버그는 두 개의 개별적인 버그가 상호작용하는 것입니다. 예를 들어, 계단을 내려가다가 발이 걸려 넘어지고, 난간을 잡으려고 하는데 난간이 손에 뽑히는 경우입니다. 소프트웨어에서 이런 종류의 버그는 가장 찾기 어렵고, 결과도 가장 나쁜 경향이 있습니다.[5] 전통적인 "모든 것을 망가뜨리고 버그를 걸러내는" 접근 방식은 본질적으로 많은 복합 버그를 야기합니다. 그리고 일련의 작은 변경 사항으로 출시되는 소프트웨어는 본질적으로 그렇지 않은 경향이 있습니다. 바닥은 나중에 무언가에 걸릴 수 있는 느슨한 물건들이 항상 쓸어내려져 깨끗하게 유지됩니다.

함수형 프로그래밍(functional programming)이라는 기술을 사용하면 도움이 됩니다. 함수형 프로그래밍은 부작용(side-effects)을 피하는 것을 의미합니다. 상업용 소프트웨어보다는 연구 논문에서 더 많이 볼 수 있는 것이지만, 웹 기반 애플리케이션에는 정말 유용하다는 것이 밝혀졌습니다. 전체 프로그램을 순수 함수형 코드로 작성하기는 어렵지만, 상당한 부분을 이런 방식으로 작성할 수 있습니다. 그렇게 하면 소프트웨어의 해당 부분을 테스트하기가 더 쉬워집니다. 상태(state)가 없기 때문인데, 이는 지속적으로 작은 수정 사항을 만들고 테스트하는 상황에서 매우 편리합니다. 저는 비아웹 에디터의 많은 부분을 이런 스타일로 작성했고, 우리의 스크립트 언어인 RTML을 순수 함수형 언어로 만들었습니다.

데스크톱 소프트웨어 업계 사람들은 믿기 어렵겠지만, 비아웹에서는 버그가 거의 게임처럼 느껴졌습니다. 대부분의 릴리즈된 버그가 경계 사례(borderline cases)와 관련되어 있었기 때문에, 이를 경험하는 사용자들은 고급 사용자(advanced user)들이었을 가능성이 높았고, 이들은 한계를 넘어서는 시도를 하고 있었습니다. 고급 사용자들은 버그에 대해 더 관대했습니다. 특히 우리가 그들이 요청하는 기능을 추가하는 과정에서 버그를 도입했을 가능성이 높았기 때문입니다. 사실, 버그가 드물고 이를 보려면 정교한 작업을 해야 했기 때문에, 고급 사용자들은 종종 버그를 발견한 것에 대해 자랑스러워했습니다. 그들은 분노보다는 승리감에 차서 지원팀에 전화를 걸었고, 마치 우리에게 점수를 얻은 것처럼 보였습니다.

## 지원 (Support)

오류를 재현할 수 있다면 고객 지원에 대한 접근 방식이 바뀝니다. 대부분의 소프트웨어 회사에서는 고객에게 좋은 기분을 주기 위한 방법으로 지원을 제공합니다. 고객들은 알려진 버그에 대해 전화하거나, 단순히 뭔가 잘못하고 있어서 무엇이 문제인지 알아내야 하는 경우입니다. 어느 경우든 그들로부터 배울 수 있는 것이 많지 않습니다. 그래서 지원 전화는 개발자들로부터 최대한 격리하고 싶은 귀찮은 일로 여기는 경향이 있습니다.

비아웹에서는 그런 식으로 일하지 않았습니다. 비아웹에서는 고객의 이야기를 듣고 싶었기 때문에 지원이 무료였습니다. 누군가 문제가 있다면, 즉시 알고 싶었고, 그래서 오류를 재현하고 수정을 릴리즈할 수 있었습니다.

그래서 비아웹에서는 개발자들이 항상 지원팀과 긴밀하게 연락했습니다. 고객 지원 담당자들은 프로그래머들로부터 약 9미터 정도 떨어져 있었고, 진정한 버그 보고서가 있으면 언제든지 무엇이든 중단시킬 수 있다는 것을 알고 있었습니다. 우리는 심각한 버그를 고치기 위해 이사회 회의를 떠나기도 했습니다.

우리의 지원 방식은 모두를 더 행복하게 만들었습니다. 고객들은 기뻐했습니다. 지원 전화에 걸어 중요한 소식을 전하는 사람으로 대우받는다면 어떤 기분일지 상상해 보세요. 고객 지원 담당자들은 스크립트를 읽어주는 대신 사용자들을 도울 수 있어서 좋아했습니다. 그리고 프로그래머들은 모호한 간접 보고서를 듣는 대신 버그를 재현할 수 있어서 좋아했습니다.

버그를 즉시 수정하는 우리의 정책은 고객 지원 담당자와 해커 사이의 관계를 바꾸어 놓았습니다. 대부분의 소프트웨어 회사에서는 지원 담당자가 보수도 적게 받는 인간 방패 역할을 하고, 해커는 세상의 창조주인 하느님의 작은 복사판처럼 여겨집니다. 버그 보고 절차가 어떻든 간에, 그것은 일방적일 가능성이 높습니다. 버그에 대해 들은 지원 담당자는 어떤 양식을 작성하여 (아마도 QA를 거쳐) 프로그래머에게 전달하고, 프로그래머는 그것을 할 일 목록에 추가합니다. 비아웹에서는 매우 달랐습니다. 고객으로부터 버그에 대해 들은 지 1분 이내에 지원 담당자는 프로그래머 옆에 서서 "젠장, 당신 말이 맞아, 버그야"라는 말을 들을 수 있었습니다. 지원 담당자들은 해커들로부터 "당신 말이 맞아"라는 말을 듣는 것을 기뻐했습니다. 그들은 마치 방금 잡은 쥐를 가져다주는 고양이처럼 기대에 찬 표정으로 우리에게 버그를 가져왔습니다. 또한 이제 자신들의 명예가 걸려 있었기 때문에 버그의 심각성을 판단하는 데 더 신중해졌습니다.

우리가 야후에 인수된 후, 고객 지원 직원들은 프로그래머들과 멀리 떨어지게 되었습니다. 그제야 우리는 그들이 사실상 QA이자 어느 정도 마케팅 역할도 하고 있다는 것을 깨달았습니다. 버그를 잡는 것 외에도, 그들은 사용자들을 혼란스럽게 하는 기능과 같은 모호하고 버그와 유사한 것들에 대한 지식의 보관자였습니다.[6] 그들은 또한 일종의 대리 포커스 그룹이기도 했습니다. 우리는 그들에게 두 가지 새로운 기능 중 어떤 것을 사용자들이 더 원하는지 물어볼 수 있었고, 그들은 항상 옳았습니다.

## 사기 (Morale)

소프트웨어를 즉시 출시할 수 있다는 것은 큰 동기 부여가 됩니다. 종종 출근길에 소프트웨어에 변경하고 싶은 것이 떠오르면 그날 바로 실행했습니다. 이는 더 큰 기능에도 적용되었습니다. 심지어 작성하는 데 2주가 걸리는 작업(더 오래 걸리는 프로젝트는 거의 없었음)이라 할지라도, 완료되자마자 소프트웨어에서 그 효과를 볼 수 있다는 것을 알았습니다.

다음 릴리즈를 위해 1년을 기다려야 했다면, 적어도 한동안은 대부분의 아이디어를 보류했을 것입니다. 하지만 아이디어라는 것은 더 많은 아이디어로 이어진다는 점입니다. 글을 쓰기 시작할 때, 최종 결과물의 절반은 글을 쓰는 도중에 떠올랐던 아이디어라는 것을 알아차린 적이 있나요? 소프트웨어에서도 마찬가지입니다. 하나의 아이디어를 구현하기 위해 노력하는 것은 더 많은 아이디어를 줍니다. 따라서 아이디어를 보류하는 것은 그 아이디어를 구현하는 데 드는 지연뿐만 아니라, 그것을 구현함으로써 얻었을 모든 아이디어의 손실을 의미합니다. 사실, 아이디어를 보류하는 것은 새로운 아이디어를 억제하기도 합니다. 새로운 기능을 생각하기 시작할 때, 보류된 아이디어들이 쌓여 있는 선반을 보고 "하지만 다음 릴리즈를 위해 해야 할 새로운 일들이 이미 많이 있어"라고 생각하게 됩니다.

대기업들이 기능을 구현하는 대신 하는 일은 계획하는 것입니다. 비아웹에서는 때때로 이 문제로 어려움을 겪었습니다. 투자자와 분석가들은 우리에게 미래에 대한 계획이 무엇인지 물었습니다. 솔직한 답변은 '아무 계획도 없다'였을 것입니다. 개선하고 싶은 것에 대한 일반적인 아이디어는 있었지만, 어떻게 할지 알았다면 이미 했을 것입니다. 다음 6개월 동안 무엇을 할 것인가? 가장 큰 이득이 될 만한 것이 무엇이든 할 것입니다. 감히 이런 대답을 했는지는 모르겠지만, 그것이 진실이었습니다. 계획은 단지 '선반에 놓인 아이디어'를 다른 말로 표현한 것입니다. 좋은 아이디어가 떠오르면 우리는 그것을 구현했습니다.

비아웹에서는 많은 소프트웨어 회사와 마찬가지로 대부분의 코드는 명확한 소유자가 있었습니다. 하지만 무언가를 소유하면 정말로 소유하는 것이었습니다. 소프트웨어 조각의 소유자를 제외하고는 아무도 릴리즈를 승인(심지어 알 필요도)할 필요가 없었습니다. 고장을 막는 유일한 보호책은 동료들에게 바보처럼 보일까봐 하는 두려움이었는데, 그것만으로도 충분했습니다. 제가 마치 무작정 코드를 작성하며 나아갔다는 인상을 주었을 수도 있습니다. 우리는 빠르게 움직였지만, 그 서버에 소프트웨어를 릴리즈하기 전에 매우 신중하게 생각했습니다. 그리고 세심한 주의를 기울이는 것이 느리게 움직이는 것보다 안정성에 더 중요합니다. 해군 조종사는 세심한 주의를 기울이기 때문에 밤에 흔들리는 항공모함 갑판에 시속 140마일로 4만 파운드 비행기를 착륙시킬 수 있으며, 이는 평범한 십대들이 베이글을 자르는 것보다 훨씬 안전합니다.

물론 이런 방식으로 소프트웨어를 작성하는 것은 양날의 검입니다. 좋은, 신뢰할 수 있는 소규모 프로그래머 팀에게는 훨씬 더 잘 작동하지만, 아이디어를 낸 사람이 아닌 위원회에서 나쁜 아이디어를 걸러내는 평범한 대기업에게는 그렇지 않을 것입니다.

## 브룩스의 역설 (Brooks in Reverse)

다행히도 웹 기반 소프트웨어는 더 적은 수의 프로그래머를 필요로 합니다. 저는 한때 전체 엔지니어링 부서에 100명 이상의 직원이 있는 중간 규모의 데스크톱 소프트웨어 회사에서 일했습니다. 이 중 제품 개발에 종사하는 인원은 13명에 불과했습니다. 나머지는 모두 릴리즈, 포팅(porting) 등에 집중했습니다. 웹 기반 소프트웨어는 릴리즈, 포팅 등이 없기 때문에 (최대) 13명의 인원만 있으면 됩니다.

비아웹은 단 3명의 인원으로 작성되었습니다.[7] 저는 항상 더 많은 인원을 고용하라는 압력을 받았습니다. 왜냐하면 우리는 인수되기를 원했고, 인수자들이 프로그래머가 3명밖에 없는 회사에 높은 가격을 지불하는 것을 어려워할 것이라는 것을 알았기 때문입니다. (해결책: 우리는 더 많은 인원을 고용했지만, 그들에게 새로운 프로젝트를 만들었습니다.)

더 적은 수의 프로그래머로 소프트웨어를 작성할 수 있다면 돈보다 더 많은 것을 절약할 수 있습니다. 프레드 브룩스(Fred Brooks)가 『맨먼스 미신(The Mythical Man-Month)』에서 지적했듯이, 프로젝트에 인원을 추가하면 진행 속도가 느려지는 경향이 있습니다. 개발자들 간의 가능한 연결 수는 그룹 규모에 따라 기하급수적으로 증가합니다. 그룹이 커질수록 소프트웨어가 함께 작동하는 방식을 협상하는 회의에 더 많은 시간을 할애하고, 예상치 못한 상호작용으로 인해 더 많은 버그가 발생할 것입니다.

다행히 이 과정은 반대로도 작동합니다. 그룹이 작아질수록 소프트웨어 개발은 기하급수적으로 효율적이 됩니다. 비아웹의 프로그래머들이 실제로 회의를 한 적은 없는 것으로 기억합니다. 점심을 먹으러 걸어가는 동안 말할 수 있는 것보다 더 많은 것을 동시에 말할 필요는 없었습니다.

만약 단점이 있다면, 모든 프로그래머가 어느 정도 시스템 관리자 역할도 해야 한다는 것입니다. 소프트웨어를 호스팅할 때는 누군가 서버를 감시해야 하는데, 실제로는 이를 제대로 할 수 있는 유일한 사람들은 소프트웨어를 작성한 사람들입니다. 비아웹에서는 우리 시스템이 너무 많은 구성 요소를 가지고 있었고 너무 자주 변경되었기 때문에 소프트웨어와 인프라 사이에 명확한 경계가 없었습니다. 그러한 경계를 임의로 선언하는 것은 우리의 설계 선택을 제약했을 것입니다. 그래서 우리는 항상 언젠가 ("두어 달 안에") 모든 것이 안정화되어 서버만 걱정하는 사람을 고용할 수 있기를 바랐지만, 결코 일어나지 않았습니다.

제품을 활발하게 개발하는 한 다른 방법은 없을 것이라고 생각합니다. 웹 기반 소프트웨어는 결코 작성하고 체크인하고 집에 가는 종류의 것이 아닙니다. 그것은 지금 서버에서 실행되고 있는 살아있는 것입니다. 나쁜 버그는 한 사용자의 프로세스(process)만 충돌시키는 것이 아니라 모든 프로세스를 충돌시킬 수도 있습니다. 코드의 버그가 디스크의 일부 데이터를 손상시키면 그것을 수정해야 합니다. 등등. 우리는 서버를 매분 감시할 필요는 없다는 것을 알았습니다(처음 1년 정도 후에는). 하지만 최근에 변경한 것들을 확실히 주시해야 합니다. 밤늦게 코드를 릴리즈하고 집에 가지 않습니다.

## 사용자 관찰 (Watching Users)

서버 기반 소프트웨어는 코드와 더 긴밀하게 연결되어 있습니다. 사용자들과도 더 긴밀하게 연결될 수 있습니다. 인튜이트(Intuit)는 소매점에서 고객에게 자신을 소개하고 그들을 집까지 따라가는 것으로 유명합니다. 누군가 당신의 소프트웨어를 처음 사용하는 것을 본 적이 있다면, 어떤 놀라움이 그들을 기다리고 있었을지 알 것입니다.

소프트웨어는 사용자가 생각하는 대로 작동해야 합니다. 하지만 사용자들은 무엇을 생각하고 있을지, 저를 믿으세요, 직접 보기 전에는 전혀 알 수 없습니다. 그리고 서버 기반 소프트웨어는 그들의 행동에 대한 전례 없는 정보를 제공합니다. 작고 인위적인 포커스 그룹에만 의존할 필요가 없습니다. 모든 사용자의 모든 클릭을 볼 수 있습니다. 사용자들의 사생활을 침해하지 않도록 무엇을 볼지 신중하게 고려해야 하지만, 가장 일반적인 통계 샘플링(statistical sampling)조차도 매우 유용할 수 있습니다.

서버에 사용자가 있으면 벤치마크(benchmark)에 의존할 필요가 없습니다. 벤치마크는 시뮬레이션된 사용자입니다. 서버 기반 소프트웨어에서는 실제 사용자를 관찰할 수 있습니다. 무엇을 최적화할지 결정하려면 서버에 로그인하여 무엇이 CPU를 모두 소모하는지 확인하면 됩니다. 그리고 언제 최적화를 멈춰야 할지도 알 수 있습니다. 우리는 결국 비아웹 에디터가 CPU 제한이 아닌 메모리 제한에 도달하도록 만들었고, 사용자 데이터의 크기를 줄이기 위해 할 수 있는 것이 없었기 때문에(쉬운 방법은 없었음), 거기서 멈춰도 좋다는 것을 알았습니다.

서버 기반 소프트웨어에는 효율성이 중요합니다. 하드웨어 비용을 지불해야 하기 때문입니다. 서버당 지원할 수 있는 사용자 수는 자본 비용의 제수(divisor)이므로, 소프트웨어를 매우 효율적으로 만들 수 있다면 경쟁업체보다 싸게 팔면서도 여전히 이익을 낼 수 있습니다. 비아웹에서 우리는 사용자당 자본 비용을 약 5달러까지 낮췄습니다. 지금은 더 낮을 것이고, 아마도 첫 달 청구서를 보내는 비용보다도 적을 것입니다. 소프트웨어가 합리적으로 효율적이라면 이제 하드웨어는 무료입니다.

사용자를 관찰하는 것은 최적화뿐만 아니라 디자인에도 도움이 됩니다. 비아웹에는 RTML이라는 스크립트 언어가 있었는데, 고급 사용자들이 자신만의 페이지 스타일을 정의할 수 있도록 했습니다. 우리는 RTML이 일종의 제안함이 된다는 것을 알게 되었습니다. 사용자들이 미리 정의된 페이지 스타일로는 원하는 것을 할 수 없을 때만 RTML을 사용했기 때문입니다. 예를 들어, 원래 에디터는 페이지 전체에 버튼 바를 배치했지만, 많은 사용자들이 RTML을 사용하여 버튼을 왼쪽에 배치한 후, 우리는 그것을 미리 정의된 페이지 스타일의 옵션(실제로 기본값)으로 만들었습니다.

마지막으로, 사용자를 관찰하면 그들이 어려움에 처했을 때를 종종 알 수 있습니다. 그리고 고객은 항상 옳기 때문에, 그것은 고쳐야 할 것이 있다는 신호입니다. 비아웹에서 사용자를 확보하는 핵심은 온라인 시험 사용이었습니다. 그것은 마케팅 담당자들이 만든 단순한 슬라이드 시리즈가 아니었습니다. 우리의 시험 사용에서는 사용자들이 실제로 소프트웨어를 사용했습니다. 약 5분이 걸렸고, 그 끝에는 실제 작동하는 상점을 만들었습니다.

시험 사용은 우리가 거의 모든 신규 사용자를 확보하는 방식이었습니다. 대부분의 웹 기반 애플리케이션에서도 마찬가지일 것이라고 생각합니다. 사용자가 시험 사용을 성공적으로 마칠 수 있다면 제품을 좋아할 것입니다. 혼란스러워하거나 지루해하면 그렇지 않을 것입니다. 따라서 더 많은 사람들이 시험 사용을 마칠 수 있도록 우리가 할 수 있는 모든 것은 우리의 성장률을 높일 것입니다.

시험 사용을 하는 사람들의 클릭 경로(click trail)를 연구해보니, 특정 단계에서 혼란스러워하며 브라우저의 '뒤로' 버튼을 클릭하는 것을 발견했습니다. (웹 기반 애플리케이션을 작성해 보면 '뒤로' 버튼이 가장 흥미로운 철학적 문제 중 하나가 된다는 것을 알게 될 것입니다.) 그래서 그 지점에 "거의 다 마쳤으니 '뒤로' 버튼을 클릭하지 마세요"라는 메시지를 추가했습니다. 웹 기반 소프트웨어의 또 다른 큰 장점은 변경 사항에 대한 즉각적인 피드백을 얻을 수 있다는 것입니다. 시험 사용을 완료하는 사람들의 수가 즉시 60%에서 90%로 증가했습니다. 그리고 신규 사용자 수는 완료된 시험 사용 횟수의 함수였기 때문에, 그 변경 하나만으로도 우리의 매출 성장은 50% 증가했습니다.

## 돈 (Money)

1990년대 초반에 소프트웨어가 구독 비즈니스(subscription business)라는 기사를 읽었습니다. 처음에는 매우 냉소적인 발언으로 들렸습니다. 하지만 나중에 그것이 현실을 반영한다는 것을 깨달았습니다. 소프트웨어 개발은 지속적인 과정입니다. 사람들이 계속 비용을 지불하도록 새로운 버전을 계속 구매하고 설치하도록 강요하는 것보다 구독료를 공개적으로 청구하는 것이 더 깔끔하다고 생각합니다. 다행히 구독은 웹 기반 애플리케이션에 대한 청구의 자연스러운 방식입니다.

애플리케이션 호스팅은 프리웨어(freeware)로는 채워지지 않을 영역입니다. 애플리케이션 호스팅은 많은 스트레스와 실제 비용이 발생합니다. 아무도 무료로 하고 싶어하지 않을 것입니다.

기업에게 웹 기반 애플리케이션은 이상적인 수익원입니다. 매 분기를 백지 상태로 시작하는 대신, 반복적인 수익 흐름을 갖게 됩니다. 소프트웨어가 점진적으로 발전하기 때문에, 새로운 모델이 실패할까 봐 걱정할 필요가 없습니다. 새로운 모델이 본질적으로 필요 없을 수도 있고, 사용자들이 싫어하는 작업을 소프트웨어에 추가했다면 즉시 알 수 있을 것입니다. 미수금 청구서로 어려움을 겪을 필요가 없습니다. 누군가 비용을 지불하지 않으면 서비스를 중단할 수 있습니다. 그리고 불법 복제(piracy)의 가능성도 없습니다.

마지막 "이점"은 문제가 될 수도 있습니다. 어느 정도의 불법 복제는 소프트웨어 회사에 유리합니다. 어떤 사용자가 어떤 가격에도 소프트웨어를 구매하지 않았을 것이라면, 그가 불법 복제본을 사용해도 잃을 것이 없습니다. 사실 그가 소프트웨어를 표준으로 만드는 데 도움이 되는 또 다른 사용자이기 때문에 이득을 얻거나, 고등학교를 졸업한 후 나중에 구매할 수도 있기 때문입니다.

가능할 때 기업들은 가격 차별(price discrimination)이라는 것을 하고 싶어 합니다. 이는 각 고객이 감당할 수 있는 만큼의 비용을 청구하는 것을 의미합니다.[8] 소프트웨어는 한계 비용(marginal cost)이 0에 가깝기 때문에 가격 차별에 특히 적합합니다. 그래서 일부 소프트웨어는 인텔(Intel) 박스보다 선(Sun)에서 실행하는 데 비용이 더 많이 듭니다. 선을 사용하는 회사는 돈을 절약하는 데 관심이 없으며 안전하게 더 많은 비용을 청구할 수 있기 때문입니다. 불법 복제는 사실상 가격 차별의 가장 낮은 계층입니다. 소프트웨어 회사들은 이것을 이해하고 있으며 의도적으로 일부 종류의 불법 복제를 묵인한다고 생각합니다.[9] 서버 기반 소프트웨어의 경우 다른 해결책을 찾아야 할 것입니다.

웹 기반 소프트웨어는 특히 데스크톱 소프트웨어와 비교할 때 구매하기 쉽기 때문에 잘 팔립니다. 사람들은 무언가를 사기로 결정하고, 그 다음에 그것을 산다고 생각할 수도 있습니다. 저는 비아웹 전에는 그렇게 생각했습니다. 사실 두 번째 단계가 첫 번째 단계로 다시 돌아갈 수 있습니다. 무언가를 사기 어렵다면 사람들은 그것을 원했는지에 대한 마음을 바꿀 것입니다. 그리고 그 반대도 마찬가지입니다. 사기 쉽다면 더 많이 팔릴 것입니다. 저는 아마존(Amazon)이 존재하기 때문에 더 많은 책을 삽니다. 웹 기반 소프트웨어는 세상에서 가장 쉽게 살 수 있는 것 중 하나이며, 특히 온라인 데모를 방금 마쳤다면 더욱 그렇습니다. 사용자들은 신용카드 번호를 입력하는 것 외에 많은 것을 할 필요가 없습니다. (더 많은 것을 요구하면 위험합니다.)

때로는 ISP가 리셀러(reseller) 역할을 하여 웹 기반 소프트웨어를 제공하기도 합니다. 이것은 좋지 않은 생각입니다. 하드웨어와 소프트웨어 모두를 지속적으로 개선해야 하므로 서버를 관리해야 합니다. 서버에 대한 직접적인 통제권을 포기하면 웹 기반 애플리케이션을 개발하는 대부분의 이점을 포기하는 것입니다. 우리 경쟁사 중 몇몇은 이런 식으로 스스로 무덤을 팠습니다. 보통 저는 생각하건대, 엄청난 잠재적 채널에 흥분했지만, 그 채널을 통해 판매하려던 제품을 망칠 것이라는 사실을 깨닫지 못한 양복쟁이들(suits)에게 압도당했기 때문입니다. ISP를 통해 웹 기반 소프트웨어를 판매하는 것은 자판기를 통해 스시(sushi)를 판매하는 것과 같습니다.

## 고객 (Customers)

고객은 누가 될까요? 비아웹에서는 처음에는 개인과 소규모 기업이었고, 웹 기반 애플리케이션에서도 이러한 경향이 나타날 것이라고 생각합니다. 이들은 새로운 것을 시도할 준비가 된 사용자들입니다. 부분적으로는 더 유연하기 때문이고, 부분적으로는 새로운 기술의 낮은 비용을 원하기 때문입니다.

웹 기반 애플리케이션은 종종 대기업에게도 최고의 선택이 될 것입니다 (비록 그들이 늦게 깨닫겠지만). 최고의 인트라넷(intranet)은 인터넷입니다. 기업이 진정한 웹 기반 애플리케이션을 사용한다면, 소프트웨어는 더 잘 작동하고, 서버는 더 잘 관리되며, 직원들은 어디서든 시스템에 접근할 수 있을 것입니다.

이러한 접근 방식에 대한 반대 의견은 주로 보안에 초점을 맞춥니다. 직원들에게 접근이 쉬워지면, 나쁜 사람들에게도 쉬워질 것이라는 것입니다. 일부 대형 상인들은 고객의 신용카드 정보가 자체 서버에 더 안전할 것이라고 생각하여 비아웹 사용을 꺼려했습니다. 이 점을 외교적으로 설명하기는 쉽지 않았지만, 사실 데이터는 거의 확실히 그들보다 우리 손에 더 안전했습니다. 보안을 관리할 더 나은 인력을 고용할 수 있는 곳은 서버 운영을 주된 사업으로 하는 기술 스타트업일까요, 아니면 의류 소매업체일까요? 우리는 보안에 대해 더 나은 인력을 가지고 있었을 뿐만 아니라, 보안에 대해 더 많이 걱정했습니다. 만약 누군가 의류 소매업체의 서버를 침입했다면, 기껏해야 한 상인에게만 영향을 미치고, 아마도 조용히 덮어질 수 있었으며, 최악의 경우 한 사람이 해고될 수도 있었습니다. 만약 누군가 우리 서버를 침입했다면, 수천 명의 상인에게 영향을 미칠 수 있었고, 아마도 CNet 뉴스에 나올 것이며, 우리 사업을 망하게 할 수도 있었습니다.

돈을 안전하게 보관하고 싶다면 집에 있는 매트리스 밑에 두실 건가요, 아니면 은행에 맡기실 건가요? 이 주장은 서버 관리의 모든 측면에 적용됩니다. 보안뿐만 아니라 가동 시간(uptime), 대역폭(bandwidth), 부하 관리(load management), 백업(backup) 등에도 해당됩니다. 우리의 존재는 이러한 것들을 올바르게 수행하는 것에 달려 있었습니다. 서버 문제는 우리에게는 위험한 장난감이 장난감 제조업자에게, 또는 살모넬라 균이 식품 가공업자에게 그러하듯이 가장 큰 금기 사항이었습니다.

웹 기반 애플리케이션을 사용하는 대기업은 그만큼 IT를 아웃소싱하는 것입니다. 극단적으로 들리겠지만, 저는 일반적으로 이것이 좋은 생각이라고 생각합니다. 이런 방식으로 기업들은 사내 시스템 관리자로부터 받는 것보다 더 나은 서비스를 받을 가능성이 높습니다. 시스템 관리자는 경쟁 압력에 직접 노출되지 않기 때문에 까다롭고 반응이 느려질 수 있습니다. 영업 사원은 고객을 상대해야 하고, 개발자는 경쟁사의 소프트웨어를 상대해야 하지만, 시스템 관리자는 마치 독신 노인처럼 자신을 통제할 외부적인 힘이 거의 없습니다.[10] 비아웹에서는 우리를 통제할 외부적인 힘이 충분히 있었습니다. 우리에게 전화하는 사람들은 동료가 아니라 고객이었습니다. 서버가 막히면 우리는 즉시 행동했습니다. 생각만 해도 몇 년이 지난 지금도 아드레날린이 솟구칩니다.

따라서 웹 기반 애플리케이션은 일반적으로 대기업에게도 올바른 답이 될 것입니다. 그러나 그들은 데스크톱 컴퓨터의 경우처럼 가장 늦게 이를 깨달을 것입니다. 그리고 부분적으로는 같은 이유 때문입니다. 대기업에게 더 비싼 것이 필요하다고 설득하는 데 많은 돈이 들 것이기 때문입니다.

부유한 고객은 더 비싼 솔루션을 구매하는 경향이 항상 있습니다. 심지어 저렴한 솔루션이 더 나을 때도 말입니다. 왜냐하면 비싼 솔루션을 제공하는 사람들이 판매에 더 많은 돈을 쓸 수 있기 때문입니다. 비아웹에서는 항상 이런 문제에 부딪혔습니다. 우리는 몇몇 고액 상인들을 웹 컨설팅 회사에 뺏겼습니다. 그 회사들은 자체 서버에 맞춤형 온라인 상점을 구축하는 데 50만 달러를 지불하면 더 나아질 것이라고 그들을 설득했습니다. 그러나 크리스마스 쇼핑 시즌이 다가오고 서버 부하가 증가했을 때, 한 명 이상이 발견했듯이 그들은 일반적으로 더 나아지지 않았습니다. 비아웹은 이들 상인들이 얻은 것보다 훨씬 더 정교했지만, 우리는 그들에게 그것을 말할 여유가 없었습니다. 월 300달러로는 잘 차려입고 권위 있는 목소리를 내는 팀을 고객에게 프레젠테이션(presentation)하러 보낼 여유가 없었습니다.

대기업이 추가로 지불하는 비용의 상당 부분은 고가의 물건을 판매하는 데 드는 비용입니다. (국방부가 변기 시트에 천 달러를 지불한다면, 부분적으로는 변기 시트를 천 달러에 판매하는 데 많은 비용이 들기 때문입니다.) 그리고 이것이 인트라넷 소프트웨어가 아마도 좋지 않은 아이디어임에도 불구하고 계속 번성하는 한 가지 이유입니다. 단순히 더 비싸기 때문입니다. 이 딜레마를 해결할 방법은 없으므로, 가장 좋은 계획은 먼저 소규모 고객을 공략하는 것입니다. 나머지는 시간이 지나면 따라올 것입니다.

## 서버의 아들 (Son of Server)

서버에서 소프트웨어를 실행하는 것은 새로운 것이 아닙니다. 사실 그것은 오래된 모델입니다. 메인프레임(mainframe) 애플리케이션은 모두 서버 기반입니다. 서버 기반 소프트웨어가 그렇게 좋은 아이디어라면 왜 지난번에는 실패했을까요? 왜 데스크톱 컴퓨터가 메인프레임을 압도했을까요?

처음에는 데스크톱 컴퓨터가 그다지 위협적이지 않아 보였습니다. 초기 사용자들은 모두 해커였습니다. 또는 그때는 취미가라고 불렸습니다. 그들은 마이크로컴퓨터(microcomputer)가 저렴했기 때문에 좋아했습니다. 처음으로 자신만의 컴퓨터를 가질 수 있었습니다. "개인용 컴퓨터(personal computer)"라는 문구는 이제 일상어가 되었지만, 처음 사용될 때는 오늘날의 "개인용 위성(personal satellite)"처럼 의도적으로 대담한 소리를 냈습니다.

데스크톱 컴퓨터가 주도권을 잡은 이유는 무엇일까요? 저는 더 나은 소프트웨어를 가졌기 때문이라고 생각합니다. 그리고 마이크로컴퓨터 소프트웨어가 더 좋았던 이유는 소규모 회사들이 작성할 수 있었기 때문이라고 생각합니다.

초기 단계에서 스타트업이 얼마나 취약하고 미숙한지 깨닫는 사람은 많지 않을 것입니다. 많은 스타트업은 거의 우연히 시작됩니다. 직업이 있거나 학생인 두세 명이 가능성이 있어 보이면 회사로 발전할 수도 있는 무언가의 프로토타입을 작성하는 방식으로 시작됩니다. 이러한 유충 단계에서는 어떤 상당한 장애물이라도 스타트업을 그 자리에서 멈추게 할 것입니다. 메인프레임 소프트웨어를 작성하는 것은 너무 많은 초기 투자를 요구했습니다. 개발 장비는 비쌌고, 고객이 대기업이기 때문에 그들에게 판매하려면 인상적인 영업팀이 필요했습니다. 메인프레임 소프트웨어를 작성하기 위한 스타트업을 시작하는 것은 저녁에 애플 II(Apple II)에서 무언가를 해킹하는 것보다 훨씬 더 심각한 사업이 될 것입니다. 그래서 메인프레임 애플리케이션을 작성하는 스타트업은 많지 않았습니다.

데스크톱 컴퓨터의 등장은 많은 새로운 소프트웨어를 탄생시켰습니다. 데스크톱용 애플리케이션을 작성하는 것이 유충 단계 스타트업에게 달성 가능한 목표처럼 보였기 때문입니다. 개발 비용이 저렴했고, 고객은 컴퓨터 상점이나 심지어 우편 주문으로도 접촉할 수 있는 개인이었습니다.

데스크톱 컴퓨터를 주류로 밀어붙인 애플리케이션은 최초의 스프레드시트(spreadsheet)인 비지캘크(VisiCalc)였습니다. 그것은 다락방에서 일하는 두 사람이 작성했지만, 어떤 메인프레임 소프트웨어도 할 수 없는 일들을 해냈습니다.[11] 비지캘크는 당시에 너무나 큰 진보였기 때문에 사람들은 그것을 실행하기 위해 애플 II를 구매했습니다. 그리고 이것이 하나의 추세의 시작이었습니다. 데스크톱 컴퓨터는 스타트업이 소프트웨어를 작성했기 때문에 승리했습니다.

서버 기반 소프트웨어가 이번에는 잘 될 것 같습니다. 스타트업이 소프트웨어를 작성할 것이기 때문입니다. 컴퓨터가 이제 너무 저렴해서, 우리처럼 데스크톱 컴퓨터를 서버로 사용하여 시작할 수 있습니다. 저렴한 프로세서(processor)는 워크스테이션(workstation) 시장을 잠식했고(이제는 그 단어를 거의 듣지 못할 것입니다) 서버 시장의 대부분을 차지하고 있습니다. 인터넷에서 가장 높은 부하를 처리하는 야후의 서버들은 모두 여러분의 데스크톱 컴퓨터에 있는 것과 동일한 저렴한 인텔 프로세서를 사용합니다. 그리고 소프트웨어를 작성한 후에는 판매하는 데 필요한 것은 웹 사이트뿐입니다. 우리 사용자들 거의 모두가 입소문과 언론 기사를 통해 우리 사이트에 직접 방문했습니다.[12]

비아웹은 전형적인 유충 단계의 스타트업이었습니다. 우리는 회사를 시작하는 것을 두려워했고, 처음 몇 달 동안은 모든 것을 언제든지 중단할 수 있는 실험으로 여기며 스스로를 위안했습니다. 다행히도 기술적인 문제 외에는 장애물이 거의 없었습니다. 소프트웨어를 작성하는 동안 우리의 웹 서버는 개발에 사용하던 데스크톱 컴퓨터와 동일했고, 다이얼업(dialup) 회선으로 외부 세계와 연결되어 있었습니다. 그 단계에서 우리의 유일한 지출은 식비와 임대료였습니다.

이제 스타트업들이 웹 기반 소프트웨어를 작성해야 할 이유가 더 많아졌습니다. 데스크톱 소프트웨어를 작성하는 것이 훨씬 덜 즐거워졌기 때문입니다. 이제 데스크톱 소프트웨어를 작성하려면 마이크로소프트의 조건에 따라 그들의 API를 호출하고 버그가 많은 운영체제 주변에서 작업해야 합니다. 그리고 성공적인 소프트웨어를 작성했다면, 마이크로소프트의 시장 조사를 해준 것에 불과하다는 것을 알게 될 수도 있습니다.

회사가 스타트업이 기반을 구축할 플랫폼을 만들고 싶다면, 해커들 자신이 사용하고 싶어할 만한 것을 만들어야 합니다. 즉, 저렴하고 잘 설계되어야 합니다. 맥(Mac)은 처음 나왔을 때 해커들 사이에서 인기가 많았고, 많은 해커들이 맥용 소프트웨어를 작성했습니다.[13] 윈도우에서는 이런 현상이 덜 나타납니다. 해커들이 윈도우를 사용하지 않기 때문입니다. 소프트웨어를 잘 작성하는 사람들은 지금은 리눅스(Linux)나 FreeBSD를 실행하는 경향이 있습니다.

우리는 데스크톱 소프트웨어를 만들기 위한 스타트업을 시작하지 않았을 것이라고 생각합니다. 데스크톱 소프트웨어는 윈도우에서 실행되어야 하는데, 윈도우용 소프트웨어를 만들기 전에 윈도우를 사용해야 했기 때문입니다. 웹은 윈도우를 우회하여 유닉스(Unix)에서 실행되는 소프트웨어를 브라우저를 통해 사용자에게 직접 전달할 수 있게 해주었습니다. 이는 25년 전 PC의 등장과 많이 닮은 해방적인 전망입니다.

## 마이크로소프트 (Microsoft)

데스크톱 컴퓨터가 등장했을 때, IBM은 모두가 두려워하는 거인이었습니다. 지금은 상상하기 어렵겠지만, 그 느낌을 아주 잘 기억합니다. 이제 두려운 거인은 마이크로소프트이고, 저는 그들이 자신들이 직면한 위협에 대해 IBM만큼 눈이 멀지 않았다고 생각합니다. 결국 마이크로소프트는 IBM의 맹점을 의도적으로 파고들어 사업을 구축했습니다.

앞서 저희 어머니는 사실 데스크톱 컴퓨터가 필요 없다고 언급했습니다. 대부분의 사용자도 아마 그럴 것입니다. 그것은 마이크로소프트에게 문제이며, 그들도 알고 있습니다. 애플리케이션이 원격 서버에서 실행된다면, 아무도 윈도우를 필요로 하지 않습니다. 마이크로소프트는 무엇을 할까요? 그들은 데스크톱에 대한 통제력을 사용하여 이러한 새로운 세대의 소프트웨어를 막거나 제한할 수 있을까요?

제 추측으로는 마이크로소프트가 운영체제가 그들이 통제하는 서버와 함께 작동하는 일종의 서버/데스크톱 하이브리드를 개발할 것이라는 것입니다. 최소한 파일은 그것을 원하는 사용자를 위해 중앙에서 이용 가능할 것입니다. 마이크로소프트가 서버에서 연산을 수행하고 클라이언트로는 브라우저만 사용하는 극단적인 방식까지는 가지 않을 것이라고 예상합니다. 만약 클라이언트로 브라우저만 필요하다면, 클라이언트에 마이크로소프트가 필요 없고, 마이크로소프트가 클라이언트를 통제하지 못한다면, 사용자들을 그들의 서버 기반 애플리케이션으로 유도할 수 없을 것입니다.

마이크로소프트가 요술 램프의 요정을 병에 가두는 데 어려움을 겪을 것이라고 생각합니다. 그들이 모든 클라이언트를 통제하기에는 너무나 다양한 종류의 클라이언트가 있을 것입니다. 그리고 마이크로소프트의 애플리케이션이 일부 클라이언트에서만 작동한다면, 경쟁업체들은 어떤 클라이언트에서도 작동하는 애플리케이션을 제공함으로써 그들을 능가할 수 있을 것입니다.[14]

웹 기반 애플리케이션의 세상에서는 마이크로소프트가 자동으로 설 자리가 없습니다. 그들이 설 자리를 만들 수는 있겠지만, 데스크톱 애플리케이션의 세상을 지배했던 것처럼 이 새로운 세상을 지배하지는 못할 것이라고 생각합니다.

경쟁사가 그들을 넘어뜨리기보다는 그들 스스로 넘어질 것입니다. 웹 기반 소프트웨어의 부상과 함께 그들은 기술적인 문제뿐만 아니라 그들 자신의 희망적인 사고방식에도 직면하게 될 것입니다. 그들이 해야 할 일은 기존 사업을 잠식하는 것인데, 저는 그들이 그것에 직면하는 것을 보지 못합니다. 그들을 여기까지 이끌어온 바로 그 단일 목표 지향성이 이제 그들에게 불리하게 작용할 것입니다.

IBM은 정확히 같은 상황에 있었고, 이를 극복하지 못했습니다. IBM은 그들의 현금 창출원인 메인프레임 컴퓨팅을 위협하는 것에 대해 양가적인 감정을 가지고 있었기 때문에 마이크로컴퓨터 사업에 늦고 미지근하게 진입했습니다. 마이크로소프트도 마찬가지로 데스크톱을 구하려는 욕구 때문에 방해를 받을 것입니다. 현금 창출원은 등 뒤에 짊어진 정말 무거운 짐이 될 수 있습니다.

제가 서버 기반 애플리케이션을 아무도 지배하지 않을 것이라고 말하는 것은 아닙니다. 아마 언젠가는 누군가 지배할 것입니다. 하지만 마이크로컴퓨터의 초기 시절과 마찬가지로 오랫동안 즐거운 혼란의 시기가 있을 것이라고 생각합니다. 그때는 스타트업에게 좋은 시기였습니다. 많은 소규모 회사들이 번성했고, 멋진 것들을 만들면서 그렇게 했습니다.

## 스타트업이지만 더 그렇다 (Startups but More So)

고전적인 스타트업은 빠르고 비공식적이며, 적은 인력과 적은 돈으로 운영됩니다. 그 소수의 사람들은 매우 열심히 일하고, 기술은 그들이 내리는 결정의 효과를 증폭시킵니다. 그들이 승리하면 크게 승리합니다.

웹 기반 애플리케이션을 작성하는 스타트업에서는 스타트업과 관련된 모든 것이 극단으로 치닫습니다. 훨씬 적은 인력과 훨씬 적은 돈으로 제품을 작성하고 출시할 수 있습니다. 훨씬 더 빨라야 하며, 더 비공식적인 것을 용인할 수 있습니다. 말 그대로 아파트 거실에 앉은 세 명의 친구와 ISP에 입주한 서버로 제품을 출시할 수 있습니다. 우리는 그렇게 했습니다.

시간이 지남에 따라 팀은 더 작고, 더 빠르고, 더 비공식적으로 변했습니다. 1960년대에는 소프트웨어 개발이 뿔테안경을 쓰고 좁은 검은색 넥타이를 맨 남자들이 방에 가득 앉아 IBM 코딩 양식에 하루에 열 줄의 코드를 부지런히 작성하는 것을 의미했습니다. 1980년대에는 사무실에 청바지를 입고 vt100 터미널에 타이핑하는 8~10명의 팀이었습니다. 이제는 거실에 노트북을 들고 앉은 두어 명의 친구들입니다. (그리고 청바지가 비공식성의 끝이 아니라는 것이 밝혀졌습니다.)

스타트업은 스트레스를 많이 받는데, 불행히도 웹 기반 애플리케이션에서는 이것도 극단으로 치닫습니다. 특히 초창기에 많은 소프트웨어 회사들은 개발자들이 책상 밑에서 잠을 자고 하는 기간을 가졌습니다. 웹 기반 소프트웨어의 놀라운 점은 이것이 기본값이 되는 것을 막을 수 있는 것이 아무것도 없다는 것입니다. 책상 밑에서 자는 이야기들은 보통 이렇게 끝납니다. "마침내 출시했고, 우리는 모두 집에 가서 일주일 동안 잠을 잤다." 웹 기반 소프트웨어는 결코 출시되지 않습니다. 원하는 만큼 16시간씩 일할 수 있습니다. 그리고 당신이 할 수 있기 때문에, 그리고 경쟁사도 할 수 있기 때문에, 그렇게 하도록 강요당하는 경향이 있습니다. 당신이 할 수 있으므로, 당신은 해야 합니다. 이것은 파킨슨 법칙(Parkinson's Law)이 거꾸로 작용하는 것입니다.

가장 나쁜 것은 근무 시간이 아니라 책임입니다. 프로그래머와 시스템 관리자는 전통적으로 각자의 걱정거리가 있습니다. 프로그래머는 버그에 대해 걱정하고, 시스템 관리자는 인프라에 대해 걱정합니다. 프로그래머는 하루 종일 소스 코드에 파묻혀 지낼 수 있지만, 어느 시점에는 집에 가서 잊을 수 있습니다. 시스템 관리자는 일을 완전히 떨쳐버릴 수 없지만, 새벽 4시에 호출을 받을 때 보통 매우 복잡한 일을 해야 하는 것은 아닙니다.

웹 기반 애플리케이션에서는 이 두 가지 종류의 스트레스가 결합됩니다. 프로그래머는 시스템 관리자가 되지만, 일반적으로 직업을 견딜 수 있게 해주는 명확하게 정의된 한계가 없습니다.

비아웹에서는 처음 6개월 동안 소프트웨어만 작성했습니다. 우리는 초기 스타트업의 일반적인 긴 시간을 일했습니다. 데스크톱 소프트웨어 회사에서는 이 부분이 열심히 일하는 부분이었겠지만, 사용자들을 서버로 맞이했던 다음 단계에 비하면 휴가처럼 느껴졌습니다. 야후에 비아웹을 매각한 두 번째로 큰 이점(돈 다음으로)은 모든 것의 궁극적인 책임을 대기업의 어깨에 넘길 수 있었다는 것입니다.

데스크톱 소프트웨어는 사용자들을 시스템 관리자로 만들었습니다. 웹 기반 소프트웨어는 프로그래머들을 그렇게 만듭니다. 전체 스트레스는 줄어들지만, 프로그래머들에게는 더 많습니다. 그것이 반드시 나쁜 소식은 아닙니다. 대기업과 경쟁하는 스타트업이라면 좋은 소식입니다.[15] 웹 기반 애플리케이션은 경쟁사보다 더 많은 일을 할 수 있는 직접적인 방법을 제공합니다. 어떤 스타트업도 더 많은 것을 요구하지 않습니다.

## 딱 좋은 정도 (Just Good Enough)

웹 기반 애플리케이션을 작성하는 것을 주저하게 만드는 한 가지는 UI(User Interface)로서 웹 페이지의 미숙함일 수 있습니다. 그것은 인정하는 문제점입니다. HTML과 HTTP에 정말로 추가하고 싶었던 몇 가지가 있었습니다. 하지만 중요한 것은 웹 페이지가 딱 좋은 정도라는 것입니다.

여기서 초기 마이크로컴퓨터와 유사점이 있습니다. 그 기계들의 프로세서는 실제로는 컴퓨터의 CPU로 의도된 것이 아니었습니다. 신호등과 같은 곳에 사용하도록 설계되었습니다. 하지만 알테어(Altair)를 설계한 에드 로버츠(Ed Roberts)와 같은 사람들은 그것들이 딱 좋은 정도라는 것을 깨달았습니다. 이러한 칩 중 하나를 메모리(최초의 알테어는 256바이트)와 전면 패널 스위치와 결합하면 작동하는 컴퓨터를 가질 수 있었습니다. 자신만의 컴퓨터를 가질 수 있다는 것은 너무나 흥미로워서, 아무리 제한적이라도 그것을 사고 싶어 하는 사람들이 많았습니다.

웹 페이지는 애플리케이션의 UI로 설계되지 않았지만, 딱 좋은 정도입니다. 그리고 상당수의 사용자에게는 어떤 브라우저에서도 사용할 수 있는 소프트웨어가 UI의 어색함을 상쇄하고도 남을 만큼의 충분한 이점을 제공할 것입니다. HTML을 사용하여 가장 보기 좋은 스프레드시트를 작성할 수는 없을지라도, 특별한 클라이언트 소프트웨어 없이 여러 사람이 다른 위치에서 동시에 사용할 수 있거나, 실시간 데이터 피드(live data feeds)를 통합할 수 있거나, 특정 조건이 트리거(trigger)될 때 호출을 보낼 수 있는 스프레드시트를 작성할 수 있습니다. 더 중요한 것은 아직 이름도 없는 새로운 종류의 애플리케이션을 작성할 수 있다는 것입니다. 비지캘크는 단지 메인프레임 애플리케이션의 마이크로컴퓨터 버전이 아니었습니다. 그것은 새로운 유형의 애플리케이션이었습니다.

물론 서버 기반 애플리케이션이 반드시 웹 기반일 필요는 없습니다. 다른 종류의 클라이언트를 가질 수도 있습니다. 하지만 그것은 좋지 않은 생각이라고 꽤 확신합니다. 모든 사람이 클라이언트를 설치할 것이라고 가정할 수 있다면 매우 편리할 것입니다. 너무 편리해서 모두가 설치할 것이라고 쉽게 스스로를 납득시킬 수 있을 것입니다. 하지만 그들이 설치하지 않으면 당신은 망합니다. 웹 기반 소프트웨어는 클라이언트에 대해 아무것도 가정하지 않기 때문에 웹이 작동하는 모든 곳에서 작동할 것입니다. 이는 이미 큰 이점이며, 새로운 웹 장치가 확산될수록 그 이점은 커질 것입니다. 사용자들은 소프트웨어가 그냥 작동하기 때문에 당신을 좋아할 것이고, 당신은 새로운 클라이언트마다 소프트웨어를 조정할 필요가 없기 때문에 삶이 더 쉬워질 것입니다.[16]

저는 웹의 진화를 누구 못지않게 면밀히 관찰했다고 생각하지만, 클라이언트에 무슨 일이 일어날지 예측할 수는 없습니다. 수렴(convergence)이 아마 오겠지만, 어디에서 올까요? 저는 승자를 선택할 수 없습니다. 한 가지 예측할 수 있는 것은 AOL과 마이크로소프트 간의 갈등입니다. 마이크로소프트의 .NET이 무엇이든 간에, 그것은 아마도 데스크톱을 서버에 연결하는 것을 포함할 것입니다. AOL이 맞서 싸우지 않는다면, 그들은 밀려나거나 마이크로소프트 클라이언트와 서버 소프트웨어 사이의 파이프(pipe)로 전락할 것입니다. 마이크로소프트와 AOL이 클라이언트 전쟁에 돌입한다면, 양쪽 모두에서 확실히 작동하는 유일한 것은 웹 브라우징(browsing)일 것입니다. 즉, 웹 기반 애플리케이션만이 모든 곳에서 작동하는 유일한 종류가 될 것입니다.

이 모든 것이 어떻게 전개될까요? 저는 모릅니다. 그리고 웹 기반 애플리케이션에 투자한다면 알 필요도 없습니다. 아무도 브라우징을 방해하지 않고는 그것을 막을 수 없습니다. 웹이 소프트웨어를 제공하는 유일한 방법은 아닐지라도, 지금 작동하며 오랫동안 계속 작동할 것입니다. 웹 기반 애플리케이션은 개발 비용이 저렴하고, 아무리 작은 스타트업이라도 쉽게 제공할 수 있습니다. 많은 노력이 필요하고 특히 스트레스가 많은 종류이지만, 그것은 스타트업에게 더 나은 기회를 제공할 뿐입니다.

## 왜 안 돼? (Why Not?)

E.B. 화이트(E. B. White)는 농부 친구로부터 많은 전기 울타리가 실제로 전류가 흐르지 않는다는 사실을 알고 즐거워했습니다. 소들은 분명히 그것을 피하는 법을 배우고, 그 후에는 전류가 필요 없다는 것입니다. 그는 "일어나라, 소들이여! 폭군들이 코를 골고 있을 때 자유를 쟁취하라!"고 썼습니다.

만약 당신이 언젠가 스타트업을 시작할 생각이었던 해커라면, 아마도 두 가지가 당신을 막고 있을 것입니다. 하나는 사업에 대해 아무것도 모른다는 것이고, 다른 하나는 경쟁이 두렵다는 것입니다. 이 울타리들 중 어느 것에도 전류가 흐르지 않습니다.

사업에 대해 알아야 할 것은 두 가지뿐입니다. 사용자들이 사랑할 만한 것을 만들고, 지출보다 더 많이 버는 것입니다. 이 두 가지를 잘 해낸다면 대부분의 스타트업보다 앞설 것입니다. 나머지는 진행하면서 알아낼 수 있습니다.

처음에는 지출보다 더 많이 벌지 못할 수도 있지만, 그 격차가 충분히 빠르게 줄어들면 괜찮을 것입니다. 자금 부족 상태로 시작하면 적어도 절약하는 습관을 기르게 될 것입니다. 적게 쓸수록 더 많이 버기가 쉽습니다. 다행히 웹 기반 애플리케이션을 출시하는 것은 매우 저렴할 수 있습니다. 우리는 1만 달러 미만으로 출시했으며, 오늘날에는 훨씬 더 저렴할 것입니다. 우리는 서버에 수천 달러를 지출해야 했고, SSL을 얻기 위해 또 수천 달러를 지출해야 했습니다. (당시 SSL 소프트웨어를 판매하는 유일한 회사는 넷스케이프였습니다.) 이제 훨씬 더 강력한 서버를 SSL을 포함하여 우리가 대역폭(bandwidth)에 지불했던 것보다 적은 비용으로 대여할 수 있습니다. 이제 멋진 사무실 의자 값보다 적은 비용으로 웹 기반 애플리케이션을 출시할 수 있습니다.

사용자들이 사랑할 만한 것을 만드는 방법에 대한 일반적인 팁을 알려드리겠습니다. 먼저 스스로 사용하고 싶은 깨끗하고 간단한 것을 만드는 것부터 시작하세요. 버전 1.0을 빠르게 출시한 다음, 사용자의 의견을 주의 깊게 들으면서 소프트웨어를 계속 개선하세요. 고객은 항상 옳지만, 다른 고객은 다른 것에 대해 옳습니다. 가장 미숙한 사용자들은 무엇을 단순화하고 명확히 해야 하는지를 보여주고, 가장 숙련된 사용자들은 어떤 기능을 추가해야 하는지를 알려줍니다. 소프트웨어가 가장 좋을 때는 쉬울 때이지만, 이를 위한 방법은 기본 설정을 올바르게 하는 것이지 사용자의 선택을 제한하는 것이 아닙니다. 경쟁사의 소프트웨어가 허접하다고 해서 안주하지 마세요. 당신의 소프트웨어를 비교해야 할 기준은 그것이 될 수 있는 것이지, 현재 경쟁사가 가지고 있는 것이 아닙니다. 당신의 소프트웨어를 항상 직접 사용하세요. 비아웹은 온라인 스토어 빌더였지만, 우리는 우리 자신의 사이트를 만드는 데도 사용했습니다.

직책 때문에 마케팅 담당자나 디자이너, 제품 관리자의 말을 듣지 마세요. 그들이 좋은 아이디어를 가지고 있다면 사용하되, 결정은 당신에게 달려 있습니다. 소프트웨어는 디자인을 이해하는 해커가 설계해야 하며, 소프트웨어에 대해 조금 아는 디자이너가 설계해서는 안 됩니다. 소프트웨어를 구현하는 것만큼 잘 설계할 수 없다면 스타트업을 시작하지 마세요.

이제 경쟁에 대해 이야기해 봅시다. 당신이 두려워하는 것은 당신과 같은 해커 그룹이 아니라, 사무실과 사업 계획, 영업 사원 등을 가진 실제 회사들이겠죠? 글쎄요, 그들은 당신보다 당신을 더 두려워하고, 그들이 옳습니다. 몇몇 해커가 사무실 공간을 빌리거나 영업 사원을 고용하는 방법을 알아내는 것이 어떤 규모의 회사라도 소프트웨어를 작성하는 것보다 훨씬 쉽습니다. 저는 양쪽 모두를 경험했고, 알고 있습니다. 비아웹이 야후에 인수되었을 때, 저는 갑자기 대기업에서 일하게 되었고, 허리까지 오는 물속을 달려가는 것 같았습니다.

야후를 폄하하려는 것은 아닙니다. 그들에게는 훌륭한 해커들도 있었고, 최고 경영진은 정말 유능한 사람들이었습니다. 대기업치고는 예외적이었습니다. 하지만 그들은 여전히 작은 스타트업의 생산성의 10분의 1 정도밖에 되지 않았습니다. 어떤 대기업도 그것보다 훨씬 잘할 수는 없습니다. 마이크로소프트가 무서운 점은 그 거대한 회사임에도 불구하고 소프트웨어를 개발할 수 있다는 것입니다. 그들은 마치 걸어 다닐 수 있는 산과 같습니다.

겁먹지 마세요. 마이크로소프트가 할 수 없는 만큼 당신이 할 수 있는 것도 많고, 당신이 할 수 없는 만큼 마이크로소프트가 할 수 있는 것도 많습니다. 그리고 아무도 당신을 막을 수 없습니다. 웹 기반 애플리케이션을 개발하기 위해 누구의 허락도 받을 필요가 없습니다. 라이선스 계약을 하거나, 소매점에서 매대 공간을 확보하거나, 운영체제에 당신의 애플리케이션이 번들되도록 굽실거릴 필요도 없습니다. 소프트웨어를 브라우저에 직접 전달할 수 있고, 아무도 당신과 잠재 사용자 사이에 끼어들 수 없습니다. 웹 브라우징을 막지 않고서는 말입니다.

믿지 않으시겠지만, 저는 약속합니다. 마이크로소프트는 당신을 두려워하고 있습니다. 안일한 중간 관리자들은 아닐지 몰라도, 빌 게이츠는 그렇습니다. 1975년, 소프트웨어를 제공하는 새로운 방식이 등장했을 때, 그는 한때 당신과 같았기 때문입니다.

**참고 (Notes)**

[1] 많은 돈이 서비스에 있다는 것을 깨달은 경량 클라이언트(lightweight client)를 만드는 회사들은 보통 하드웨어와 온라인 서비스(online service)를 결합하려고 시도했습니다. 이러한 접근 방식은 잘 작동하지 않았습니다. 부분적으로는 가전제품을 만드는 회사와 온라인 서비스를 운영하는 회사가 서로 다른 종류의 회사여야 했기 때문이고, 부분적으로는 사용자들이 그 아이디어를 싫어했기 때문입니다. 질레트(Gillette)에게는 면도기를 공짜로 주고 면도날로 돈을 버는 것이 통할지 모르지만, 면도기는 웹 터미널보다 훨씬 작은 약속입니다. 휴대폰 핸드셋 제조업체들은 서비스 수익까지 얻으려 하지 않고 하드웨어만 판매하는 것에 만족합니다. 인터넷 클라이언트도 아마 그 모델을 따라야 할 것입니다. 만약 누군가 웹 브라우저가 내장된 멋진 작은 상자를 판매하여 어떤 ISP를 통해서든 연결할 수 있게 한다면, 이 나라의 모든 기술 공포증 환자들이 하나씩 구매할 것입니다.

[2] 보안은 항상 어떤 설계 결정보다도 실수하지 않는 것에 더 의존하지만, 서버 기반 소프트웨어의 특성은 개발자들이 실수하지 않는 것에 더 많은 주의를 기울이게 만들 것입니다. 서버 침해는 너무나 큰 피해를 야기할 수 있으므로 ASP(사업을 계속하고 싶다면)는 보안에 신중할 가능성이 높습니다.

[3] 1995년, 우리가 비아웹을 시작했을 때, 자바 애플릿(Java applet)은 모두가 서버 기반 애플리케이션을 개발하는 데 사용할 기술이라고 예상되었습니다. 애플릿은 우리에게 구식 아이디어처럼 보였습니다. 클라이언트에서 실행하기 위해 프로그램을 다운로드한다고요? 그냥 모든 것을 서버에서 실행하는 것이 더 간단했습니다. 우리는 애플릿에 시간을 거의 낭비하지 않았지만, 수많은 다른 스타트업들이 이 타르 웅덩이에 유인되었을 것입니다. 살아남은 곳은 거의 없을 것이고, 마이크로소프트는 익스플로러(Explorer)의 최신 버전에서 자바를 버리는 일도 저지르지 못했을 것입니다.

[4] 이 요점은 트레버 블랙웰(Trevor Blackwell) 덕분인데, 그는 "소프트웨어 작성 비용은 크기에 비례하여 선형적으로 증가하는 것이 아니라 그 이상으로 증가합니다. 아마도 이는 주로 오래된 버그를 수정하는 데서 오는 것이며, 모든 버그가 빨리 발견되면 비용은 더 선형적일 수 있습니다"라고 덧붙였습니다.

[5] 가장 찾기 어려운 종류의 버그는 한 버그가 다른 버그를 보완하는 복합 버그의 변형일 수 있습니다. 한 버그를 수정하면 다른 버그가 드러납니다. 하지만 수정이 잘못된 것처럼 보일 것입니다. 왜냐하면 그것이 마지막으로 변경된 것이었기 때문입니다.

[6] 비아웹 내에서 우리는 한때 우리 소프트웨어의 최악의 점을 설명하는 콘테스트를 열었습니다. 두 명의 고객 지원 담당자가 1등을 차지했는데, 아직도 그 내용을 떠올리면 몸서리쳐집니다. 우리는 두 가지 문제를 즉시 해결했습니다.

[7] 로버트 모리스(Robert Morris)는 쇼핑객들이 주문하는 데 사용되는 주문 시스템을 작성했습니다. 트레버 블랙웰(Trevor Blackwell)은 상인들이 주문을 검색하고, 통계를 보고, 도메인 이름 등을 구성하는 데 사용되는 이미지 생성기와 관리자를 작성했습니다. 저는 상인들이 자신의 사이트를 만드는 데 사용되는 편집기를 작성했습니다. 주문 시스템과 이미지 생성기는 C와 C++로 작성되었고, 관리자는 주로 펄(Perl)로, 편집기는 리스프(Lisp)로 작성되었습니다.

[8] 가격 차별(Price discrimination)은 너무나 만연하여 (소매업자가 구매력 때문에 가격을 낮출 수 있다고 주장하는 것을 얼마나 자주 들었는가?) 미국에서는 1936년 로빈슨-패트먼 법(Robinson-Patman Act)에 의해 불법화되었다는 사실에 놀랐습니다. 이 법은 강력하게 시행되지 않는 것으로 보입니다.

[9] 나오미 클라인(Naomi Klein)은 『노 로고(No Logo)』에서 "도시 청년층"이 선호하는 의류 브랜드는 좀도둑질을 막기 위해 너무 열심히 노력하지 않는다고 말합니다. 왜냐하면 그들의 타겟 시장에서는 좀도둑들이 패션 리더(fashion leader)이기도 하기 때문입니다.

[10] 기업들은 무엇을 아웃소싱하고 무엇을 아웃소싱하지 않을지 종종 고민합니다. 한 가지 가능한 답은 다음과 같습니다. 경쟁 압력에 직접 노출되지 않는 모든 직무는 아웃소싱하세요. 그렇게 하면 경쟁 압력에 노출될 것이기 때문입니다.

[11] 두 사람은 댄 브리클린(Dan Bricklin)과 밥 프랭크스턴(Bob Frankston)이었습니다. 댄은 며칠 만에 베이직(Basic)으로 프로토타입을 작성했고, 그 다음 1년 동안 함께 (주로 밤에) 6502 머신 언어(machine language)로 작성된 더 강력한 버전을 만들었습니다. 댄은 당시 하버드 경영대학원(Harvard Business School)에 있었고 밥은 명목상 소프트웨어 작성 직업이 있었습니다. 밥은 "사업을 하는 데 큰 위험은 없었다. 실패하면 실패하는 것이다. 별거 아니다"라고 썼습니다.

[12] 제가 말하는 것만큼 그렇게 쉽지는 않습니다. 입소문이 퍼지는 데는 고통스러울 정도로 오랜 시간이 걸렸고, 월 1만 6천 달러를 주고 홍보 회사(분명히 업계 최고였지만)를 고용하기 전까지는 많은 언론 보도를 받지 못했습니다. 그러나 유일한 중요한 채널이 우리 자신의 웹사이트였다는 것은 사실이었습니다.

[13] 맥이 그렇게 훌륭했다면 왜 실패했을까요? 다시 말하지만, 비용 때문이었습니다. 마이크로소프트는 소프트웨어 사업에 집중했고, 애플 하드웨어에 값싼 부품 공급업체들의 무리를 풀어놓았습니다. 또한, 중요한 시기에 양복쟁이들(suits)이 장악한 것도 도움이 되지 않았습니다.

[14] 웹 기반 애플리케이션에 도움이 되고, 다음 세대 소프트웨어가 마이크로소프트에 의해 가려지는 것을 막는 한 가지는 훌륭한 오픈 소스 브라우저일 것입니다. 모질라(Mozilla)는 오픈 소스이지만 너무 오랫동안 기업 소프트웨어였기 때문에 어려움을 겪은 것 같습니다. 작고 빠른 브라우저가 활발하게 유지된다면 그 자체로 훌륭한 일이 될 것이고, 아마도 기업들이 작은 웹 기기를 만들도록 장려할 것입니다.

무엇보다도 적절한 오픈 소스 브라우저는 HTTP와 HTML이 계속 진화하도록 만들 것입니다(예: Perl처럼). 링크를 선택하는 것과 따라가는 것을 구별할 수 있다면 웹 기반 애플리케이션에 큰 도움이 될 것입니다. 이를 위해 필요한 것은 HTTP의 사소한 개선, 즉 요청에서 여러 URL을 허용하는 것뿐입니다. 계단식 메뉴도 좋을 것입니다.

세상을 바꾸고 싶다면, 새로운 모자이크(Mosaic)를 만드세요. 너무 늦었다고 생각하시나요? 1998년에 많은 사람들이 새로운 검색 엔진을 출시하기에는 너무 늦었다고 생각했지만, 구글(Google)은 그들이 틀렸음을 증명했습니다. 현재 옵션이 충분히 나쁘다면 항상 새로운 것을 위한 공간은 있습니다. 모든 무료 운영체제에서 먼저 작동하는지 확인하세요. 새로운 것은 사용자와 함께 시작됩니다.

[15] 개인적인 경험으로 누구보다 이 문제에 대해 잘 알고 있을 트레버 블랙웰(Trevor Blackwell)은 다음과 같이 썼습니다.
"저는 서버 기반 소프트웨어가 프로그래머들에게 너무 힘들기 때문에 대기업으로부터 근본적인 경제적 전환을 야기한다고 더 나아가 말할 것입니다. 이는 프로그래머들에게 그들 자신의 회사일 때만 기꺼이 제공할 의지가 있는 종류의 강렬함과 헌신을 요구합니다. 소프트웨어 회사들은 너무 까다롭지 않은 환경에서 일할 숙련된 사람들을 고용할 수 있고, 고난을 견딜 비숙련된 사람들을 고용할 수 있지만, 매우 숙련된 사람들이 열심히 일하도록 고용할 수는 없습니다. 자본이 더 이상 필요하지 않으므로, 대기업은 내놓을 것이 거의 없습니다."

[16] 이 에세이의 원래 버전에서 저는 자바스크립트(Javascript)를 피하도록 조언했습니다. 2001년에는 좋은 계획이었지만, 자바스크립트는 이제 작동합니다.

이 논문의 초고를 읽어준 사라 할린(Sarah Harlin), 트레버 블랙웰(Trevor Blackwell), 로버트 모리스(Robert Morris), 에릭 레이먼드(Eric Raymond), 켄 앤더슨(Ken Anderson), 댄 기핀(Dan Giffin)에게 감사드립니다. 비지캘크에 대한 정보를 제공해준 댄 브리클린(Dan Bricklin)과 밥 프랭크스턴(Bob Frankston)에게도 감사드립니다. 그리고 BBN에서 강연에 초청해준 켄 앤더슨에게 다시 한번 감사드립니다.

이 에세이와 14개의 다른 에세이를 『해커스 앤 페인터스(Hackers & Painters)』에서 찾을 수 있습니다.