# 한 사람이 프로그램을 머릿속에 담는 것 (Holding a Program in One's Head)

2007년 8월

열정적으로 자신의 코드에 몰두하는 뛰어난 프로그래머는 자신이 다루는 문제를 머릿속에 담아두는 수학자와 같은 방식으로 프로그램을 다룰 수 있습니다. 수학자들은 학교에서 배우는 방식대로 종이에 문제를 풀어 답을 찾지 않습니다. 그들은 머릿속에서 더 많은 작업을 합니다. 자신이 자라온 집의 기억을 떠올리듯, 문제 영역을 충분히 이해하여 그 주위를 거닐 수 있을 정도가 되기를 바랍니다. 최고의 프로그래밍은 이와 같습니다. 프로그램 전체를 머릿속에 담고 마음대로 조작할 수 있습니다.

이것은 프로젝트 초기에 특히 가치가 있습니다. 초기에는 자신이 하고 있는 일을 변경할 수 있는 능력이 가장 중요하기 때문입니다. 단순히 문제를 다른 방식으로 해결하는 것이 아니라, 자신이 해결하고 있는 문제 자체를 바꾸는 것입니다.

당신의 코드는 당신이 탐구하고 있는 문제에 대한 당신의 이해입니다. 따라서 코드를 머릿속에 담고 있을 때 비로소 문제를 진정으로 이해하게 되는 것입니다.

프로그램을 머릿속에 담는 것은 쉽지 않습니다. 프로젝트를 몇 달 동안 떠나 있다가 다시 돌아오면, 제대로 이해하는 데 며칠이 걸릴 수도 있습니다. 심지어 적극적으로 프로그램에 참여하고 있을 때조차도, 매일 작업을 시작할 때 머릿속에 로드하는 데 반나절이 걸릴 수 있습니다. 이것은 가장 좋은 경우입니다. 일반적인 프로그래머들은 일반적인 사무 환경에서 이런 모드에 전혀 들어가지 못합니다. 더 극적으로 표현하자면, 일반적인 프로그래머들은 자신이 해결하고 있는 문제를 결코 제대로 이해하지 못합니다.

최고의 프로그래머조차도 항상 자신이 작업 중인 프로그램 전체를 머릿속에 담고 있는 것은 아닙니다. 하지만 이를 돕기 위해 할 수 있는 일들이 있습니다.

방해 요소를 피하십시오.
방해 요소는 여러 유형의 작업에 좋지 않지만, 프로그래밍에는 특히 해롭습니다. 프로그래머는 처리할 수 있는 세부 정보의 한계점에서 작동하는 경향이 있기 때문입니다.
방해 요소의 위험은 그 길이가 아니라 뇌를 얼마나 혼란스럽게 하는지에 따라 결정됩니다. 프로그래머는 사무실을 떠나 샌드위치를 사러 갈 수 있지만, 코드를 머릿속에서 잃지 않습니다. 하지만 잘못된 종류의 방해는 30초 만에 당신의 뇌를 지워버릴 수 있습니다.
이상하게도, 예정된 방해가 예정되지 않은 방해보다 더 나쁠 수 있습니다. 만약 한 시간 뒤에 회의가 있다는 것을 안다면, 어려운 작업에 착수조차 하지 않을 것입니다.

긴 시간 동안 작업하십시오.
프로그램 작업을 시작할 때마다 고정된 비용이 발생하므로, 짧은 시간을 여러 번 갖는 것보다 긴 시간을 몇 번 갖는 것이 더 효율적입니다. 물론 너무 지쳐서 멍청해지는 시점이 올 것입니다. 이것은 사람마다 다릅니다. 36시간 연속으로 코딩했다는 사람들의 이야기도 들었지만, 제가 관리할 수 있었던 최대치는 약 18시간이었고, 저는 12시간을 넘지 않는 덩어리로 작업할 때 가장 잘합니다.
최적점은 물리적으로 견딜 수 있는 한계가 아닙니다. 프로젝트를 분할하는 데는 비용뿐만 아니라 이점도 있습니다. 때로는 휴식 후 문제로 돌아갔을 때 무의식 속에 답이 기다리고 있음을 발견하기도 합니다.

간결한 언어를 사용하십시오.
더 강력한 프로그래밍 언어는 프로그램을 더 짧게 만듭니다. 그리고 프로그래머는 프로그램을 적어도 부분적으로는 자신이 작성하는 언어로 생각하는 것 같습니다. 언어가 간결할수록 프로그램은 더 짧아지고, 머릿속에 로드하고 유지하기가 더 쉬워집니다.
바텀업 프로그래밍(bottom-up programming)이라는 스타일을 사용하여 강력한 언어의 효과를 증폭시킬 수 있습니다. 이 스타일은 프로그램을 여러 계층으로 작성하며, 하위 계층은 상위 계층을 위한 프로그래밍 언어 역할을 합니다. 제대로 한다면 최상위 계층만 머릿속에 담아두면 됩니다.

프로그램을 계속 다시 작성하십시오.
프로그램을 다시 작성하면 종종 더 깔끔한 설계를 얻을 수 있습니다. 하지만 그렇지 않더라도 이점은 있습니다. 프로그램을 다시 작성하려면 완전히 이해해야 하므로, 머릿속에 프로그램을 담는 것보다 더 좋은 방법은 없습니다.
읽기 쉬운 코드를 작성하십시오.
모든 프로그래머는 읽기 쉬운 코드를 작성하는 것이 좋다는 것을 알고 있습니다. 하지만 당신 자신이 가장 중요한 독자입니다. 특히 처음에는 프로토타입(prototype)이 자신과의 대화입니다. 그리고 자신을 위해 글을 쓸 때는 우선순위가 다릅니다. 다른 사람을 위해 글을 쓴다면 코드를 너무 밀집시켜서는 안 됩니다. 프로그램의 일부는 마치 입문 교과서처럼 내용을 펼쳐 놓는 것이 읽기 가장 쉬울 수 있습니다. 반면, 머릿속에 쉽게 다시 로드하기 위해 코드를 작성하는 경우 간결함을 추구하는 것이 가장 좋을 수 있습니다.

소규모 그룹으로 작업하십시오.
머릿속으로 프로그램을 조작할 때, 당신의 시야는 자신이 소유한 코드의 가장자리에서 멈추는 경향이 있습니다. 당신이 잘 이해하지 못하는 다른 부분들, 더 중요하게는 마음대로 변경할 수 없는 부분들 말입니다. 따라서 프로그래머의 수가 적을수록 프로젝트는 더 완전히 변형될 수 있습니다. 만약 처음처럼 프로그래머가 단 한 명뿐이라면, 포괄적인 재설계를 할 수 있습니다.

여러 사람이 같은 코드를 편집하지 않도록 하십시오.
다른 사람의 코드는 자신의 코드만큼 잘 이해할 수 없습니다. 아무리 철저히 읽었더라도, 단지 읽었을 뿐 직접 작성한 것은 아닙니다. 따라서 코드를 여러 저자가 작성했다면, 아무도 단일 저자만큼 잘 이해하지 못합니다.
물론 다른 사람들이 작업 중인 것을 안전하게 재설계할 수는 없습니다. 허락을 받아야 할 뿐만 아니라, 그런 생각을 스스로에게 허용조차 하지 않습니다. 여러 저자가 있는 코드를 재설계하는 것은 법을 바꾸는 것과 같고, 자신이 단독으로 제어하는 코드를 재설계하는 것은 모호한 이미지에 대한 다른 해석을 보는 것과 같습니다.
여러 사람을 프로젝트에 투입하고 싶다면, 그것을 구성 요소로 나누어 각 구성 요소를 한 사람에게 맡기십시오.

작게 시작하십시오.
프로그램은 익숙해질수록 머릿속에 담기 쉬워집니다. 완전히 탐구했다고 확신이 들면 일부를 블랙박스(black box)처럼 취급할 수 있습니다. 하지만 프로젝트를 처음 시작할 때는 모든 것을 봐야 합니다. 너무 큰 문제로 시작하면 결코 그것을 완전히 파악하지 못할 수도 있습니다. 따라서 크고 복잡한 프로그램을 작성해야 한다면, 시작하는 가장 좋은 방법은 사양(spec)을 작성하는 것이 아니라 문제의 일부를 해결하는 프로토타입을 작성하는 것일 수 있습니다. 계획의 장점이 무엇이든, 프로그램을 머릿속에 담을 수 있다는 이점 때문에 종종 무시되곤 합니다.

프로그래머들이 우연히 이 여덟 가지 사항을 모두 충족하는 경우가 놀랍도록 많습니다. 누군가 새로운 프로젝트에 대한 아이디어를 가지고 있지만, 공식적으로 승인되지 않았기 때문에 개인 시간을 활용해야 합니다. 이 시간은 방해가 없기 때문에 더 생산적이 됩니다. 새로운 프로젝트에 대한 열정에 힘입어 그는 많은 시간을 연속으로 작업합니다. 처음에는 "운영용(production)" 언어가 아니라 단순한 "스크립팅(scripting)" 언어를 사용하는데, 이는 사실 훨씬 더 강력합니다. 그는 프로그램을 여러 번 완전히 다시 작성하는데, 공식 프로젝트에서는 정당화되지 않겠지만 이것은 애정으로 하는 일이기에 완벽하게 만들고 싶어 합니다. 그리고 자신 외에는 아무도 보지 않을 것이므로, 자기 메모 외에는 어떤 주석도 생략합니다. 그는 어쩔 수 없이 소규모 그룹으로 작업하는데, 아직 아무에게도 아이디어를 말하지 않았거나, 너무 유망해 보이지 않아 다른 누구도 작업하도록 허용되지 않았기 때문입니다. 그룹이 있더라도, 너무 빨리 변경되기 때문에 여러 사람이 같은 코드를 편집할 수는 없습니다. 그리고 프로젝트는 처음에는 아이디어가 작았기 때문에 작게 시작됩니다. 단지 시도해보고 싶은 멋진 해킹(hack)이 있었을 뿐입니다.

더 놀라운 것은 공식적으로 승인된 프로젝트들이 이 모든 여덟 가지 사항을 잘못 관리하는 경우입니다. 사실, 대부분의 조직에서 소프트웨어가 어떻게 작성되는지를 보면, 마치 의도적으로 잘못된 일을 하도록 만든 것 같습니다. 어떤 의미에서는 그렇습니다. 조직의 정의하는 특징 중 하나는 개인을 상호 교체 가능한 부품으로 취급하는 것입니다. 이것은 전쟁을 싸우는 것과 같이 더 병렬화 가능한 작업에는 잘 작동합니다. 역사 대부분 동안 잘 훈련된 전문 군대는 아무리 용맹하더라도 개인 전사 군대를 이길 수 있었습니다. 하지만 아이디어를 갖는 것은 그다지 병렬화가 잘 되지 않습니다. 그리고 프로그램이란 바로 아이디어입니다.

조직이 개인의 천재성에 의존하는 아이디어를 싫어하는 것이 단순히 사실이 아니라, 그것은 동어 반복입니다. 조직이 그렇지 않다는 것은 조직의 정의의 일부입니다. 적어도 우리 현재의 조직 개념에서는 말입니다.

어쩌면 우리는 개인의 노력을 개인을 상호 교체 가능하게 만들 필요 없이 결합하는 새로운 종류의 조직을 정의할 수 있을지도 모릅니다. 시장이 그러한 조직 형태라고 주장할 수도 있지만, 시장을 퇴화된 사례, 즉 조직이 불가능할 때 기본적으로 얻게 되는 것으로 묘사하는 것이 더 정확할 수 있습니다.

아마도 우리가 할 수 있는 최선은 조직의 프로그래밍 부분을 나머지 부분과 다르게 작동하도록 만드는 것과 같은 일종의 해킹(hack)일 것입니다. 아마도 최적의 해결책은 대기업이 내부적으로 아이디어를 개발하려고 시도하지 않고 단순히 그것을 구매하는 것일 수 있습니다. 하지만 해결책이 무엇이 되든, 첫걸음은 문제가 있다는 것을 깨닫는 것입니다. "소프트웨어 회사"라는 문구 자체에 모순이 있습니다. 두 단어는 반대 방향으로 끌어당깁니다.

대규모 조직에 있는 뛰어난 프로그래머는 결국 조직과 충돌하게 될 것입니다. 왜냐하면 조직은 프로그래머들이 추구하는 것을 방지하도록 설계되었기 때문입니다.

뛰어난 프로그래머들은 어쨌든 많은 것을 해냅니다.
하지만 종종 그것은 그들을 고용하는 조직에 대한 거의 반란에 가까운 행위를 필요로 합니다. 아마도 프로그래머들의 행동 방식이 그들이 하는 일의 요구 사항에 의해 주도된다는 것을 더 많은 사람들이 이해한다면 도움이 될 것입니다. 다른 모든 의무를 무시하고, 먼저 스펙을 작성하는 대신 프로그래밍에 바로 뛰어들고, 이미 작동하는 코드를 다시 작성하는 등 긴 시간 동안 작업하는 것이 무책임해서가 아닙니다. 혼자 일하는 것을 선호하거나 문을 두드리는 사람들에게 으르렁거리는 것이 비사교적이어서가 아닙니다. 이 겉보기에 무작위적인 거슬리는 습관들의 집합에는 단 하나의 설명이 있습니다: 한 사람이 프로그램을 머릿속에 담는 것의 힘.

이것을 이해하는 것이 대규모 조직에 도움이 되든 안 되든, 그것은 확실히 경쟁자들에게 도움이 될 수 있습니다. 대기업의 가장 약한 지점은 개별 프로그래머가 위대한 일을 하도록 허용하지 않는다는 것입니다. 따라서 당신이 작은 스타트업이라면, 이곳이 그들을 공략할 지점입니다. 하나의 거대한 뇌 속에서 해결되어야 하는 종류의 문제에 도전하십시오.

이 글의 초안을 읽어준 Sam Altman, David Greenspan, Aaron Iba, Jessica Livingston, Robert Morris, Peter Norvig, Lisa Randall, Emmett Shear, Sergei Tsarev, Stephen Wolfram에게 감사합니다.