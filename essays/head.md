# 머릿속에 프로그램을 담는다는 것 (Holding a Program in One's Head)

2007년 8월

숙련된 프로그래머가 자신이 작성한 코드를 집중적으로 작업할 때는, 마치 수학자가 작업 중인 문제를 머릿속에 담는 방식과 유사하게 코드를 머릿속에 담을 수 있습니다. 수학자들은 학교에서 배우는 방식처럼 종이에 문제를 풀어나가며 답을 찾는 것이 아닙니다. 그들은 머릿속에서 더 많은 것을 해냅니다. 문제 공간을 충분히 이해하려고 노력하여, 마치 어릴 적 살던 집의 기억 속을 거닐 듯 그 공간을 자유롭게 돌아다닐 수 있게 됩니다. 프로그래밍도 가장 이상적인 경우엔 이와 같습니다. 전체 프로그램을 머릿속에 담고, 마음먹은 대로 조작할 수 있습니다.

이는 프로젝트 초기에 특히 중요합니다. 왜냐하면 초기에는 자신이 하고 있는 것을 바꿀 수 있는 능력이 가장 중요하기 때문입니다. 단순히 문제를 다른 방식으로 해결하는 것을 넘어, 해결하려는 문제 자체를 바꿀 수 있어야 합니다.

여러분의 코드는 여러분이 탐색하는 문제에 대한 이해를 담고 있습니다. 그러므로 코드를 머릿속에 담고 있을 때에야 비로소 문제를 진정으로 이해하게 됩니다.

프로그램을 머릿속에 담는 것은 쉽지 않습니다. 프로젝트를 몇 달간 손놓고 있다가 다시 돌아오면, 다시 제대로 이해하는 데 며칠이 걸릴 수 있습니다. 심지어 프로그램을 활발히 작업 중일 때도, 매일 작업을 시작할 때 머릿속에 로드하는 데 30분이 걸릴 수 있습니다. 이것은 가장 좋은 경우입니다. 일반적인 프로그래머들은 전형적인 사무실 환경에서 일하면서 이런 모드에 진입하지 못합니다. 더 극적으로 말하자면, 일반적인 프로그래머들은 전형적인 사무실 환경에서 일하면서 자신이 해결하는 문제를 결코 진정으로 이해하지 못합니다.

최고의 프로그래머들조차도 작업 중인 전체 프로그램을 항상 머릿속에 로드하고 있는 것은 아닙니다. 하지만 다음과 같은 도움이 되는 방법들이 있습니다.

**방해 요소를 피하세요.**
방해 요소는 여러 종류의 작업에 좋지 않지만, 프로그래머는 자신이 다룰 수 있는 세부 사항의 한계에서 작업하는 경향이 있기 때문에 프로그래밍에는 특히 나쁩니다.
방해의 위험은 그것이 얼마나 오래 지속되느냐가 아니라, 얼마나 뇌를 혼란스럽게 하느냐에 달려있습니다. 프로그래머는 사무실을 떠나 샌드위치를 사러 가는 것만으로는 머릿속의 코드를 잃지 않습니다. 하지만 잘못된 종류의 방해는 30초 안에 여러분의 뇌를 백지 상태로 만들 수 있습니다.
이상하게도, 예정된 방해는 예정되지 않은 방해보다 더 나쁠 수 있습니다. 한 시간 뒤에 회의가 있다는 것을 알면, 어려운 작업은 시작조차 하지 않게 됩니다.

**오랫동안 작업하세요.**
프로그램 작업을 시작할 때마다 고정된 비용이 발생하므로, 짧게 여러 번 작업하는 것보다 길게 몇 번 작업하는 것이 더 효율적입니다. 물론 피곤해서 머리가 잘 돌아가지 않는 시점이 올 것입니다. 이는 사람마다 다릅니다. 어떤 사람들은 36시간 동안 쉬지 않고 해킹했다고 들었지만, 제가 가장 오랫동안 할 수 있었던 것은 약 18시간 정도이며, 저는 12시간을 넘지 않는 덩어리로 작업할 때 가장 효율적입니다.
최적의 상태는 물리적으로 견딜 수 있는 한계가 아닙니다. 프로젝트를 중단하는 데는 비용뿐만 아니라 이점도 있습니다. 때로는 휴식 후에 문제로 돌아오면, 무의식중에 답이 기다리고 있다는 것을 발견하기도 합니다.

**간결한 언어를 사용하세요.**
더 강력한 프로그래밍 언어 (powerful programming languages)는 프로그램을 더 짧게 만듭니다. 그리고 프로그래머들은 프로그램을 적어도 부분적으로는 자신이 사용하는 언어로 생각하는 경향이 있습니다. 언어가 간결할수록 프로그램은 더 짧아지고, 머릿속에 로드하고 유지하기가 더 쉬워집니다.
하향식 프로그래밍 (bottom-up programming)이라는 스타일을 사용하면 강력한 언어의 효과를 극대화할 수 있습니다. 이는 프로그램을 여러 계층으로 작성하는 방식으로, 하위 계층은 상위 계층을 위한 프로그래밍 언어 역할을 합니다. 이 작업을 제대로 하면, 최상위 계층만 머릿속에 담고 있으면 됩니다.

**프로그램을 계속해서 다시 작성하세요.**
프로그램을 다시 작성하는 것은 종종 더 깔끔한 디자인을 가져옵니다. 하지만 그렇지 않더라도 장점이 있습니다. 프로그램을 다시 작성하려면 프로그램을 완전히 이해해야 하므로, 프로그램을 머릿속에 로드하는 데 이보다 더 좋은 방법은 없습니다.

**다시 읽기 쉬운 코드를 작성하세요.**
모든 프로그래머는 읽기 쉬운 코드를 작성하는 것이 좋다는 것을 알고 있습니다. 하지만 여러분 자신이 가장 중요한 독자입니다. 특히 초기 단계에서는 프로토타입 (prototype)은 자신과의 대화입니다. 그리고 자신을 위해 작성할 때는 우선순위가 다릅니다. 다른 사람들을 위해 작성하는 경우, 코드를 너무 밀집하게 만들고 싶지 않을 수 있습니다. 프로그램의 일부는 입문서처럼 내용을 펼쳐놓는 것이 가장 읽기 쉬울 수 있습니다. 반면에 코드를 머릿속에 쉽게 다시 로드할 수 있도록 작성하는 경우, 간결함 (brevity)을 추구하는 것이 가장 좋을 수 있습니다.

**소규모 그룹으로 작업하세요.**
프로그램을 머릿속에서 조작할 때, 시야는 자신이 소유한 코드의 가장자리에서 멈추는 경향이 있습니다. 다른 부분은 잘 이해하지 못하며, 더 중요하게는 함부로 다룰 수 없습니다. 따라서 프로그래머의 수가 적을수록 프로젝트는 더 완벽하게 변화할 수 있습니다. 처음에는 종종 그렇듯이 프로그래머가 한 명뿐이라면, 모든 것을 아우르는 재설계가 가능합니다.

**여러 사람이 같은 코드를 편집하지 마세요.**
여러분은 다른 사람의 코드를 자신의 코드만큼 잘 이해하지 못합니다. 아무리 철저히 읽었더라도, 그것은 단지 읽었을 뿐, 작성한 것이 아닙니다. 따라서 한 조각의 코드가 여러 저자에 의해 작성되었다면, 그 누구도 단일 저자가 했을 만큼 잘 이해하지 못합니다.
그리고 물론 다른 사람들이 작업 중인 것을 안전하게 재설계할 수도 없습니다. 단지 허락을 받아야 하기 때문만이 아닙니다. 그런 생각조차 스스로에게 허락하지 않습니다. 여러 저자가 있는 코드를 재설계하는 것은 법을 바꾸는 것과 같습니다. 자신만이 통제하는 코드를 재설계하는 것은 모호한 이미지의 다른 해석을 보는 것과 같습니다.
여러 사람을 프로젝트에 투입하고 싶다면, 프로젝트를 구성 요소로 나누고 각 구성 요소를 한 사람에게 할당하세요.

**작게 시작하세요.**
프로그램은 익숙해질수록 머릿속에 담기가 더 쉬워집니다. 일단 완전히 탐색했다고 확신하면 일부를 블랙박스 (black box)처럼 다룰 수 있습니다. 하지만 프로젝트를 처음 시작할 때는 모든 것을 봐야만 합니다. 너무 큰 문제로 시작하면, 결코 완전히 파악하지 못할 수도 있습니다. 따라서 크고 복잡한 프로그램을 작성해야 한다면, 가장 좋은 시작 방법은 사양서 (spec)를 작성하는 것이 아니라 문제의 하위 집합을 해결하는 프로토타입 (prototype)을 작성하는 것일 수 있습니다. 계획의 장점이 무엇이든 간에, 프로그램 전체를 머릿속에 담을 수 있는 장점에 의해 종종 상쇄됩니다.

프로그래머들이 우연히 이 여덟 가지 지점을 모두 충족시키는 경우가 놀랍도록 많습니다. 어떤 사람은 새로운 프로젝트 아이디어를 가지고 있지만, 공식적으로 승인되지 않았기 때문에 여가 시간에 해야 합니다. 이 여가 시간은 방해 요소가 없기 때문에 더 생산적인 것으로 밝혀집니다. 새로운 프로젝트에 대한 열정으로 그는 오랜 시간 동안 쉬지 않고 작업합니다. 처음에는 단지 실험이기 때문에, '생산' 언어 대신 '스크립팅' 언어라는 단지 훨씬 더 강력한 언어를 사용합니다. 그는 프로그램을 여러 번 완전히 다시 작성합니다. 이는 공식 프로젝트에서는 정당화될 수 없지만, 이것은 열정으로 하는 일이며 그는 완벽하게 만들고 싶어 합니다. 그리고 그 외에는 아무도 보지 않을 것이기 때문에, 자신을 위한 메모 외에는 어떤 주석도 달지 않습니다. 그는 어쩔 수 없이 소규모 그룹으로 작업합니다. 왜냐하면 아직 아무에게도 아이디어를 말하지 않았거나, 너무 가망 없어 보여서 아무도 그 일을 할 수 없기 때문입니다. 그룹이 있더라도, 코드가 너무 빨리 변하기 때문에 여러 사람이 같은 코드를 편집할 수 없습니다. 그리고 프로젝트는 아이디어가 처음에는 작기 때문에 작게 시작합니다. 그는 단지 시도해보고 싶은 멋진 해킹 (hack) 아이디어를 가지고 있을 뿐입니다.

훨씬 더 놀라운 것은 공식적으로 승인된 프로젝트들이 이 여덟 가지를 모두 '잘못' 해내는 경우가 많다는 것입니다. 사실, 대부분의 조직에서 소프트웨어가 작성되는 방식을 보면, 마치 고의적으로 잘못된 방식으로 일을 하려고 하는 것과 같습니다. 어떤 의미에서는 그렇습니다. 조직의 정의적인 특성 중 하나는 개별 구성원을 교체 가능한 부품으로 취급하는 것입니다. 이는 전쟁과 같이 더 병렬화 가능한 작업에는 잘 작동합니다. 역사상 대부분의 기간 동안, 잘 훈련된 직업 군대는 아무리 용맹하더라도 개별 전사들의 군대를 이길 수 있다고 여겨졌습니다. 그러나 아이디어를 내는 것은 병렬화가 잘 되지 않습니다. 그리고 프로그램이란 바로 아이디어입니다.

조직이 개인의 천재성에 의존하는 것을 싫어한다는 것은 단순한 사실이 아니라, 자명한 이치입니다. 적어도 우리가 현재 가진 조직의 개념에서는 그렇게 하지 않는 것이 정의의 일부입니다.

아마도 우리는 개인의 노력을 통합하면서도 그들이 교체 가능할 것을 요구하지 않는 새로운 종류의 조직을 정의할 수 있을 것입니다. 시장은 그러한 형태의 조직이라고 주장할 수도 있지만, 시장을 조직화가 불가능할 때 기본적으로 얻게 되는 퇴행적인 경우로 설명하는 것이 더 정확할 수도 있습니다.

아마도 우리가 할 수 있는 최선은 조직의 프로그래밍 부분을 나머지 부분과 다르게 작동하도록 만드는 일종의 해킹일 것입니다. 어쩌면 최적의 해결책은 대기업이 아이디어를 자체적으로 개발하려고 시도하지 않고, 단순히 '구매'하는 것일 수도 있습니다. 하지만 해결책이 무엇이든 간에, 첫 번째 단계는 문제가 있다는 것을 깨닫는 것입니다. '소프트웨어 회사'라는 문구 자체에 모순이 있습니다. 두 단어는 서로 반대 방향으로 나아가고 있습니다.

대규모 조직의 모든 유능한 프로그래머는 조직과 갈등을 겪을 것입니다. 왜냐하면 조직은 프로그래머들이 추구하는 것을 방해하도록 설계되어 있기 때문입니다.

유능한 프로그래머들은 그럼에도 불구하고 많은 것을 해냅니다. 하지만 종종 그것은 자신을 고용한 조직에 대한 사실상의 반항 행위를 요구합니다. 아마도 프로그래머들의 행동 방식이 그들이 하는 일의 요구 사항에 의해 결정된다는 것을 더 많은 사람들이 이해한다면 도움이 될 것입니다.

그들이 무책임해서 다른 모든 의무를 제쳐두고 오랜 시간 몰입해서 일하고, 먼저 사양서를 작성하는 대신 바로 프로그래밍에 뛰어들고, 이미 작동하는 코드를 다시 작성하는 것이 아닙니다. 그들이 비우호적이어서 혼자 일하는 것을 선호하거나, 문에 머리를 내밀고 인사하는 사람들에게 으르렁거리는 것이 아닙니다. 겉보기에 무작위적인 이 짜증나는 습관들의 공통적인 설명은 바로 '프로그램을 머릿속에 담는 힘'입니다.

이러한 이해가 대규모 조직에 도움이 될지는 모르겠지만, 경쟁자들에게는 확실히 도움이 될 수 있습니다. 대기업의 가장 약한 점은 개별 프로그래머가 훌륭한 작업을 할 수 있도록 허용하지 않는다는 것입니다. 따라서 여러분이 작은 스타트업이라면, 이곳이 그들을 공격할 지점입니다. 하나의 거대한 두뇌로 해결해야 하는 종류의 문제에 도전하십시오.

이 초안을 읽어준 샘 올트먼 (Sam Altman), 데이비드 그린스팬 (David Greenspan), 애런 이바 (Aaron Iba), 제시카 리빙스턴 (Jessica Livingston), 로버트 모리스 (Robert Morris), 피터 노르비그 (Peter Norvig), 리사 랜달 (Lisa Randall), 에밋 시어 (Emmett Shear), 세르게이 차레프 (Sergei Tsarev), 스티븐 울프람 (Stephen Wolfram)에게 감사드립니다.