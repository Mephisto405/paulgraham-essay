# 웹 기반 애플리케이션을 위한 리스프 (Lisp for Web-Based Applications)

슬래시닷(slashdot)에 '평균을 이기는 방법(Beating the Averages)' 이라는 글의 링크가 게시된 후, 일부 독자들은 우리가 비아웹(Viaweb)에서 리스프(Lisp)를 사용함으로써 얻었던 구체적인 기술적 이점에 대해 더 자세히 듣고 싶어 했습니다. 관심 있는 분들을 위해, 2001년 4월 매사추세츠주 케임브리지에 있는 BBN 랩스에서 제가 강연했던 내용 중 일부를 발췌했습니다.

# 웹 기반 애플리케이션에서의 리스프 (Lisp in Web-Based Applications)

폴 그레이엄 (Paul Graham)

(이 글은 2001년 4월 매사추세츠주 케임브리지 BBN 연구소에서 진행된 강연의 발췌문입니다.)

## 원하는 어떤 언어든 (Any Language You Want)

웹 기반 애플리케이션을 작성할 때 리스프(Lisp)를 사용하는 이유 중 하나는 리스프를 *사용할 수* 있기 때문입니다. 자체 서버에서만 실행될 소프트웨어를 작성할 때는 원하는 어떤 언어든 사용할 수 있습니다. 오랫동안 프로그래머들은 애플리케이션 프로그램을 작성할 언어에 대해 많은 선택권이 없었습니다. 최근까지 애플리케이션 프로그램을 작성한다는 것은 데스크톱 컴퓨터에서 실행되는 소프트웨어를 작성한다는 의미였습니다. 데스크톱 소프트웨어에서는 운영체제(OS)와 동일한 언어로 애플리케이션을 작성하는 경향이 강했습니다. 10년 전만 해도 실질적으로 애플리케이션은 C 언어로 작성되었습니다.

웹 기반 애플리케이션에서는 이러한 상황이 변합니다. 서버를 제어하기 때문에 원하는 어떤 언어로든 소프트웨어를 작성할 수 있습니다. 이제는 운영체제(OS)와 컴파일러의 소스 코드(source code)를 모두 가지고 있다는 것을 당연하게 여길 수 있습니다. 만약 언어와 OS 사이에 어떤 종류의 문제가 발생한다면, 직접 고칠 수 있습니다. 그러나 이러한 새로운 자유는 양날의 검입니다. 더 많은 선택지가 있다는 것은 이제 어떤 선택을 할지 고민해야 한다는 것을 의미합니다. 옛날에는 더 쉬웠습니다. 소프트웨어 프로젝트를 담당하고 있는데, 어떤 귀찮은 사람이 평소 사용하던 언어가 아닌 다른 언어로 소프트웨어를 작성하자고 제안하면, 비실용적이라고 말하면 끝이었습니다. 이제 서버 기반 애플리케이션에서는 모든 것이 변했습니다. 이제는 선택하는 언어에 시장 원리(market forces)가 적용됩니다. 만약 아무것도 변하지 않은 척하고, 대부분의 경쟁사처럼 C와 C++만 계속 사용한다면, 몰락할 준비를 하는 셈입니다. 더 강력한 언어를 사용하는 작은 스타트업이 당신의 점심을 빼앗아 갈 것입니다.

## 점진적 개발 (Incremental Development)

리스프와 관련된 특정 소프트웨어 개발 방식이 있습니다. 그 전통 중 하나는 점진적 개발(incremental development)입니다. 이 방식은 거의 아무것도 하지 않는 프로그램을 가능한 한 빨리 작성하는 것으로 시작하여, 점진적으로 기능을 추가하되, 모든 단계에서 작동하는 코드(working code)를 유지합니다. 저는 이 방법으로 더 나은 소프트웨어를 더 빠르게 작성할 수 있다고 생각합니다. 리스프 프로그래머들은 최소 30년 동안 이런 방식으로 작업해 왔기 때문에, 리스프의 모든 것은 이러한 프로그래밍 스타일에 맞춰져 있습니다.

비아웹(Viaweb) 에디터는 점진적 개발의 가장 극단적인 사례 중 하나였을 것입니다. 이 에디터는 비아웹을 시작하기 직전에 제가 끝낸 책의 예시로 사용했던 120줄짜리 웹사이트 생성 프로그램으로 시작되었습니다. 결국 약 25,000줄의 코드로 성장한 비아웹 에디터는 이 프로그램에서 점진적으로 성장했습니다. 저는 한 번도 앉아서 전체를 다시 작성한 적이 없습니다. 저는 실행되는 코드 없이 하루나 이틀 이상을 보낸 적이 없다고 생각합니다. 전체 개발 과정은 길고 점진적인 변화의 연속이었습니다. 이러한 개발 스타일은 웹 기반 소프트웨어에서 가능한 롤링 릴리스(rolling releases)와 잘 맞습니다. 또한 일반적으로 소프트웨어를 더 빠르게 작성하는 방법이기도 합니다.

## 대화형 탑레벨 (Interactive Toplevel)

리스프의 대화형 탑레벨(interactive toplevel)은 소프트웨어를 빠르게 개발하는 데 큰 도움이 됩니다. 하지만 우리에게 가장 큰 이점은 아마도 버그(bug)를 찾는 데 있었을 것입니다. 앞서 언급했듯이, 웹 기반 애플리케이션에서는 사용자 데이터가 서버에 있고 일반적으로 버그를 재현할 수 있습니다. 고객 지원팀 직원 중 한 명이 에디터의 버그 보고서를 가지고 오면, 저는 코드를 리스프 인터프리터(interpreter)에 로드하고 사용자 계정에 로그인했습니다. 버그를 재현할 수 있다면 실제 브레이크 루프(break loop)가 발생하여 정확히 무엇이 잘못되었는지 알려주었습니다. 종종 코드를 수정하고 즉시 수정 사항을 릴리스(release)할 수 있었습니다. 즉시라고 말하는 것은 사용자가 여전히 전화상에 있을 때를 의미합니다.

버그 수정에 대한 이러한 빠른 처리 시간은 우리를 상상할 수 없을 정도로 매력적인 위치에 놓이게 했습니다. 사용자가 여전히 전화상에 있을 때 버그를 잡아서 수정할 수 있다면, 사용자에게 그들이 착각하고 있다는 인상을 주는 것이 매우 유혹적이었습니다. 그래서 우리는 때때로 (그들의 기쁨을 위해) 고객 지원팀 직원들에게 사용자에게 다시 로그인하여 여전히 문제가 있는지 확인하라고 말하게 했습니다. 물론 사용자가 다시 로그인하면 버그가 수정된 새로 릴리스된 버전의 소프트웨어를 받게 되고, 모든 것이 잘 작동했습니다. 이것이 약간 교활했다는 것을 알지만, 또한 매우 재미있었습니다.

## HTML을 위한 매크로 (Macros for Html)

리스프 매크로(macro)는 우리에게 또 다른 큰 이점이었습니다. 우리는 비아웹 에디터에서 매크로를 매우 광범위하게 사용했습니다. 이 에디터는 하나의 거대한 매크로로 정확하게 설명될 수 있습니다. 그리고 이는 우리가 리스프에 얼마나 의존했는지 알려줍니다. 왜냐하면 다른 어떤 언어도 리스프와 같은 의미의 매크로를 가지고 있지 않기 때문입니다.

우리가 매크로를 사용한 한 가지 방법은 HTML을 생성하는 것이었습니다. 매크로와 HTML 사이에는 매우 자연스러운 조합이 있습니다. 왜냐하면 HTML은 리스프처럼 전위 표기법(prefix notation)이고, HTML은 리스프처럼 재귀적(recursive)이기 때문입니다. 그래서 우리는 매크로 호출 안에 매크로 호출을 사용하여 가장 복잡한 HTML을 생성했는데, 이 모든 것이 여전히 매우 관리하기 쉬웠습니다.

## 임베디드 언어 (Embedded Languages)

매크로의 또 다른 큰 용도는 페이지를 설명하기 위해 우리가 사용했던 임베디드 언어(embedded language)인 RTML이었습니다. (우리는 RTML이 무엇을 의미하는지에 대해 다양한 설명을 지어냈지만, 실제로는 비아웹의 다른 창업자인 로버트 모리스(Robert Morris)의 사용자 이름이 Rtm이라서 그의 이름을 따서 지었습니다.) 우리 소프트웨어로 만들어진 모든 페이지는 RTML로 작성된 프로그램에 의해 생성되었습니다. 우리는 이 프로그램들을 덜 위협적으로 보이게 하기 위해 템플릿(template)이라고 불렀지만, 그것들은 실제 프로그램이었습니다. 사실, 그것들은 리스프 프로그램이었습니다.

RTML은 매크로와 내장 리스프 연산자의 조합이었습니다. 사용자들은 페이지가 어떻게 보이기를 원하는지 설명하기 위해 자신만의 RTML 템플릿을 작성할 수 있었습니다. 우리는 이러한 템플릿을 조작하기 위한 구조 편집기(structure editor)를 가지고 있었는데, 인터리스프(Interlisp)에 있던 구조 편집기와 매우 유사했습니다. 자유 형식 텍스트를 입력하는 대신, 코드 조각들을 잘라 붙였습니다. 이는 구문 오류(syntax errors)가 발생할 수 없다는 것을 의미했습니다. 또한 기본 S-표현식(s-expressions)에서 괄호를 표시할 필요가 없다는 것을 의미했습니다. 들여쓰기(indentation)를 통해 구조를 보여줄 수 있었습니다. 이러한 방식으로 우리는 언어를 훨씬 덜 위협적으로 보이게 만들었습니다.

또한 우리는 런타임(runtime)에 오류가 없도록 RTML을 설계했습니다. 모든 RTML 프로그램은 어떤 종류의 웹 페이지를 생성했으며, 의도한 페이지를 생성할 때까지 해킹(hacking)하여 디버그(debug)할 수 있었습니다. 처음에는 우리 사용자들이 웹 컨설턴트일 것이라고 예상했고, 그들이 RTML을 많이 사용할 것이라고 예상했습니다. 우리는 섹션 페이지와 아이템 페이지 등을 위한 몇 가지 기본 템플릿을 제공했고, 사용자들은 그것들을 가져와서 원하는 페이지를 만들 수 있도록 수정할 수 있다는 생각이었습니다.

사실 웹 컨설턴트들은 비아웹을 좋아하지 않는 것으로 나타났습니다. 컨설턴트들은 일반적으로 고객이 사용하기에는 너무 어려운 제품을 사용하는 것을 좋아합니다. 왜냐하면 그것이 지속적인 고용을 보장하기 때문입니다. 컨설턴트들은 우리 웹사이트에 와서, 우리 소프트웨어가 너무 사용하기 쉬워서 누구나 5분 안에 온라인 상점을 만들 수 있다고 적힌 것을 보고는, "우리는 절대로 그걸 사용하지 않을 거야"라고 말했습니다. 그래서 우리는 웹 컨설턴트들로부터 많은 관심을 얻지 못했습니다. 대신 사용자들은 모두 최종 사용자, 즉 실제 상인들인 경향이 있었습니다. 그들은 자신들의 웹사이트를 직접 통제하는 아이디어를 좋아했습니다. 그리고 이런 종류의 사용자들은 어떤 종류의 프로그래밍도 하고 싶어 하지 않았습니다. 그들은 그냥 기본 템플릿을 사용했습니다.

그래서 RTML은 프로그램의 주요 인터페이스가 되지 못했습니다. 대신 두 가지 역할을 하게 되었습니다. 첫째, RTML은 우리 내장 템플릿이 제공할 수 없는 것을 원하는 정말 정교한 사용자들을 위한 비상구(escape valve)였습니다. 비아웹을 운영하는 동안 누군가 저에게 매우 유용한 조언을 해주었습니다. 사용자들은 일반적으로 업그레이드 경로(upgrade path)를 원하지만, 규칙적으로는 결코 그 경로를 택하지 않는다는 것입니다. RTML은 우리의 업그레이드 경로였습니다. 원한다면, 페이지의 모든 것을 절대적으로 제어할 수 있었습니다. 2백 명 중 한 명의 사용자만이 실제로 자신만의 템플릿을 작성했습니다.

그리고 이것이 RTML의 두 번째 장점으로 이어졌습니다. 이 사용자들이 우리의 내장 템플릿을 수정하는 방식을 살펴보면서, 우리는 무엇을 추가해야 할지 알 수 있었습니다. 결국 우리는 아무도 RTML을 사용해야 할 필요가 없도록 하는 것을 목표로 삼았습니다. 우리의 내장 템플릿이 사람들이 원하는 모든 것을 수행해야 했습니다. 이러한 새로운 접근 방식에서 RTML은 우리 소프트웨어에 뭔가 빠져 있다는 경고 신호 역할을 했습니다.

RTML을 사용하여 얻은 세 번째이자 가장 큰 이점은 우리가 직접 얻은 이점이었습니다. 우리가 RTML을 사용한 유일한 사람들이었다 하더라도, 그런 방식으로 소프트웨어를 작성하는 것은 매우 가치 있는 일이었습니다. 우리 소프트웨어에 그 추가적인 추상화(abstraction) 계층을 두는 것은 경쟁사보다 큰 이점을 주었습니다. 무엇보다도 우리 소프트웨어의 설계를 훨씬 더 깔끔하게 만들었습니다. 경쟁사처럼 웹 페이지를 생성하는 실제 C 또는 펄(Perl) 코드 조각들을 사용하는 대신, 우리는 웹 페이지를 생성하는 매우 높은 수준의 언어를 가졌고, 우리 페이지 스타일은 그 언어로 지정되었습니다. 그것은 코드를 훨씬 더 깔끔하고 수정하기 쉽게 만들었습니다.

웹 기반 소프트웨어가 많은 작은 수정 사항들의 연속으로 릴리스된다는 것을 이미 언급했습니다. 그렇게 할 때는 주어진 수정 사항이 얼마나 심각한지 알 수 있어야 합니다. 코드를 계층(layers)으로 나누면 이것을 더 잘 파악할 수 있습니다. 하위 계층(RTML 자체)의 내용을 수정하는 것은 드물게 신중하게 수행되어야 하는 심각한 문제였습니다. 반면, 최상위 계층(템플릿 코드)을 수정하는 것은 결과에 대해 너무 걱정하지 않고 빠르게 할 수 있는 일이었습니다.

RTML은 매우 리스프스러운(Lispy) 개념이었습니다. 우선 대부분 리스프 매크로로 시작되었습니다. 온라인 에디터는 내부적으로 S-표현식(s-expressions)을 조작하고 있었습니다. 그리고 사람들이 템플릿을 실행할 때, 런타임(runtime)에 `compile`을 호출하여 리스프 함수로 컴파일되었습니다. RTML은 심지어 키워드 매개변수(keyword parameters)에 크게 의존했는데, 그때까지 저는 그것이 커먼 리스프(Common Lisp)의 가장 의심스러운 기능 중 하나라고 생각했었습니다.

웹 기반 소프트웨어가 릴리스되는 방식 때문에, 소프트웨어를 변경하기 쉽도록 설계해야 합니다. 그리고 RTML 자체도 다른 소프트웨어 부분과 마찬가지로 변경하기 쉬워야 했습니다. RTML의 대부분의 연산자들은 키워드 매개변수를 받도록 설계되었는데, 이것이 큰 도움이 되었습니다. 만약 제가 어떤 연산자의 동작에 또 다른 차원을 추가하고 싶다면, 새로운 키워드 매개변수만 추가하면 되었고, 모든 기존 템플릿은 계속 작동했습니다. 몇몇 RTML 연산자들은 키워드 매개변수를 받지 않았는데, 제가 변경할 필요가 없을 것이라고 생각했기 때문이었고, 거의 모든 경우에 나중에 후회했습니다. 만약 제가 처음부터 다시 시작할 수 있다면, 제가 변경할 것 중 하나는 모든 RTML 연산자가 키워드 매개변수를 받도록 하는 것이었을 겁니다.

사실 우리는 에디터 안에 몇 개의 임베디드 언어를 가지고 있었습니다. 사용자에게 직접 노출되지 않은 또 다른 언어는 이미지를 설명하는 데 사용되었습니다. 비아웹은 C로 작성된 이미지 생성기를 포함하고 있었는데, 이 생성기는 이미지에 대한 설명을 받아 이미지를 생성하고 해당 URL을 반환할 수 있었습니다. 우리는 이 이미지들을 설명하는 데도 S-표현식(s-expressions)을 사용했습니다.

## 클로저로 서브루틴 시뮬레이션 (Closures Simulate Subroutines)

웹 페이지를 사용자 인터페이스(UI)로 사용하는 문제 중 하나는 웹 세션의 본질적인 상태 없음(statelessness)입니다. 우리는 렉시컬 클로저(lexical closure)를 사용하여 서브루틴(subroutine)과 유사한 동작을 시뮬레이션함으로써 이 문제를 해결했습니다. 만약 컨티뉴에이션(continuation)에 대해 이해한다면, 우리가 한 일을 설명하는 한 가지 방법은 우리가 소프트웨어를 컨티뉴에이션 전달 스타일(continuation-passing style)로 작성했다고 말하는 것입니다.

대부분의 웹 기반 소프트웨어가 페이지에 링크를 생성할 때, 사용자가 이 링크를 클릭하면 이 CGI 스크립트(CGI script)를 이러한 인자(argument)로 호출하고 싶다고 생각하는 경향이 있습니다. 우리 소프트웨어가 링크를 생성할 때, 사용자가 이 링크를 클릭하면 이 코드 조각을 실행하고 싶다고 생각할 수 있었습니다. 그리고 그 코드 조각은 임의의 코드 조각일 수 있었으며, 주변 컨텍스트(surrounding context)에서 온 값을 가지는 자유 변수(free variables)를 포함할 수 있었습니다(사실, 보통 포함했습니다).

우리가 이 작업을 수행한 방법은 첫 번째 인자가 클로저(closure)이고 그 뒤에 코드 본문이 오는 매크로를 작성하는 것이었습니다. 코드는 고유 ID(unique id) 아래에 전역 해시 테이블(hash table)에 저장되었고, 코드 본문에서 생성된 모든 출력은 해당 해시 키(hash key)를 포함하는 URL을 가진 링크 내에 나타났습니다. 만약 그 링크가 다음에 클릭되면, 우리 소프트웨어는 해당 코드 조각을 찾아 호출했고, 체인은 계속되었습니다. 효과적으로 우리는 즉석에서 CGI 스크립트를 작성하고 있었는데, 그것들은 주변 컨텍스트를 참조할 수 있는 클로저였습니다.

지금까지는 매우 이론적으로 들리므로, 이 기술이 명확한 차이를 만든 한 가지 예를 들어보겠습니다. 웹 기반 애플리케이션에서 자주 하고 싶은 일 중 하나는 다양한 유형의 속성(properties)을 가진 객체(object)를 편집하는 것입니다. 객체의 많은 속성은 양식 필드(form field) 또는 메뉴로 표현될 수 있습니다. 예를 들어, 사람을 나타내는 객체를 편집하는 경우, 이름 필드, 직함에 대한 메뉴 선택지 등을 얻을 수 있습니다.

이제 어떤 객체가 색상 속성을 가질 경우 어떻게 될까요? 모든 것이 하나의 양식에서 맨 아래의 "업데이트" 버튼으로 이루어져야 하는 일반적인 CGI 스크립트를 사용한다면, 어려움을 겪을 것입니다. 텍스트 필드를 사용하여 사용자에게 RGB 값(RGB number)을 입력하게 할 수 있지만, 최종 사용자들은 그것을 좋아하지 않습니다. 또는 가능한 색상 메뉴를 가질 수 있지만, 그렇게 되면 가능한 색상을 제한해야 하거나, 그렇지 않으면 표준 웹 컬러맵(Web colormap)만 제공하더라도 거의 구별할 수 없는 이름의 메뉴 항목이 256개 필요할 것입니다.

비아웹에서 우리가 할 수 있었던 것은 현재 값을 나타내는 색상 견본(swatch)을 표시하고, 그 뒤에 "변경" 버튼을 추가하는 것이었습니다. 사용자가 "변경" 버튼을 클릭하면, 선택할 수 있는 색상 이미지맵(imagemap)이 있는 페이지로 이동했습니다. 그리고 색상을 선택한 후에는 객체의 속성을 편집하던 페이지로 돌아와 그 색상이 변경된 상태로 나타났습니다. 이것이 제가 서브루틴과 유사한 동작을 시뮬레이션한다는 의미입니다. 소프트웨어는 색상을 선택한 후 돌아온 것처럼 동작할 수 있었습니다. 물론 실제로 돌아온 것은 아니었습니다. 스택(stack)을 거슬러 올라가는 것처럼 보이는 새로운 CGI 호출을 하는 것이었습니다. 하지만 클로저를 사용함으로써, 사용자에게 그리고 우리 자신에게 마치 서브루틴 호출을 하는 것처럼 보이게 만들 수 있었습니다.

우리는 다음과 같이 코드를 작성할 수 있었습니다. 사용자가 이 링크를 클릭하면 색상 선택 페이지로 이동한 다음 여기로 돌아옵니다. 이것은 우리가 이 가능성을 활용한 여러 장소 중 하나였습니다. 이것은 우리 소프트웨어를 경쟁사의 소프트웨어보다 시각적으로 더 정교하게 만들었습니다.